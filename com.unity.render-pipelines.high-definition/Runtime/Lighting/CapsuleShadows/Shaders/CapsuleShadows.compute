#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/NormalBuffer.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/CapsuleShadows/ShaderVariablesCapsuleShadows.cs.hlsl"
#include "Packages/com.unity.render-pipelines.core/Runtime/Lighting/CapsuleShadows/Shaders/CapsuleShadows.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/CapsuleShadows/CapsuleOccluderData.cs.hlsl"

#pragma only_renderers d3d11 playstation xboxone xboxseries vulkan metal switch
//#pragma enable_d3d11_debug_symbols

#pragma kernel CapsuleShadowMain

RW_TEXTURE2D_X(float2, _CapsuleShadowTexture);
StructuredBuffer<CapsuleOccluderData> _CapsuleOccluderDatas;

#define _FirstDepthMipOffset uint2(_FirstDepthMipOffsetX, _FirstDepthMipOffsetY)

#define DEPTH_MIN_EMPTY 0xffffffffU
groupshared uint s_depthMin;
groupshared uint s_depthMax;
groupshared uint s_capsuleBits[2];

#if USE_LEFT_HAND_CAMERA_SPACE
#define PACK_UNPACK_POSITIVE_DEPTH(D)   (D)
#else
#define PACK_UNPACK_POSITIVE_DEPTH(D)   (-(D))
#endif

float3 ViewspaceFromXY(float2 posVS_XY, float linearDepth)
{
    return float3(posVS_XY * abs(linearDepth), linearDepth);
}

#define TILE_SIZE   8

[numthreads(TILE_SIZE,TILE_SIZE,1)]
void CapsuleShadowMain(uint3 dispatchThreadId : SV_DispatchThreadID, uint flatThreadIndex : SV_GroupIndex)
{
    uint2 pixelCoord = dispatchThreadId.xy;
    UNITY_XR_ASSIGN_VIEW_INDEX(dispatchThreadId.z);

    float deviceDepth = LOAD_TEXTURE2D_X(_CameraDepthTexture, pixelCoord + (_CapsulesFullResolution ? 0 : _FirstDepthMipOffset)).x;
    bool is_sky = (deviceDepth == UNITY_RAW_FAR_CLIP_VALUE);

    float4 normalBufferData = LOAD_TEXTURE2D_X(_NormalBufferTexture, pixelCoord * (_CapsulesFullResolution ? 1 : 2));

    float4 positionCS = ComputeClipSpacePosition((pixelCoord + .5f)*_OutputSize.zw, deviceDepth);

    // TODO: handle orthographic
    float4x4 invProj = UNITY_MATRIX_I_P;
    float linearDepth = invProj._m23/(invProj._m32 * positionCS.z + invProj._m33);
    float2 viewFromClipScale = float2(invProj._m00, invProj._m11);
    float2 viewFromClipOffset = float2(invProj._m03, invProj._m13);

    float2 positionVS_XY = viewFromClipScale*positionCS.xy + viewFromClipOffset;
    float3 positionWS = TransformViewToWorld(ViewspaceFromXY(positionVS_XY, linearDepth));

    NormalData normalData;
    DecodeFromNormalBuffer(normalBufferData, normalData);
    float3 normalWS = normalData.normalWS;

    if (flatThreadIndex == 0)
    {
        s_depthMin = DEPTH_MIN_EMPTY;
        s_depthMax = 0;
    }
    GroupMemoryBarrierWithGroupSync();

    if (!is_sky)
    {
        float depth = max(0.f, PACK_UNPACK_POSITIVE_DEPTH(linearDepth));
        InterlockedMin(s_depthMin, asuint(depth));
        InterlockedMax(s_depthMax, asuint(depth));
    }
    GroupMemoryBarrierWithGroupSync();

    // early out if tile is all far clip
    if (s_depthMin == DEPTH_MIN_EMPTY)
        return;

    // TODO: splitting planes for froxel
    // TODO: move work to setup pass to run as one tile per thread
    // TODO: save/restore to LDS each pass to free up registers
    // TODO: two depth ranges, to handle edges better
    // for now just make a bounding sphere using all threads
    float nearLinearDepth = PACK_UNPACK_POSITIVE_DEPTH(asfloat(s_depthMin));
    float farLinearDepth = PACK_UNPACK_POSITIVE_DEPTH(asfloat(s_depthMax));

    // build viewspace bounds
    float midLinearDepth = 0.5f*(nearLinearDepth + farLinearDepth);
    float3 tileCenterVS = ViewspaceFromXY(positionVS_XY, midLinearDepth);

    // TODO: optimise
    float tileRadiusSqVS = 0.f;
    for (int i = 0; i < 8; ++i) {
        float2 cornerVS_XY = positionVS_XY + float2((i & 1) != 0 ? 1.f : -1.f, (i & 2) != 0 ? 1.f : -1.f)*viewFromClipScale*_OutputSize.zw*TILE_SIZE;
        float cornerLinearDepth = ((i & 4) != 0 ? nearLinearDepth : farLinearDepth);
        float3 offsetVS = ViewspaceFromXY(cornerVS_XY, cornerLinearDepth) - tileCenterVS;
        tileRadiusSqVS = max(tileRadiusSqVS, dot(offsetVS, offsetVS));
    }
    float3 tileCenterWS = TransformViewToWorld(tileCenterVS);
    float tileRadiusWS = sqrt(tileRadiusSqVS) * abs(UNITY_MATRIX_I_V._m00);


    // loop over capsules in batches of 64
    // TODO: make 32, check 2 depth ranges per capsule
    float directVisibility = 1.f;
    float indirectVisibility = 1.f;
    uint capsuleCount = _CapsuleDirectShadowCount + (_CapsuleIndirectShadowCountAndFlags & CAPSULEINDIRECTSHADOWFLAGS_COUNT_MASK);
    for (uint capsuleBaseIndex = 0; capsuleBaseIndex < capsuleCount; capsuleBaseIndex += 64)
    {
        // clear state
        if (flatThreadIndex < 2)
        {
            s_capsuleBits[flatThreadIndex] = 0;
        }
        GroupMemoryBarrierWithGroupSync();

        // use one thread per capsule to check against tile
        // TODO: check if any pixels still visible?
        {
            uint capsuleIndex = capsuleBaseIndex + flatThreadIndex;
            if (capsuleIndex < capsuleCount)
            {
                CapsuleOccluderData capsuleData = _CapsuleOccluderDatas[capsuleIndex];

                float3 offsetWS = capsuleData.centerRWS - tileCenterWS;
                float centerToCenterDistSq = dot(offsetWS, offsetWS);

                bool intersectsTile = false;
                if (capsuleIndex < _CapsuleDirectShadowCount)
                {
                    float lightT = max(0.f, dot(offsetWS, _CapsuleLightDir));
                    float tileInfluenceRadius = tileRadiusWS + lightT * _CapsuleLightTanTheta;
                    float3 checkOffsetWS = offsetWS - _CapsuleLightDir*lightT;
                    bool intersectsPenumbra = (dot(checkOffsetWS, checkOffsetWS) < Sq(tileInfluenceRadius + capsuleData.offset + capsuleData.radius));

                    float directRangeWS = capsuleData.offset + capsuleData.radius + _CapsuleShadowRange;
                    bool intersectsRange = (centerToCenterDistSq < Sq(directRangeWS + tileRadiusWS));

                    intersectsTile = intersectsPenumbra && intersectsRange;
                }
                else
                {
                    float indirectRangeWS = capsuleData.offset + capsuleData.radius*(1.f + _CapsuleIndirectRangeFactor);
                    intersectsTile = (centerToCenterDistSq < Sq(indirectRangeWS + tileRadiusWS));
                }

                if (intersectsTile)
                    InterlockedOr(s_capsuleBits[flatThreadIndex/32], 1U << (flatThreadIndex % 32));
            }
        }
        GroupMemoryBarrierWithGroupSync();

        // loop over set bits to do the shading
        uint remainingBits = s_capsuleBits[0];
        bool secondPass = false;
        for (;;)
        {
            if (remainingBits == 0 && !secondPass)
            {
                remainingBits = s_capsuleBits[1];
                secondPass = true;
            }
            if (remainingBits == 0)
                break;

            int bitIndex = firstbitlow(remainingBits);
            remainingBits &= ~(1U << bitIndex);

            uint capsuleIndex = capsuleBaseIndex + (secondPass ? 32 : 0) + (uint)bitIndex;

            CapsuleOccluderData capsuleData = _CapsuleOccluderDatas[capsuleIndex];
            if (capsuleIndex < _CapsuleDirectShadowCount)
            {
                uint flags = CAPSULE_SHADOW_FLAG_FLATTEN | CAPSULE_SHADOW_FLAG_FADE_SELF_SHADOW;
                float occlusion = EvaluateCapsuleOcclusion(
                    flags,
                    _CapsuleLightDir,
                    false,
                    _CapsuleLightCosTheta,
                    capsuleData.centerRWS - positionWS,
                    capsuleData.axisDirWS,
                    capsuleData.offset,
                    capsuleData.radius,
                    _CapsuleShadowRange,
                    normalWS);
                directVisibility *= max(1.f - occlusion, 0.0f);
            }
            else
            {
                uint flags = CAPSULEAMBIENTOCCLUSIONMETHOD_LINE_AND_CLOSEST_SPHERE;
                float occlusion = EvaluateCapsuleAmbientOcclusion(
                    flags,
                    capsuleData.centerRWS - positionWS,
                    capsuleData.axisDirWS,
                    capsuleData.offset,
                    capsuleData.radius,
                    capsuleData.radius*_CapsuleIndirectRangeFactor,
                    normalWS);
                indirectVisibility *= max(1.f - occlusion, 0.f);
            }
        }
    }

    _CapsuleShadowTexture[COORD_TEXTURE2D_X(pixelCoord)] = float2(1.f - directVisibility, 1.f - indirectVisibility);
}
