#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Visibility/VisibilityOITResources.hlsl"

//#pragma enable_d3d11_debug_symbols

#pragma kernel MainInitialize
#pragma kernel MainTileComputeHiZ

#define GROUP_SIZE 8

#if defined(USE_TEXTURE2D_X_AS_ARRAY)
RWTexture2DArray<float4> _OITTileHiZOutput;
#else
RWTexture2D<float4> _OITTileHiZOutput;
#endif

uint4 _SrcOffsetAndLimit;
uint4 _DstOffset;

float4 _VBufferLightingOffscreenParams;

uint GetOffscreenLightBufferWidth()
{
    return asuint(_VBufferLightingOffscreenParams.x);
}

[numthreads(GROUP_SIZE, GROUP_SIZE, 1)]
void MainInitialize(int3 dispatchThreadID : SV_DispatchThreadID)
{
    UNITY_XR_ASSIGN_VIEW_INDEX(dispatchThreadID.z);

    if (any((float2)dispatchThreadID.xy > _ScreenSize.xy))
    {
        return;
    }

    PositionInputs posInputs = GetPositionInput(float2(dispatchThreadID.xy), _ScreenSize.zw, uint2(GROUP_SIZE, GROUP_SIZE));

    uint pixelOffset = posInputs.positionSS.y * _ScreenSize.x + posInputs.positionSS.x;
    uint listCount, listOffset;
    VisibilityOIT::GetPixelList(pixelOffset, listCount, listOffset);
    if (listCount == 0)
    {
        //_OITTileHiZOutput[COORD_TEXTURE2D_X(dispatchThreadID.xy)] = float4(1.0f, 1.0f, UNITY_RAW_FAR_CLIP_VALUE, UNITY_RAW_FAR_CLIP_VALUE);
        _OITTileHiZOutput[COORD_TEXTURE2D_X(dispatchThreadID.xy)] = float4(_ProjectionParams.z, _ProjectionParams.z, UNITY_RAW_FAR_CLIP_VALUE, UNITY_RAW_FAR_CLIP_VALUE);

        return;
    }

    float minDepthDevice =  1e7f;
    float maxDepthDevice = -1e7f;
    float minDepthLinear =  1e7f;
    float maxDepthLinear = -1e7f;

    for (uint i = 0; i < listCount; ++i)
    {
        uint sortedSampleIndex = Sorting::GetSortedSampleIndex(i, listCount, listOffset);

        int globalOffset = sortedSampleIndex + listOffset;
        uint2 offscreenCoord = uint2(globalOffset % GetOffscreenLightBufferWidth(), globalOffset / GetOffscreenLightBufferWidth());

        Visibility::VisibilityData unusedVisData;
        uint2 unusedTexelCoord;
        float deviceDepth;
        float linearDepth;
        VisibilityOIT::GetVisibilitySampleWithLinearDepth(sortedSampleIndex, listOffset, unusedVisData, unusedTexelCoord, deviceDepth, linearDepth);

        uint4 packedOITGBuffer0 = _VisOITOffscreenGBuffer0[COORD_TEXTURE2D_X(offscreenCoord)].rgba;
        float3 normal;
        VisibilityOIT::UnpackOITNormalFromGBufferData0(packedOITGBuffer0, normal);

        //float2 minMax = GeomHelper::GetPixelMinMax(linearDepth, normal);
        float2 minMaxLinear = GeomHelper::GetPixelMinMax(linearDepth, normal);

        //float hitPerspective;
        //PlaneLineIntersection(zero, w0, center, float3(0, 0, 1), hitPerspective);

        //minDepth = min(linearDepth, minDepth);
        //maxDepth = max(linearDepth, maxDepth);
        minDepthLinear = min(minMaxLinear.x, minDepthLinear);
        maxDepthLinear = max(minMaxLinear.y, maxDepthLinear);

        minDepthDevice = min(deviceDepth, minDepthDevice);
        maxDepthDevice = max(deviceDepth, maxDepthDevice);
    }

    _OITTileHiZOutput[COORD_TEXTURE2D_X(dispatchThreadID.xy)] = float4(minDepthLinear, maxDepthLinear, minDepthDevice, maxDepthDevice);
}

[numthreads(GROUP_SIZE, GROUP_SIZE, 1)]
void MainTileComputeHiZ(int3 dispatchThreadID : SV_DispatchThreadID)
{
    UNITY_XR_ASSIGN_VIEW_INDEX(dispatchThreadID.z);

    uint2 srcLimit = _SrcOffsetAndLimit.zw;

    //if (any(dispatchThreadID.xy >= (int2)(2.0f*srcLimit.xy)))
    //    return;

    uint2 srcOffset = _SrcOffsetAndLimit.xy;
    uint2 dstOffset = _DstOffset.xy;

    float minDepthDevice =  1e7f;
    float maxDepthDevice = -1e7f;
    float minDepthLinear =  1e7f;
    float maxDepthLinear = -1e7f;

    uint2 srcPixel = srcOffset + (dispatchThreadID.xy << 1);

    // TODO: Replace this loop by GatherRed, GatherGreen
    UNITY_UNROLL
    for (int i = 0; i < 2; ++i)
    {
        UNITY_UNROLL
        for (int j = 0; j < 2; ++j)
        {
            float4 minMaxData = _OITTileHiZOutput[COORD_TEXTURE2D_X(min(srcPixel + uint2(i, j), srcLimit))].xyzw;
            float2 minMaxLinear = minMaxData.xy;
            float2 minMaxDevice = minMaxData.zw;

            minDepthLinear = min(minMaxLinear.x, minDepthLinear);
            maxDepthLinear = max(minMaxLinear.y, maxDepthLinear);
            minDepthDevice = min(minMaxDevice.x, minDepthDevice);
            maxDepthDevice = max(minMaxDevice.y, maxDepthDevice);
        }
    }

    _OITTileHiZOutput[COORD_TEXTURE2D_X(dstOffset + dispatchThreadID.xy)] = float4(minDepthLinear, maxDepthLinear, minDepthDevice, maxDepthDevice);
}
