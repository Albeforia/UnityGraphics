#ifdef SURFACE_GRADIENT
#undef SURFACE_GRADIENT
#endif
#ifdef DECAL_SURFACE_GRADIENT
#undef DECAL_SURFACE_GRADIENT
#endif

#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/TextureXR.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Visibility/VisibilityOITResources.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/PostProcessing/Shaders/PostProcessDefines.hlsl"

#define VARIANT_DIR_PUNCTUAL_AREA_ENV 1
#define HAS_LIGHTLOOP

#define DISABLE_APPLY_DEBUG_TO_LIGHTING

#define SHADERPASS SHADERPASS_VBUFFER_LIGHTING_OFFSCREEN

#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/LitProperties.hlsl"

#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/Lighting.hlsl"

#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/ShaderPass/LitDepthPass.hlsl"

#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoopDef.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoop.hlsl"

#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/LitData.hlsl"

#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/CommonLighting.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/EntityLighting.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Sky/SkyUtils.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/SDF2D.hlsl"

#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariablesFunctions.hlsl"

//#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/HDShadow.hlsl"
//#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoopDef.hlsl"
//#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/PunctualLightCommon.hlsl"
//#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoop.cs.hlsl"
//#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Builtin/BuiltinData.hlsl"
//#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoop.hlsl"

#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Visibility/VisibilityOITResources.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Visibility/VBufferDeferredMaterialCommon.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Visibility/BTDF.hlsl"

//#pragma enable_d3d11_debug_symbols
#pragma only_renderers d3d11 playstation xboxone xboxseries vulkan metal switch

#pragma kernel MainResolveOffscreenLighting

#define GROUP_SIZE 8

#if UNITY_REVERSED_Z
# define MIN_DEPTH(a, b) max(a, b)
#else
# define MIN_DEPTH(a, b) min(a, b)
#endif

TEXTURE2D_X(_DepthTexture);
RW_TEXTURE2D_X(float4, _OutputTexture);

float4 _VBufferLightingOffscreenParams;
int _OITHiZMaxMip;
StructuredBuffer<int2> _DepthPyramidMipLevelOffsets;

uint GetOffscreenLightBufferWidth()
{
    return asuint(_VBufferLightingOffscreenParams.x);
}

BuiltinData GetBuiltinData(float3 normal, float roughness, float3 diffuseAlbedo)
{
    BuiltinData builtinData;
    ZERO_INITIALIZE(BuiltinData, builtinData);

    //builtinData.opacity = 0.5f;
//    real alphaClipTreshold;
//    real3 bakeDiffuseLighting;
//    real3 backBakeDiffuseLighting;
    builtinData.shadowMask0 = 1.0f;
    builtinData.shadowMask1 = 1.0f;
    builtinData.shadowMask2 = 1.0f;
    builtinData.shadowMask3 = 1.0f;
    builtinData.emissiveColor = 0.0f;
//    real2 motionVector;
//    real2 distortion;
//    real distortionBlur;
//    uint isLightmap;
//    uint renderingLayers;
//    float depthOffset;
//#if defined(UNITY_VIRTUAL_TEXTURING)
//    real4 vtPackedFeedback;
//#endif

    return builtinData;
}

SurfaceData GetSurfaceData(float3 normal, float roughness, float3 diffuseAlbedo)
{
    SurfaceData surfaceData;
    ZERO_INITIALIZE(SurfaceData, surfaceData);

    //uint materialFeatures;
    surfaceData.baseColor = diffuseAlbedo;
    surfaceData.specularOcclusion = 1.0f;
    surfaceData.normalWS = normal;
    surfaceData.perceptualSmoothness = RoughnessToPerceptualSmoothness(roughness);
    surfaceData.ambientOcclusion = 1.0f;
    surfaceData.metallic = 0.0f;
    //real coatMask;
    surfaceData.specularColor = DEFAULT_SPECULAR_VALUE;
    //uint diffusionProfileHash;
    //real subsurfaceMask;
    //real thickness;
    //float3 tangentWS;
    //real anisotropy;
    //real iridescenceThickness;
    //real iridescenceMask;
    //real3 geomNormalWS;
    //real ior;
    //real3 transmittanceColor;
    //real atDistance;
    //real transmittanceMask;

    return surfaceData;
}

BSDFData GetBSDFData(float3 normal, float roughness, float3 diffuseAlbedo)
{
    BSDFData outBSDF;
    ZERO_INITIALIZE(BSDFData, outBSDF);

    outBSDF.materialFeatures = MATERIALFEATUREFLAGS_LIT_STANDARD | MATERIALFEATUREFLAGS_LIT_TRANSMISSION | MATERIALFEATUREFLAGS_LIT_SPECULAR_COLOR;
    outBSDF.diffuseColor = diffuseAlbedo;
    outBSDF.fresnel0 = DEFAULT_SPECULAR_VALUE;
    outBSDF.ambientOcclusion = 1.0f;
    outBSDF.specularOcclusion = 1.0f;
    outBSDF.normalWS = normal;
    outBSDF.perceptualRoughness = RoughnessToPerceptualRoughness(roughness);
    //real coatMask;
    //uint diffusionProfileIndex;
    //real subsurfaceMask;
    //real thickness;
    //bool useThickObjectMode;
    //real3 transmittance;
    //float3 tangentWS;
    //float3 bitangentWS;
    //real roughnessT;
    //real roughnessB;
    //real anisotropy;
    //real iridescenceThickness;
    //real iridescenceMask;
    //real coatRoughness;
    outBSDF.geomNormalWS = normal;
    //real ior;
    //real3 absorptionCoefficient;
    //real transmittanceMask;

    return outBSDF;
}

[numthreads(GROUP_SIZE, GROUP_SIZE, 1)]
void MainResolveOffscreenLighting(int3 dispatchThreadId : SV_DispatchThreadID)
{
#define SSR_TRACE_EPS               0.000488281f // 2^-11, should be good up to 4K
#define MIN_GGX_ROUGHNESS           0.00001f
#define MAX_GGX_ROUGHNESS           0.99999f

    UNITY_XR_ASSIGN_VIEW_INDEX(dispatchThreadId.z);
    if (any((float2)dispatchThreadId.xy > _ScreenSize.xy))
        return;

    PositionInputs posInputRaw = GetPositionInput(float2(dispatchThreadId.xy), _ScreenSize.zw, uint2(GROUP_SIZE, GROUP_SIZE));

    uint pixelOffset = posInputRaw.positionSS.y * _ScreenSize.x + posInputRaw.positionSS.x;
    uint listCount, listOffset;
    VisibilityOIT::GetPixelList(pixelOffset, listCount, listOffset);
    if (listCount == 0)
        return;

    //float currentDepth = _DepthTexture[COORD_TEXTURE2D_X(posInputRaw.positionSS.xy)].x;
    //float3 currentColor = _OutputTexture[COORD_TEXTURE2D_X(posInputRaw.positionSS.xy)].rgb;

    float3 lighting = float3(0.0f, 0.0f, 0.0f);

    //float2 minMax = _OITTileHiZ[COORD_TEXTURE2D_X(posInputRaw.positionSS.xy)];

    float foundDepth = 0.0;
    uint firstSample = -1;
    //for (uint a = 0; a < listCount; ++a)
    //for (int a = listCount - 1; a >= 0; --a)
    //uint a = listCount - 1;
    uint a = 0;
    {
        int globalOffset = a + listOffset;
        uint2 offscreenCoord = uint2(globalOffset % GetOffscreenLightBufferWidth(), globalOffset / GetOffscreenLightBufferWidth());

        Visibility::VisibilityData unusedVisData;
        uint2 unusedTexelCoord;
        float depthValue;
        VisibilityOIT::GetVisibilitySample(a, listOffset, unusedVisData, unusedTexelCoord, depthValue);

        if (depthValue > foundDepth)
        {
            firstSample = a;
            foundDepth = depthValue;
            //break;
        }
    }
    float startDeviceDepth = foundDepth;

    float deviceDepth = foundDepth;

    ////for (uint i = 0; i < listCount; ++i)
    uint i = firstSample;
    //
    int globalOffset = i + listOffset;
    uint2 offscreenCoord = uint2(globalOffset % GetOffscreenLightBufferWidth(), globalOffset / GetOffscreenLightBufferWidth());
    //
    //Visibility::VisibilityData unusedVisData;
    //uint2 unusedTexelCoord;
    //float depthValue;
    //VisibilityOIT::GetVisibilitySample(i, listOffset, unusedVisData, unusedTexelCoord, depthValue);

    //minDepth = max(depthValue, minDepth);

    float3 lightingSource = _VisOITOffscreenDirectReflectionLighting[COORD_TEXTURE2D_X(offscreenCoord)].rgb;
    ////outRes = _VisOITOffscreenPhotonRadianceLighting[COORD_TEXTURE2D_X(offscreenCoord)].rgb;
    //outRes = _VisOITOffscreenDirectReflectionLighting[COORD_TEXTURE2D_X(offscreenCoord)].rgb;
    //float3 outRes;
    ////outRes = _VisOITOffscreenPhotonRadianceLighting[COORD_TEXTURE2D_X(offscreenCoord)].rgb;
    //outRes = _VisOITOffscreenDirectReflectionLighting[COORD_TEXTURE2D_X(offscreenCoord)].rgb;
    //
  //  _OutputTexture[COORD_TEXTURE2D_X(posInputRaw.positionSS.xy)] = float4(lightingSource, 1.0);
  //  return;
    ////_OutputTexture[COORD_TEXTURE2D_X(posInputRaw.positionSS.xy)] = float4(currentColor*100, 1.0);
    //return;

    int2 tileCoord = (float2)posInputRaw.positionSS.xy / GetTileSize();
    PositionInputs posInput = GetPositionInput(posInputRaw.positionSS.xy, _ScreenSize.zw, deviceDepth, UNITY_MATRIX_I_VP, GetWorldToViewMatrix(), tileCoord);

    float3 wo = GetWorldSpaceNormalizeViewDir(posInput.positionWS);

    float2 positionNDC = posInputRaw.positionSS.xy * _ScreenSize.zw + (0.5 * _ScreenSize.zw); // Should we precompute the half-texel bias? We seem to use it a lot.
    //float3 positionWS = GetAbsolutePositionWS(ComputeWorldSpacePosition(positionNDC, deviceDepth, UNITY_MATRIX_I_VP)); // Jittered
    float3 positionWS = ComputeWorldSpacePosition(positionNDC, deviceDepth, UNITY_MATRIX_I_VP); // Jittered

    //float2 positionNDC = positionSS * _ScreenSize.zw + (0.5 * _ScreenSize.zw);
    //positionWS = ComputeWorldSpacePosition(positionNDC, deviceDepth, UNITY_MATRIX_I_VP);

    float3 camPosWS = GetCurrentViewPosition();

    //float3 wo = GetWorldSpaceNormalizeViewDir(positionWS);

    // Sample GBuffer
    uint4 packedOITGBuffer0 = _VisOITOffscreenGBuffer0[COORD_TEXTURE2D_X(offscreenCoord)].rgba;
    uint packedOITGBuffer1 = _VisOITOffscreenGBuffer1[COORD_TEXTURE2D_X(offscreenCoord)].r;
    float3 n;
    float roughness;
    float3 baseColor;
    float metalness;
    VisibilityOIT::UnpackOITGBufferData(packedOITGBuffer0, packedOITGBuffer1, n, roughness, baseColor, metalness);

    float3 f0 = lerp(DEFAULT_SPECULAR_VALUE, baseColor, metalness);

    //_VisOITOffscreenDirectReflectionLighting[]
    //float3 closestLighting = _VisOITOffscreenLighting[COORD_TEXTURE2D_X(offscreenCoord)].rgb;
    //_OutputTexture[COORD_TEXTURE2D_X(posInputRaw.positionSS.xy)] = float4(closestLighting, 1.0);

    //float3 wi = -wo;
    float internalIORSource = 1.0f;
    //float internalIORMedium = Fresnel0ToIor(f0);
    float internalIORMedium = 1.5f;
    //float3 wi = refract(-wo, n.xyz, internalIORSource / internalIORMedium);
    //float3 wi = refract(-wo, n.xyz, internalIORMedium / internalIORSource);
    //float3 wi = -wo;
    float3 wi = refract(-wo, n.xyz, 0.95);
    //float3 wi = refract(-wo, n.xyz, 1.25);
    //float3 Incident = -wo;
    //float eta = internalIORSource / internalIORMedium;
    //float cos0 = dot(Incident, n);
    //float kc = 1.0 - eta * eta * (1.0 - cos0 * cos0);
    ////float3 wi = k >= 0.0 ? eta * Incident - (eta * cos0 + sqrt(k)) * n : reflect(Incident, n);
    //float3 wi = kc >= 0.0 ? eta * Incident - (eta * cos0 + sqrt(kc)) * n : -n;
    ////float3 wi;
    float3 rIntensity = 1.0f;
    //float3 rIntensity = F_Transm_Schlick(IorToFresnel0(internalIORMedium, internalIORSource), -cos0);
    //float3 rIntensity = F_FresnelDielectric(internalIORMedium / internalIORSource, -cos0);
    //float3 wi;
    //float3 rIntensity;
    //BTDF::RefractIntensity(wi, rIntensity, -wo, n, internalIORSource, internalIORMedium);

    //positionWS = camPosWS - (positionWS - camPosWS) * (1.0f - 0.001 * rcp(max(dot(n, wo), FLT_EPS)));
    //positionWS += wi * 0.001f;
    //positionWS -= wi * (1.0f - 0.001 * rcp(max(dot(n, wo), FLT_EPS)));
    //positionWS -= wi * rcp(max(dot(n, wo), FLT_EPS));
    positionWS -= wi * 0.01f;
    deviceDepth = ComputeNormalizedDeviceCoordinatesWithZ(positionWS, UNITY_MATRIX_VP).z;

    //bool killRay = minDepth == UNITY_RAW_FAR_CLIP_VALUE;

    float3 rayOrigin = float3(posInputRaw.positionSS + 0.5, deviceDepth);

    float3 reflPosWS = positionWS + wi;
    float3 reflPosNDC = ComputeNormalizedDeviceCoordinatesWithZ(reflPosWS, UNITY_MATRIX_VP); // Jittered
    float3 reflPosSS = float3(reflPosNDC.xy * _ScreenSize.xy, reflPosNDC.z);
    float3 rayDir = reflPosSS - rayOrigin;
    float3 rcpRayDir = rcp(rayDir);
    int2   rayStep = int2(rcpRayDir.x >= 0 ? 1 : 0,
        rcpRayDir.y >= 0 ? 1 : 0);
    float3 raySign = float3(rcpRayDir.x >= 0 ? 1 : -1,
        rcpRayDir.y >= 0 ? 1 : -1,
        rcpRayDir.z >= 0 ? 1 : -1);
    ////bool   rayTowardsEye  =  rcpRayDir.z >= 0;

    int mipLevel = 0;
    float3 rayPos;

    // Start ray marching from the next texel to avoid self-intersections.
    float t;
    float deltaT;
    {
        // 'rayOrigin' is the exact texel center.
        float2 dist = abs(0.5 * rcpRayDir.xy);
        deltaT = min(dist.x, dist.y);
        t = deltaT;
    }

    bool hit = false;
    int hitOffset = 0;
    float3 hitNDC = 0;
    int iterFull = 0;
    // Bounce loop
    for (int b = 0; b < 3; ++b)
    {
        for (int k = 0; k < 512; ++k)
        {
            //rayPos = rayOrigin + (0.0125f * ((float)k)) * rayDir;
            //rayPos = rayOrigin + (0.01f * ((float)k)) * rayDir;
            //rayPos = rayOrigin + (1003.1f * ((float)k)) * rayDir;
            //rayPos = rayOrigin + (0.001f * ((float)k)) * rayDir;
            rayPos = rayOrigin + (t)*rayDir;
            t += deltaT * 0.5f;

            // Ray position often ends up on the edge. To determine (and look up) the right cell,
            // we need to bias the position by a small epsilon in the direction of the ray.
        //   float2 sgnEdgeDist = round(rayPos.xy) - rayPos.xy;
        //   float2 satEdgeDist = clamp(raySign.xy * sgnEdgeDist + SSR_TRACE_EPS, 0, SSR_TRACE_EPS);
        //   rayPos.xy += raySign.xy * satEdgeDist;

            int2 mipCoord = (int2)rayPos.xy >> mipLevel;
            int2 mipOffset = _DepthPyramidMipLevelOffsets[mipLevel];

            // Bounds define 4 faces of a cube:
            // 2 walls in front of the ray, and a floor and a base below it.

            float4 bounds;
            bounds.xy = (mipCoord + rayStep) << mipLevel;

            float2 depthBound = LOAD_TEXTURE2D_X(_OITTileHiZ, mipOffset + mipCoord).rg;
            //float currentDepth = LOAD_TEXTURE2D_X(_OITTileHiZ, mipOffset + mipCoord).r;
            //bounds.z = LOAD_TEXTURE2D_X(_OITTileHiZ, mipOffset + mipCoord).r;

            float2 currentNDC_xy = floor(rayPos.xy) * _ScreenSize.zw + (0.5 * _ScreenSize.zw);
            positionWS = ComputeWorldSpacePosition(currentNDC_xy.xy, rayPos.z, UNITY_MATRIX_I_VP);
            float3 currentNDC = ComputeNormalizedDeviceCoordinatesWithZ(positionWS, UNITY_MATRIX_VP);
            float currentDepth = currentNDC.z;

            //if (currentDepth > depthBound.g && currentDepth < depthBound.r)
            //{
            //    t += deltaT;
            //    ++iterFull;
            //    continue;
            //}

            float measureMax = 0.5f;
            //for (int k = listCount - 1; k >= 0; --k)
            for (uint k = 0; k < listCount; ++k)
            {
                //uint pixelOffset_k = floor(rayPos.y) * _ScreenSize.x + floor(rayPos.x);
                uint pixelOffset_k = floor(rayPos.y * _ScreenSize.x + rayPos.x);
                uint listCount_k, listOffset_k;
                VisibilityOIT::GetPixelList(pixelOffset_k, listCount_k, listOffset_k);

                int globalOffset_k = k + listOffset_k;
                uint2 offscreenCoord_k = uint2(globalOffset_k % GetOffscreenLightBufferWidth(), globalOffset_k / GetOffscreenLightBufferWidth());

                Visibility::VisibilityData unusedVisData_k;
                uint2 unusedTexelCoord_k;
                float depthValue_k;
                VisibilityOIT::GetVisibilitySample(k, listOffset_k, unusedVisData_k, unusedTexelCoord_k, depthValue_k);

                ++iterFull;
                if (currentDepth < depthValue_k)
                {
                    float3 currentWS = ComputeWorldSpacePosition(currentNDC.xy, depthValue_k, UNITY_MATRIX_I_VP);
                    float3 toSrc = normalize(positionWS - currentWS);
                    float measure = dot(-wi, toSrc);
                    if (measure > measureMax)
                    {
                        //hit = true;
                        hitOffset = k;
                        hitNDC = float3(currentNDC.xy, depthValue_k);
                        //hitNDC.xy = floor(rayPos.xy) * _ScreenSize.zw + (0.5 * _ScreenSize.zw);
                        hitNDC.xy = rayPos.xy * _ScreenSize.zw + (0.5 * _ScreenSize.zw);
                        //hitNDC.z = depthValue_k;
                        measureMax = measure;
                        //break;
                    }
                }
                //else
                //{
                //    break;
                //}
            }

            hit = measureMax > 0.90f;

            ++iterFull;
            if (hit)
                break;
        }
    }

    if (hit)
    {
        //uint pixelOffset_k = rayPos.y * _ScreenSize.x + rayPos.x;
        float2 remap = round(hitNDC.xy * _ScreenSize.xy);
        uint pixelOffset_k = remap.y  * _ScreenSize.x + remap.x;
        uint listCount_k, listOffset_k;
        VisibilityOIT::GetPixelList(pixelOffset_k, listCount_k, listOffset_k);

        int globalOffset_k = hitOffset + listOffset_k;
        uint2 offscreenCoord_k = uint2(globalOffset_k % GetOffscreenLightBufferWidth(), globalOffset_k / GetOffscreenLightBufferWidth());

        float3 outRes = _VisOITOffscreenDirectReflectionLighting[COORD_TEXTURE2D_X(offscreenCoord_k)].rgb;

        //_OutputTexture[COORD_TEXTURE2D_X(posInputRaw.positionSS.xy)] = float4((1.0f - rIntensity) * lightingSource + (rIntensity) * outRes, 1.0);
        _OutputTexture[COORD_TEXTURE2D_X(posInputRaw.positionSS.xy)] = float4(outRes, 1.0);
        //_OutputTexture[COORD_TEXTURE2D_X(posInputRaw.positionSS.xy)] = float4(0.0f, ((float)iterFull)/512.0f, 0.0, 1.0);
    }
    else
    {
        //_OutputTexture[COORD_TEXTURE2D_X(posInputRaw.positionSS.xy)] = float4(((float)iterFull) / 512.0f, 0.0, 0.0, 1.0);
        _OutputTexture[COORD_TEXTURE2D_X(posInputRaw.positionSS.xy)] = float4(1.0f, 0.0, 0.0, 1.0);
        //_OutputTexture[COORD_TEXTURE2D_X(posInputRaw.positionSS.xy)] = float4(lightingSource, 1.0);
    }
}
