#include "Packages/com.unity.render-pipelines.high-definition-config/Runtime/ShaderConfig.cs.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/EntityLighting.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/CommonLighting.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/ProbeVolume/ProbeVolumeRotate.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/ProbeVolume/DynamicGI/ProbePropagationGlobals.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/ProbeVolume/DynamicGI/ProbeVolumeSphericalHarmonicsLighting.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/ProbeVolume/DynamicGI/ProbeVolumeSphericalHarmonicsDeringing.hlsl"

#pragma kernel CombinePropagationAxis

#pragma multi_compile _ SH_FROM_SG_PBR_FIT SH_FROM_SG_PBR_FIT_WITH_COSINE_WINDOW
#pragma multi_compile _ 

#define GROUP_SIZE 64
//#pragma enable_d3d11_debug_symbols


StructuredBuffer<float> _ProbeVolumeAtlasReadSHL01Buffer;
StructuredBuffer<float> _ProbeVolumeAtlasReadSHL2Buffer;
StructuredBuffer<float> _ProbeVolumeAtlasReadValidityBuffer;
RWTexture3D<float4> _ProbeVolumeAtlasWriteTextureSH;

uint _ProbeVolumeAtlasReadBufferCount;
float3 _ProbeVolumeResolution;
float3 _ProbeVolumeAtlasBias;
float4 _ProbeVolumeAtlasResolutionAndSliceCount;
float3 _ProbeVolumeAtlasSHRotateRight;
float3 _ProbeVolumeAtlasSHRotateUp;
float3 _ProbeVolumeAtlasSHRotateForward;

StructuredBuffer<float3> _RadianceCacheAxis;
int _RadianceCacheAxisCount;
float _BakedLightingContribution;
float _DynamicPropagationContribution;
float4 _RayAxis[NEIGHBOR_AXIS_COUNT];

float _PropagationSharpness;


uint3 ComputeWriteIndexFromReadIndex(uint readIndex, float3 resolution)
{
    // _ProbeVolumeAtlasReadBuffer[z * resolutionY * resolutionX + y * resolutionX + x]
    // TODO: Could implement as floating point operations, which is likely faster.
    // Would need to verify precision.
    uint x = readIndex % (uint)resolution.x;
    uint y = (readIndex / (uint)resolution.x) % (uint)resolution.y;
    uint z = readIndex / ((uint)resolution.y * (uint)resolution.x);

    uint3 writeIndex = uint3(x, y, z);
    writeIndex += (uint3)floor(_ProbeVolumeAtlasBias * _ProbeVolumeAtlasResolutionAndSliceCount.xyz);

    return writeIndex;
}

float ReadValidity(uint readIndex)
{
    const float occlusion = _ProbeVolumeAtlasReadValidityBuffer[readIndex];
    return pow(1.0 - occlusion, 8.0);
}

SHOutgoingRadiosityWithProjectedConstantsPacked ReadBakedSH(uint readIndex)
{
    SHOutgoingRadiosityWithProjectedConstantsPacked outgoingRadiosity;

    const uint SH_STRIDE_L01 = 4 * 3;
    const uint SH_STRIDE_L2 = (9 * 3) - SH_STRIDE_L01;

    outgoingRadiosity.data[0] = float4(
        _ProbeVolumeAtlasReadSHL01Buffer[readIndex * SH_STRIDE_L01 + 0], // shAr.w
        _ProbeVolumeAtlasReadSHL01Buffer[readIndex * SH_STRIDE_L01 + 1], // shAg.w
        _ProbeVolumeAtlasReadSHL01Buffer[readIndex * SH_STRIDE_L01 + 2], // shAb.w
        _ProbeVolumeAtlasReadSHL01Buffer[readIndex * SH_STRIDE_L01 + 3]  // shAr.x
    );
    outgoingRadiosity.data[1] = float4(
        _ProbeVolumeAtlasReadSHL01Buffer[readIndex * SH_STRIDE_L01 + 4], // shAr.y
        _ProbeVolumeAtlasReadSHL01Buffer[readIndex * SH_STRIDE_L01 + 5], // shAr.z
        _ProbeVolumeAtlasReadSHL01Buffer[readIndex * SH_STRIDE_L01 + 6], // shAg.x
        _ProbeVolumeAtlasReadSHL01Buffer[readIndex * SH_STRIDE_L01 + 7]  // shAg.y
    );
    outgoingRadiosity.data[2] = float4(
        _ProbeVolumeAtlasReadSHL01Buffer[readIndex * SH_STRIDE_L01 + 8], // shAg.z
        _ProbeVolumeAtlasReadSHL01Buffer[readIndex * SH_STRIDE_L01 + 9], // shAb.x
        _ProbeVolumeAtlasReadSHL01Buffer[readIndex * SH_STRIDE_L01 + 10], // shAb.y
        _ProbeVolumeAtlasReadSHL01Buffer[readIndex * SH_STRIDE_L01 + 11]  // shAb.z
    );
    outgoingRadiosity.data[3] = float4(
        _ProbeVolumeAtlasReadSHL2Buffer[readIndex * SH_STRIDE_L2 + 0], // shBr.x
        _ProbeVolumeAtlasReadSHL2Buffer[readIndex * SH_STRIDE_L2 + 1], // shBr.y
        _ProbeVolumeAtlasReadSHL2Buffer[readIndex * SH_STRIDE_L2 + 2], // shBr.z
        _ProbeVolumeAtlasReadSHL2Buffer[readIndex * SH_STRIDE_L2 + 3]  // shBr.w
    );
    outgoingRadiosity.data[4] = float4(
        _ProbeVolumeAtlasReadSHL2Buffer[readIndex * SH_STRIDE_L2 + 4], // shBg.x
        _ProbeVolumeAtlasReadSHL2Buffer[readIndex * SH_STRIDE_L2 + 5], // shBg.y
        _ProbeVolumeAtlasReadSHL2Buffer[readIndex * SH_STRIDE_L2 + 6], // shBg.z
        _ProbeVolumeAtlasReadSHL2Buffer[readIndex * SH_STRIDE_L2 + 7]  // shBg.w
    );
    outgoingRadiosity.data[5] = float4(
        _ProbeVolumeAtlasReadSHL2Buffer[readIndex * SH_STRIDE_L2 + 8], // shBb.x
        _ProbeVolumeAtlasReadSHL2Buffer[readIndex * SH_STRIDE_L2 + 9], // shBb.y
        _ProbeVolumeAtlasReadSHL2Buffer[readIndex * SH_STRIDE_L2 + 10], // shBb.z
        _ProbeVolumeAtlasReadSHL2Buffer[readIndex * SH_STRIDE_L2 + 11]  // shBb.w
    );
    outgoingRadiosity.data[6] = float4(
        _ProbeVolumeAtlasReadSHL2Buffer[readIndex * SH_STRIDE_L2 + 12], // shCr.x
        _ProbeVolumeAtlasReadSHL2Buffer[readIndex * SH_STRIDE_L2 + 13], // shCr.y
        _ProbeVolumeAtlasReadSHL2Buffer[readIndex * SH_STRIDE_L2 + 14], // shCr.z
        0.0
    );

    return outgoingRadiosity;
}

void WriteFinalSHOutgoingRadiosityWithProjectedConstantsPacked(uint3 writeIndex, SHOutgoingRadiosityWithProjectedConstantsPacked outgoingRadiosityProjectedConstantsPacked, float validity)
{
    _ProbeVolumeAtlasWriteTextureSH[uint3(writeIndex.x, writeIndex.y, writeIndex.z + _ProbeVolumeAtlasResolutionAndSliceCount.z * 0)] = outgoingRadiosityProjectedConstantsPacked.data[0];
    _ProbeVolumeAtlasWriteTextureSH[uint3(writeIndex.x, writeIndex.y, writeIndex.z + _ProbeVolumeAtlasResolutionAndSliceCount.z * 1)] = outgoingRadiosityProjectedConstantsPacked.data[1];
    _ProbeVolumeAtlasWriteTextureSH[uint3(writeIndex.x, writeIndex.y, writeIndex.z + _ProbeVolumeAtlasResolutionAndSliceCount.z * 2)] = outgoingRadiosityProjectedConstantsPacked.data[2];
    _ProbeVolumeAtlasWriteTextureSH[uint3(writeIndex.x, writeIndex.y, writeIndex.z + _ProbeVolumeAtlasResolutionAndSliceCount.z * 3)] = outgoingRadiosityProjectedConstantsPacked.data[3];
    _ProbeVolumeAtlasWriteTextureSH[uint3(writeIndex.x, writeIndex.y, writeIndex.z + _ProbeVolumeAtlasResolutionAndSliceCount.z * 4)] = outgoingRadiosityProjectedConstantsPacked.data[4];
    _ProbeVolumeAtlasWriteTextureSH[uint3(writeIndex.x, writeIndex.y, writeIndex.z + _ProbeVolumeAtlasResolutionAndSliceCount.z * 5)] = outgoingRadiosityProjectedConstantsPacked.data[5];
    _ProbeVolumeAtlasWriteTextureSH[uint3(writeIndex.x, writeIndex.y, writeIndex.z + _ProbeVolumeAtlasResolutionAndSliceCount.z * 6)] = float4(outgoingRadiosityProjectedConstantsPacked.data[6].xyz, validity);
}

SHIncomingIrradiance ProjectPropagationAxisFromPeak(uint probeIndex)
{
    SHIncomingIrradiance incomingIrradiance;
    ZERO_INITIALIZE(SHIncomingIrradiance, incomingIrradiance);

    uint localIndex = probeIndex;
    for (int axis = 0; axis < NEIGHBOR_AXIS_COUNT; ++axis)
    {
        float3 radiance = _RadianceCacheAxis[localIndex].xyz;
        float3 direction = _RayAxis[axis].xyz;
        SHIncomingIrradianceAccumulate(incomingIrradiance, direction, radiance);
        //FCCAddToOutputRepresentation(radiance, direction, incomingIrradiance);
        localIndex += _ProbeVolumeAtlasReadBufferCount;
    }

    return incomingIrradiance;
}

// data for fit generated with: https://gist.github.com/pastasfuture/e1a7d80d6ed1104540b22edc15ce655a
// Fit coefficient function fit generated in desmos (for non zero parameters c0, c2, and c6): https://www.desmos.com/calculator/rnrmjlz1jb
// Reference implementation: https://www.shadertoy.com/view/7tsXzH
//
// Note: These ComputeSphericalHarmonicFromSphericalGaussian functions can be replaced with hardcoded constants once we make sharpness hardcoded.
#if !defined(SH_FROM_SG_PBR_FIT_WITH_COSINE_WINDOW)
float ZHWindowComputeFromSphericalGaussianC0(float sharpness)
{
    // sharpness * 1.22962 + 0.823224 is always positive. abs is to simply make the compiler happy.
    return pow(abs(sharpness) * 1.22962 + 0.823224, -1.25462) * 3.73236 + 0.0289582;
}

float ZHWindowComputeFromSphericalGaussianC1(float sharpness)
{
    return exp2(-3.78299 * pow(abs(sharpness * 0.766922 + -0.687697), -0.95733)) * -0.862788 + 0.851292;
}

float ComputeSigmoidSCurve(float x, float p)
{
    float a = exp2(x * p);
    return a / (a + 1.0);
}

float ZHWindowComputeFromSphericalGaussianC2(float sharpness)
{
    return lerp(
        sharpness * sharpness * -0.0326676 + sharpness * 0.225077,
        ComputeSigmoidSCurve(sharpness * 15.3784 + -31.6152, 0.0162406) * -0.707591 + 0.85572,
        saturate((sharpness - 0.800167) / (0.800167 - 4.57034))
    );
}
#else
float ZHWindowComputeFromSphericalGaussianC0(float sharpness)
{
    // sharpness * 0.386254 + 1.55848 is always positive. abs is to simply make the compiler happy.
    return pow(abs(sharpness) * 0.386254 + 1.55848, -1.52661) * 1.72542 + 0.0290483;
}

float ZHWindowComputeFromSphericalGaussianC1(float sharpness)
{
    return exp2(-8.6001 * pow(abs(sharpness * 1.53466 + 3.47572), -1.16397)) * -1.32848 + 1.34496;
}

float ZHWindowComputeFromSphericalGaussianC2(float sharpness)
{
    return exp2(-0.506072 * pow(abs(sharpness * 0.273738 + 0.296201), -1.06396)) * -0.506072 + 0.511033;
}
#endif

ZHWindow ZHWindowComputeFromSphericalGaussian(float sharpness)
{
    ZHWindow zhWindow;
    zhWindow.data[0] = ZHWindowComputeFromSphericalGaussianC0(sharpness);
    zhWindow.data[1] = ZHWindowComputeFromSphericalGaussianC1(sharpness);
    zhWindow.data[2] = ZHWindowComputeFromSphericalGaussianC2(sharpness);

    return zhWindow;
}

SHIncomingIrradiance SHIncomingIrradianceComputeFromSphericalGaussian(float3 direction, float sharpness, float3 radiance)
{
    ZHWindow zhWindow = ZHWindowComputeFromSphericalGaussian(sharpness);
    SHWindow shWindow = SHWindowComputeFromZHWindow(zhWindow, direction);
    SHIncomingIrradiance irradiance = SHIncomingIrradianceComputeFromSHWindowAndRadiance(shWindow, radiance);

    return irradiance;
}

SHIncomingIrradiance ProjectPropagationAxisFromFit(uint probeIndex)
{
    SHIncomingIrradiance incomingIrradiance;
    ZERO_INITIALIZE(SHIncomingIrradiance, incomingIrradiance);

    uint localIndex = probeIndex;
    for (int axis = 0; axis < NEIGHBOR_AXIS_COUNT; ++axis)
    {
        float3 radiance = _RadianceCacheAxis[localIndex].xyz;
        float3 direction = _RayAxis[axis].xyz;

        SHIncomingIrradiance incomingIrradianceCurrentSG = SHIncomingIrradianceComputeFromSphericalGaussian(direction, _PropagationSharpness, radiance);

        SHIncomingIrradianceAccumulateFromSHIncomingIrradiance(incomingIrradiance, incomingIrradianceCurrentSG);

        localIndex += _ProbeVolumeAtlasReadBufferCount;
    }

    return incomingIrradiance;
}

SHIncomingIrradiance ProjectPropagationAxis(uint probeIndex)
{
#if defined(SH_FROM_SG_PBR_FIT) || defined(SH_FROM_SG_PBR_FIT_WITH_COSINE_WINDOW)
    return ProjectPropagationAxisFromFit(probeIndex);
#else
    return ProjectPropagationAxisFromPeak(probeIndex);
#endif
}


[numthreads(GROUP_SIZE, 1, 1)]
void CombinePropagationAxis(uint3 id : SV_DispatchThreadID)
{
    const uint readIndex = id.x;
    if (readIndex < _ProbeVolumeAtlasReadBufferCount)
    {
        uint3 writeIndex = ComputeWriteIndexFromReadIndex(readIndex, _ProbeVolumeResolution);
        const float validity = ReadValidity(readIndex);

        SHOutgoingRadiosityWithProjectedConstantsPacked bakedOutgoingRadiosityProjectedConstantsPacked = ReadBakedSH(readIndex);
        SHIncomingIrradiance dynamicIncomingIrradiance = ProjectPropagationAxis(readIndex);

        SHOutgoingRadiosity dynamicOutgoingRadiosity = SHOutgoingRadiosityComputeFromIncomingIrradiance(dynamicIncomingIrradiance);
        SHOutgoingRadiosityWithProjectedConstants bakedOutgoingRadiosityProjectedConstants = SHOutgoingRadiosityWithProjectedConstantsCompute(bakedOutgoingRadiosityProjectedConstantsPacked);
        SHOutgoingRadiosity bakedOutgoingRadiosity = SHOutgoingRadiosityCompute(bakedOutgoingRadiosityProjectedConstants);

        const float3x3 probeVolumeAtlasSHRotate = float3x3(_ProbeVolumeAtlasSHRotateRight, _ProbeVolumeAtlasSHRotateUp, _ProbeVolumeAtlasSHRotateForward);
        SHOutgoingRadiosityRotate(probeVolumeAtlasSHRotate, bakedOutgoingRadiosity); // rotate baked SH Data into absolute world space before it is combined with dynamic SH data in absolute world space
        SHOutgoingRadiosityBlend(bakedOutgoingRadiosity, _BakedLightingContribution, dynamicOutgoingRadiosity, _DynamicPropagationContribution);

        #if DERING_LUMINANCE_ONLY
            //SHOutgoingRadiosityDeringLuminance(bakedOutgoingRadiosity);
        #else
            //SHOutgoingRadiosityDering(bakedOutgoingRadiosity);
        #endif

        bakedOutgoingRadiosityProjectedConstants = SHOutgoingRadiosityWithProjectedConstantsCompute(bakedOutgoingRadiosity);
        bakedOutgoingRadiosityProjectedConstantsPacked = SHOutgoingRadiosityWithProjectedConstantsPackedCompute(bakedOutgoingRadiosityProjectedConstants);
        WriteFinalSHOutgoingRadiosityWithProjectedConstantsPacked(writeIndex, bakedOutgoingRadiosityProjectedConstantsPacked, validity);
    }
}
