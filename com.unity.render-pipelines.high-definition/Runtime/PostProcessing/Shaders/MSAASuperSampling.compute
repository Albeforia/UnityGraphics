#pragma kernel MainUpsample
#pragma kernel MainReprojectLuminance
#pragma only_renderers d3d11 playstation xboxone xboxseries vulkan metal switch

#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/PostProcessing/Shaders/RTUpscale.hlsl"

TEXTURE2D_X_MSAA(float4, _ColorTextureMS);

//#pragma enable_d3d11_debug_symbols

#define THREAD_X 8
#define THREAD_Y 8
#define THREAD_TOTAL (THREAD_X*THREAD_Y)

TEXTURE2D_X(_InputMSSSLuminance);
RW_TEXTURE2D_X(float4, _OutputMSSSLuminance);

void FsrSrtmF(inout float3 c)
{
    c*=rcp(max(max(c.r,c.g),c.b)+1.0);
}

// The extra max solves the c=1.0 case (which is a /0).
void FsrSrtmInvF(inout float3 c)
{
    c*=rcp(max(1.0/32768.0,1.0-max(max(c.r,c.g),c.b)));
}

// MSAA texture fetch prototype.
float4 MsssTexF(int2 p, int s)
{
    float4 c = LOAD_TEXTURE2D_X_MSAA(_ColorTextureMS, p, s);
    FsrSrtmF(c.rgb);
    return c;
}

// Load luma feedback prototype.
float4 MsssLdF(int2 p)
{
    return LOAD_TEXTURE2D_X(_InputMSSSLuminance, p);
}

// Store luma feedback prototype.
void MsssStF(int2 p, float4 c)
{
    _OutputMSSSLuminance[COORD_TEXTURE2D_X(p)] = c;
}

void MsssSt2F(int2 p, float4 c)
{
}

#define MSSS_32BIT 1
#define MSSS_HLSL 1
#define MSSS_DENOISE 1

#include "Packages/com.unity.render-pipelines.high-definition/Runtime/PostProcessing/Shaders/MSSS.hlsl"


#define MSSS_INTERPOLATION_TIER_0 0
#define MSSS_INTERPOLATION_TIER_1 1
#define MSSS_INTERPOLATION_TIER_2 2
#define MSSS_INTERPOLATION_MODE MSSS_INTERPOLATION_TIER_1

TEXTURE2D_X(_InputDepthTexture);

RW_TEXTURE2D_X(CTYPE,  _OutputTexture);
RW_TEXTURE2D_X(float,  _OutputDepthTexture);
RW_TEXTURE2D_X(float2, _OutputMotionVectorTexture);

float4 _SourceSize;
float4 _ViewPortSize;


static const float2 msaa4xSamplePoints[] = {
    float2(-1.0/8.0, -3.0/8.0),
    float2( 3.0/8.0, -1.0/8.0),
    float2(-3.0/8.0,  1.0/8.0),
    float2( 1.0/8.0,  3.0/8.0)
};

float GetWeigtedNearestLum(float2 centerPos, int sId)
{
    float2 velocity;
    DecodeMotionVector(LOAD_TEXTURE2D_X(_CameraMotionVectorsTexture, centerPos), velocity);
    float2 repPos = centerPos - velocity * _ScreenSize.xy;
    float4 luminances = LOAD_TEXTURE2D_X(_InputMSSSLuminance, repPos);

    float2 inPixelCoord = frac(repPos) * 2.0 - 1.0;
    float weights = 0.0;
    float luminance = 0.0;
    const float4 masks[] = { {1,0,0,0}, {0,1,0,0}, {0,0,1,0}, {0,0,0,1} };

    for (int i = 0; i < 4; ++i)
    {
        float2 dv = inPixelCoord - 2.0*msaa4xSamplePoints[i];
        //float2 dv = msaa4xSamplePoints[sId] - msaa4xSamplePoints[i];
        float d = dot(dv, dv);
        float w = rcp(d*d + 1.0);
        w *= w;
        luminance += luminances[i] * w;
        weights += w;
    }

    return luminance / weights;
}

[numthreads(8,8,1)]
void MainReprojectLuminance(uint3 dti : SV_DispatchThreadID)
{
    float2 centerPos = dti.xy + 0.5; //center texel
    float2 uv = (centerPos) * _SourceSize.zw;

#if MSSS_INTERPOLATION_MODE == MSSS_INTERPOLATION_TIER_0
    float2 velocity = float2(0.0, 0.0);
    //Simple dumb interpolation
    DecodeMotionVector(LOAD_TEXTURE2D_X(_CameraMotionVectorsTexture, centerPos), velocity);
    float2 reprojectedPos = centerPos - velocity * _ScreenSize.xy;
    float4 luminances = LOAD_TEXTURE2D_X(_InputMSSSLuminance, reprojectedPos);
#elif MSSS_INTERPOLATION_MODE == MSSS_INTERPOLATION_TIER_1
    float4 luminances = float4(0,0,0,0);
    const float4 masks[] = { {1,0,0,0}, {0,1,0,0}, {0,0,1,0}, {0,0,0,1} };
    for (int i = 0; i < 4; ++i)
    {
        float value = GetWeigtedNearestLum(centerPos + msaa4xSamplePoints[i], i);
        luminances += value * masks[i];
    }
    
#elif MSSS_INTERPOLATION_MODE == MSSS_INTERPOLATION_TIER_2
    #error "Unimplemented"
#endif
    
    _OutputMSSSLuminance[COORD_TEXTURE2D_X(dti.xy)] = luminances;
}

float calcLum(float3 colorIn)
{
    return max(colorIn.r, max(colorIn.g, colorIn.b));
}

[numthreads(THREAD_X,THREAD_Y,1)]
void MainUpsample (uint3 dti : SV_DispatchThreadID, int2 gti : SV_GroupThreadID)
{
    UNITY_XR_ASSIGN_VIEW_INDEX(dti.z);
    float2 uvs = ((float2)dti.xy + 0.5f) * _ViewPortSize.zw;
    uint2 colorCoord = dti.xy;

    float2 scale = _SourceSize.xy / _ViewPortSize.xy;
    float4 sampledColor = float4(0,0,0,1);

    sampledColor.rgb = MsssF(
        //  p ....... integer pixel position in the output
        dti.xy,
        //  k0.xy ... input/output resolution
        //  k0.zw ... k0.xy * 0.5 - 0.5
        float4(scale.x,scale.y,scale.x*0.5-0.5,scale.y*0.5-0.5),
        // denoise constant
        exp2(-64.0)).rgb;

    FsrSrtmInvF(sampledColor.rgb);
    
#if 0
    float4 debugLuminance = SAMPLE_TEXTURE2D_X_LOD(_InputMSSSLuminance, s_linear_clamp_sampler, uvs, 0);
    _OutputTexture[COORD_TEXTURE2D_X(dti.xy)] = (CTYPE)debugLuminance;
#else
    _OutputTexture[COORD_TEXTURE2D_X(dti.xy)] = (CTYPE)sampledColor;
#endif

    _OutputDepthTexture[COORD_TEXTURE2D_X(dti.xy)] = Nearest(_InputDepthTexture, uvs).x;
    _OutputMotionVectorTexture[COORD_TEXTURE2D_X(dti.xy)] = Bilinear(_CameraMotionVectorsTexture, uvs).xy;
}
