<#@ template language="C#"
#><#@ import namespace="System.Text"
#><#@ import namespace="System.Collections.Generic"
#>
using System;
using System.Linq;
using NUnit.Framework;

namespace UnityEngine.Rendering.Tests
{
    using TSet = VolumeComponentTestDataSet;

    class SomeObject {}

    partial class EqualityTests
    {

        static readonly (string name, VolumeComponentType type)[] k_NameAndVolumeComponentType = Enumerable.Range(0, 49)
            .RandomInitState(52089765)
            .Select(_ => (TestDataGenerationUtilities.RandomString(), TSet.volumeComponentTypes.RandomElement()))
            .ToArray();

<# foreach (var test in equalityTests) Write(test); #>

        [Test]
        public void EverythingVolumeComponentFilterEquality()
        {
            var l2 = new EverythingVolumeComponentFilter();
            var r2 = new EverythingVolumeComponentFilter();

            var expectsAreEquals = true;
            <# WriteEqualityCode(true); #>
            Assert.True(result);
        }
    }
}

<#+
    public struct EqualityTest
    {
        public string testName;
        public string buildFromType;
        public string buildFromTypeAttribute;
        public string constructor;
        public string expectsAreEqual;
        public bool addNullableTests;

        public EqualityTest(string testName, string buildFromType, string buildFromTypeAttribute, string constructor, string expectsAreEqual, bool addNullableTests)
        {
            this.testName = testName;
            this.buildFromType = buildFromType;
            this.buildFromTypeAttribute = buildFromTypeAttribute;
            this.constructor = constructor;
            this.expectsAreEqual = expectsAreEqual;
            this.addNullableTests = addNullableTests;
        }
    }

    public void Write(EqualityTest test)
    {
        #>
        static partial class Properties
        {
            [Test(ExpectedResult = true)]
            public static bool <#= test.testName #>(
                <#= test.buildFromTypeAttribute #><#= test.buildFromType #> l,
                <#= test.buildFromTypeAttribute #><#= test.buildFromType #> r
            )
            {
                var l2 = <#= string.Format(test.constructor, "l") #>;
                var r2 = <#= string.Format(test.constructor, "r") #>;

                var expectsAreEquals = <#= test.expectsAreEqual #>;
                <#+ WriteEqualityCode(test.addNullableTests); #>
                return result;
            }
        }
<#+
    }

    public void WriteEqualityCode(bool addNullableTests)
    {
#>
                var areEquals = l2 == r2;
                var areEquals2 = l2.Equals(r2);
                var areEquals3 = l2.Equals((object)r2);
                var areNotEquals4 = l2 != r2;

                // The hashcode must be the same for identical values
                var hashCodeEquals = expectsAreEquals && l2.GetHashCode() == r2.GetHashCode()
                    || !expectsAreEquals;

                // Check equal to itself
                var isEqual = l2 == l2 && l2.GetHashCode() == l2.GetHashCode();

                var nullableTest = false;
<#+
        if (addNullableTests)
        {
#>
                r2 = null;
                nullableTest = !l2.Equals(r2);
<#+
        }
#>
                var result = areEquals == areEquals2
                    && areEquals == areEquals3
                    && areEquals != areNotEquals4
                    && hashCodeEquals
                    && areEquals == expectsAreEquals
                    && isEqual
                    && !l2.Equals((object)null)
                    && !l2.Equals((object)new SomeObject())
                    && l2.Equals((object)l2);
<#+
    }

    public static class Tests
    {
        public const string fromTypeConstructor = "{0}.FromType({{0}}.AsType())";
        public static EqualityTest VolumeComponentFilter(string className, string constructor)
            => new EqualityTest($"" +
                $"{className}Equality",
                "VolumeComponentType",
                "[ValueSource(typeof(TSet), nameof(TSet.volumeComponentTypes))]",
                string.Format(constructor, className),
                "l.AsType() == r.AsType()",
                true);
    }

    EqualityTest[] equalityTests = new[]
    {
        Tests.VolumeComponentFilter("IsSupportedVolumeComponentFilter", Tests.fromTypeConstructor),
        Tests.VolumeComponentFilter("IsExplicitlySupportedVolumeComponentFilter", Tests.fromTypeConstructor),
        new EqualityTest("VolumeComponentTypeEquality",
            "VolumeComponentType",
            "[ValueSource(typeof(TSet), nameof(TSet.volumeComponentTypes))]",
            "{0}",
            "l.AsType() == r.AsType()",
            false),
        new EqualityTest("IsVisibleVolumeComponentFilterEquality",
            "bool",
            "[Values]",
            "IsVisibleVolumeComponentFilter.FromIsVisible({0})",
            "l == r",
            true),
        new EqualityTest("VolumeComponentArchetypeEquality",
            "VolumeComponentType[]",
            "[ValueSource(typeof(TSet), nameof(TSet.volumeComponentTypesArray))]",
            "VolumeComponentArchetype.FromTypes({0})",
            "l.ToHashSet().SetEquals(r.ToHashSet())",
            true),
        new EqualityTest("VolumeComponentArchetypeTreeProviderPathNodeEquality",
            "(string name, VolumeComponentType type)",
            "[ValueSource(nameof(k_NameAndVolumeComponentType))]",
            "new VolumeComponentArchetypeTreeProvider.PathNode({0}.name, {0}.type)",
            "(l.name == r.name && l.type == r.type)",
            true),
    };
#>
