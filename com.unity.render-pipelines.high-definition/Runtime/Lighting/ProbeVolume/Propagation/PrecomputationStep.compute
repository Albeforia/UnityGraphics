
#pragma kernel PrecomputeKernel
#pragma enable_d3d11_debug_symbols

#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/ProbeVolume/Propagation/APVDynamicGICommon.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/EntityLighting.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinGIUtilities.hlsl"
#include "Packages/com.unity.render-pipelines.core/Runtime/Lighting/ProbeVolume/ProbeVolume.hlsl"

#define GROUP_SIZE 64

// First 3 args are for hits, second 3 for miss
RWStructuredBuffer<uint4>  _PackedProbeExtraData;
StructuredBuffer<float3> _ProbeWorldLocations;

float4 _DynamicGIPrecomputation;

#define _MissCount _DynamicGIPrecomputation.x
#define _MissOffset _DynamicGIPrecomputation.y
#define _DistanceBetweenProbes _DynamicGIPrecomputation.z


// Here we try to split into three groups
//  - Completely scaled to 0 because invalidity (only happens with leak scale is 1)
//  - probe/axis couple has a hit -> list with a lightloop
//  - probe/axis has not a hit -> list with just APV sampling
// The first group directly write zero into the irradiance cache
// Other two have lists for the indirect dispatch.

// As of extra data we output a uint3 per probe/axis couple

//  - extraData packed into the original uint2
//    probeIndex + validity + axisIndex into another uint {19, 8, 5}


uint PackOutput(float3 uvw)
{
    uint output = 0;

    // Wrap
    float u = (uvw.x % 1.0f);
    float v = (uvw.y % 1.0f);
    float w = (uvw.z % 1.0f);

    output |= ((uint)(w * 32.5f) << 0);
    output |= ((uint)(v * 2047.5f) << 5);
    output |= ((uint)(u * 32767.5f) << 17);

    return output;
}

// Note: can be further optimized ( to minimize interlock adds for example ). However since this is run once only, I prefer simplicity over performance.

[numthreads(GROUP_SIZE, 1, 1)]
void PrecomputeKernel(uint3 id : SV_DispatchThreadID, uint3 groupThreadID : SV_GroupThreadID)
{
    uint elementIndex = id.x;

    if (elementIndex < _MissCount)
    {
        uint dataIndex = elementIndex + _MissOffset;
        uint4 data = _PackedProbeExtraData[dataIndex];
        uint probeIndex, axisIndex;
        float probeValidity;
        UnpackIndicesAndValidity(data.z, probeIndex, axisIndex, probeValidity);

        float3 probeWorldPosition = _ProbeWorldLocations[probeIndex];
        float4 axisDirection = _RayAxis[axisIndex];

        float3 dist = axisDirection.xyz * _DistanceBetweenProbes * axisDirection.w;
        float3 neighbourPos = probeWorldPosition + dist;

        float3 pool_uvw;
        APVResources apvRes = FillAPVResources();
        uint output = 0xffffffff;
        if (TryToGetPoolUVW(apvRes, neighbourPos, 0, pool_uvw))
        {
            output = PackOutput(pool_uvw);
        }

        _PackedProbeExtraData[dataIndex].w = output;
    }
}
