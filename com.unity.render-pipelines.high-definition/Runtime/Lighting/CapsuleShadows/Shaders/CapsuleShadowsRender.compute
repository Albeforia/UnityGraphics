#pragma only_renderers d3d11 playstation xboxone xboxseries vulkan metal switch
//#pragma enable_d3d11_debug_symbols

#pragma multi_compile_local _ CAPSULE_TILE_DEBUG

#pragma kernel Main

#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/NormalBuffer.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/CapsuleShadows/ShaderVariablesCapsuleShadows.cs.hlsl"
#include "Packages/com.unity.render-pipelines.core/Runtime/Lighting/CapsuleShadows/Shaders/CapsuleShadows.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/CapsuleShadows/Shaders/CapsuleShadowsGlobals.hlsl"
#ifdef CAPSULE_TILE_DEBUG
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/LightingDebug.cs.hlsl"
#endif

StructuredBuffer<CapsuleShadowCaster> _CapsuleShadowCasters; // TODO: could be constant buffer (need array support)
StructuredBuffer<CapsuleOccluderData> _CapsuleOccluderShadows; // TODO: could be constant buffer (need to write array from earlier pass)
StructuredBuffer<uint> _CapsuleShadowCounters; // TODO: could be constant buffer? need to write from earlier pass
RW_TEXTURE2D_ARRAY(float, _CapsuleShadowsRenderOutput);
#ifdef CAPSULE_TILE_DEBUG
RW_TEXTURE2D_X(uint, _CapsuleTileDebug);
#endif

#define TILE_SIZE               8

#define MIN_LINEAR_DEPTH        asfloat(0x00800000)
#define DEPTH_MAX_EMPTY         0x00000000U
#define DEPTH_MIN_EMPTY         0xffffffffU
#define DEPTH_RANGE_COUNT       2
groupshared uint s_depthMinU[DEPTH_RANGE_COUNT];
groupshared uint s_depthMaxU[DEPTH_RANGE_COUNT];
groupshared float3 s_tileCenter[DEPTH_RANGE_COUNT];
groupshared uint s_tileRadiusU[DEPTH_RANGE_COUNT];
groupshared uint s_intersectionBits[2];

struct CasterRenderData
{
    float maxCosTheta;
    float shadowRange;
    float3 positionWS;      // direction for directional light
    float radiusWS;         // point/spot only
};

struct CasterCullingData
{
    float3 tileToLightDir;
    float tileToLightDistance;
    float penumbraCosTheta;
};

#define MAX_SLICE_COUNT                                             MAX_CAPSULE_SHADOW_CASTER_COUNT
#define CASTER_CULLING_INDEX(CASTER_INDEX, DEPTH_RANGE_INDEX)       (((CASTER_INDEX) << 1) | (DEPTH_RANGE_INDEX))
groupshared CasterRenderData s_casterRenderData[MAX_SLICE_COUNT];
groupshared CasterCullingData s_casterCullingData[MAX_SLICE_COUNT*DEPTH_RANGE_COUNT];
groupshared uint s_casterValidBits;

groupshared uint s_packedVisibility[TILE_SIZE*TILE_SIZE*MAX_SLICE_COUNT/2]; // UNORM16 per slice per pixel


#if USE_LEFT_HAND_CAMERA_SPACE
#define PACK_UNPACK_POSITIVE_DEPTH(D)   (D)
#else
#define PACK_UNPACK_POSITIVE_DEPTH(D)   (-(D))
#endif

float MaxElement(float2 v)
{
    return max(v.x, v.y);
}

float3 ViewspaceFromXY(float2 posVS_XY, float linearDepth)
{
    return float3(posVS_XY * abs(linearDepth), linearDepth);
}

float MatchingSinCos(float sinOrCosTheta)
{
    return sqrt(max(0.f, 1.f - Sq(sinOrCosTheta)));
}

bool CastersIntersectTile(uint flatThreadIndex, bool useSecondDepthRange)
{
    uint depthRangeIndex = flatThreadIndex & 1;
    uint casterIndex = flatThreadIndex >> 1;

    if (casterIndex < _CapsuleCasterCount && (depthRangeIndex == 0 || useSecondDepthRange))
    {
        CapsuleShadowCaster caster = _CapsuleShadowCasters[casterIndex];
        bool isValid;
        if (caster.casterType == CAPSULESHADOWCASTERTYPE_INDIRECT)
        {
            // no light to intersect, always valid
            isValid = true;
        }
        else
        {
            // grab tile for this depth range
            float3 tileCenterWS = s_tileCenter[depthRangeIndex];
            float tileRadiusWS = asfloat(s_tileRadiusU[depthRangeIndex]);

            // gather data
            CasterCullingData cullingData;
            CasterRenderData renderData;
            renderData.maxCosTheta = caster.maxCosTheta;
            renderData.shadowRange = caster.shadowRange;
            if (caster.casterType == CAPSULESHADOWCASTERTYPE_DIRECTIONAL)
            {
                renderData.positionWS = caster.directionWS;
                renderData.radiusWS = 0.f;

                cullingData.tileToLightDir = caster.directionWS;
                cullingData.tileToLightDistance = FLT_MAX;
                cullingData.penumbraCosTheta = caster.maxCosTheta;

                // TODO: are there any ways to cull the tile outside of the directional light volume?
                isValid = true;
            }
            else // CAPSULESHADOWCASTERTYPE_POINT or CAPSULESHADOWCASTERTYPE_SPOT
            {
                renderData.positionWS = caster.positionRWS;
                renderData.radiusWS = caster.radiusWS;

                float3 tileToLightVec = caster.positionRWS - tileCenterWS;
                float tileToLightDistance = length(tileToLightVec);;
                cullingData.tileToLightDir = tileToLightVec/tileToLightDistance;
                cullingData.tileToLightDistance = tileToLightDistance;

                float sinTheta = max(0.f, caster.radiusWS/(tileToLightDistance - tileRadiusWS));
                cullingData.penumbraCosTheta = min(caster.maxCosTheta, MatchingSinCos(sinTheta));

                // check the tile is within the volume of the light
                isValid = (tileToLightDistance < caster.lightRange);
                if (caster.casterType == CAPSULESHADOWCASTERTYPE_SPOT)
                {
                    float tileConeSinTheta = tileRadiusWS/tileToLightDistance;
                    float tileConeCosTheta = MatchingSinCos(tileConeSinTheta);

                    float spotConeCosTheta = caster.spotCosTheta;
                    float spotConeSinTheta = MatchingSinCos(spotConeCosTheta);

                    // cos(a + b) = cos(a)cos(b) - sin(a)sin(b)
                    float combinedCosTheta = spotConeCosTheta*tileConeCosTheta - spotConeSinTheta*tileConeSinTheta;

                    // check the tile is within the spot cone
                    float cosAngleBetweenLightDirAndTileCenter = dot(cullingData.tileToLightDir, caster.directionWS);
                    isValid = isValid && (cosAngleBetweenLightDirAndTileCenter > combinedCosTheta);
                }
            }

            s_casterCullingData[CASTER_CULLING_INDEX(casterIndex, depthRangeIndex)] = cullingData;
            if (depthRangeIndex == 0)
                s_casterRenderData[casterIndex] = renderData;
        }
        if (isValid)
            InterlockedOr(s_casterValidBits, 1U << casterIndex);
    }
    GroupMemoryBarrierWithGroupSync();
    return s_casterValidBits != 0;
}

bool CapsuleIntersectsTile(CapsuleOccluderData capsuleData, uint depthRangeIndex, float3 tileCenterWS, float tileRadiusWS)
{
    float3 tileToCapsuleVec = capsuleData.centerRWS - tileCenterWS;
    float3 tileToClosestPointOnCapsuleAxis
        = tileToCapsuleVec
        + clamp(RayClosestPoint(tileToCapsuleVec, capsuleData.axisDirWS, 0.f), -capsuleData.offset, capsuleData.offset)*capsuleData.axisDirWS;
    float capsuleSignedDistanceFromTile = length(tileToClosestPointOnCapsuleAxis) - capsuleData.radius - tileRadiusWS;

    uint casterType = GetCapsuleCasterType(capsuleData);

    bool intersectsTile;
    if (casterType == CAPSULESHADOWCASTERTYPE_INDIRECT)
    {
        // only check range
        intersectsTile = (capsuleSignedDistanceFromTile < capsuleData.radius*_CapsuleIndirectRangeFactor);
    }
    else
    {
        // grab caster data
        uint casterIndex = GetCapsuleCasterIndex(capsuleData);
        intersectsTile = (((s_casterValidBits >> casterIndex) & 1) != 0);
        if (intersectsTile)
        {
            CasterCullingData cullingData = s_casterCullingData[CASTER_CULLING_INDEX(casterIndex, depthRangeIndex)];
            CasterRenderData renderData = s_casterRenderData[casterIndex];

            // check range
            intersectsTile = (capsuleSignedDistanceFromTile < renderData.shadowRange);

            // check penumbra
            if (cullingData.penumbraCosTheta != 0.f)
            {
                // check the smallest between the light axis and the capsule, from points in the tile
                bool intersectsPenumbra = (capsuleSignedDistanceFromTile < 0.f);
                if (capsuleSignedDistanceFromTile < cullingData.tileToLightDistance)
                {
                    float closestT = RayVsRayClosestPoints(tileToCapsuleVec, capsuleData.axisDirWS, 0.f, cullingData.tileToLightDir).x;
                    float3 tileToCheckPos = tileToCapsuleVec + capsuleData.axisDirWS*clamp(closestT, -capsuleData.offset, capsuleData.offset);

                    float distanceAlongAxis = dot(tileToCheckPos, cullingData.tileToLightDir);
                    float distanceFromAxis = length(tileToCheckPos - distanceAlongAxis*cullingData.tileToLightDir);

                    distanceFromAxis = max(0.f, distanceFromAxis - capsuleData.radius - tileRadiusWS);

                    float cosTheta = distanceAlongAxis/sqrt(Sq(distanceFromAxis) + Sq(distanceAlongAxis));
                    intersectsPenumbra = intersectsPenumbra || (cosTheta > cullingData.penumbraCosTheta);
                }
                intersectsTile = intersectsTile && intersectsPenumbra;
            }
        }
    }
    return intersectsTile;
}

#define INVALID_NORMAL_TAG  2.f

void UpdateVisibility(uint flatThreadIndex, uint casterIndex, float occlusion)
{
    // stored as slices per pixel
    uint entryIndex = (casterIndex/2)*TILE_SIZE*TILE_SIZE + flatThreadIndex;
    uint packedValue = s_packedVisibility[entryIndex];

    uint visibilityUnorm;
    if ((casterIndex & 1) == 0)
        visibilityUnorm = packedValue & 0xffffU;
    else
        visibilityUnorm = packedValue >> 16;

    float visibility = (float)visibilityUnorm; // keep 0-65535
    visibility *= (1.f - occlusion);
    visibilityUnorm = min((uint)visibility, 0xffffU);

    if ((casterIndex & 1) == 0)
        packedValue = (packedValue & 0xffff0000) | visibilityUnorm;
    else
        packedValue = (packedValue & 0x0000ffff) | (visibilityUnorm << 16);

    s_packedVisibility[entryIndex] = packedValue;
}

float ReadVisibility(uint flatThreadIndex, uint casterIndex)
{
    uint entryIndex = (casterIndex/2)*TILE_SIZE*TILE_SIZE + flatThreadIndex;
    uint packedValue = s_packedVisibility[entryIndex];

    uint visibilityUnorm;
    if ((casterIndex & 1) == 0)
        visibilityUnorm = packedValue & 0xffffU;
    else
        visibilityUnorm = packedValue >> 16;

    return (float)visibilityUnorm*(1.f/65535.f);
}

void CapsuleShadowLoop(
    uint2 fullResCoord,
    float3 positionWS,
    uint flatThreadIndex,
    bool useSecondDepthRange,
    inout uint processedCapsuleCounter)
{
    float3 tileCenterWS0 = s_tileCenter[0];
    float tileRadiusWS0 = asfloat(s_tileRadiusU[0]);
    float3 normalWS = float3(fullResCoord.x, fullResCoord.y, INVALID_NORMAL_TAG);

    // loop over capsules in batches
    uint shadowCount = _CapsuleShadowCounters[0];
    for (uint shadowBaseIndex = 0; shadowBaseIndex < shadowCount; shadowBaseIndex += 64)
    {
        // clear state
        if (flatThreadIndex < 2)
            s_intersectionBits[flatThreadIndex] = 0;
        GroupMemoryBarrierWithGroupSync();

        // use one thread per capsule to check against tile
        // TODO: check if any pixels still visible?
        {
            uint shadowIndex = shadowBaseIndex + flatThreadIndex;
            if (shadowIndex < shadowCount)
            {
                CapsuleOccluderData capsule = _CapsuleOccluderShadows[shadowIndex];

                bool intersectsTile = CapsuleIntersectsTile(capsule, 0, tileCenterWS0, tileRadiusWS0);
                if (useSecondDepthRange && !intersectsTile)
                    intersectsTile = CapsuleIntersectsTile(capsule, 1, s_tileCenter[1], asfloat(s_tileRadiusU[1]));

                if (intersectsTile)
                    InterlockedOr(s_intersectionBits[flatThreadIndex/32], 1U << (flatThreadIndex % 32));
            }
        }
        GroupMemoryBarrierWithGroupSync();

        // loop over set bits to do the shading
        uint remainingBits = s_intersectionBits[0];
        if (normalWS.z == INVALID_NORMAL_TAG && (remainingBits != 0 || s_intersectionBits[1] != 0))
        {
            uint2 coord = uint2(normalWS.xy);
            float4 normalBufferData = LOAD_TEXTURE2D_X(_NormalBufferTexture, coord);

            NormalData normalData;
            DecodeFromNormalBuffer(normalBufferData, normalData);
            normalWS = normalData.normalWS;
        }
        bool secondPass = false;
        for (;;)
        {
            if (remainingBits == 0 && !secondPass)
            {
                remainingBits = s_intersectionBits[1];
                secondPass = true;
            }
            if (remainingBits == 0)
                break;

            int bitIndex = firstbitlow(remainingBits);
            remainingBits &= ~(1U << bitIndex);

            uint shadowIndex = shadowBaseIndex + (secondPass ? 32 : 0) + (uint)bitIndex;

            CapsuleOccluderData capsule = _CapsuleOccluderShadows[shadowIndex];
            uint casterIndex = GetCapsuleCasterIndex(capsule);
            uint casterType = GetCapsuleCasterType(capsule);

            float occlusion;
            if (casterType == CAPSULESHADOWCASTERTYPE_INDIRECT)
            {
                uint method = _CapsuleIndirectShadowMethod;
                if (method == CAPSULEINDIRECTSHADOWMETHOD_AMBIENT_OCCLUSION)
                {
                    occlusion = EvaluateCapsuleAmbientOcclusion(
                        GetCapsuleAmbientOcclusionFlags(),
                        capsule.centerRWS - positionWS,
                        capsule.axisDirWS,
                        capsule.offset,
                        capsule.radius,
                        capsule.radius*_CapsuleIndirectRangeFactor,
                        normalWS);
                }
                else // method == CAPSULEINDIRECTSHADOWMETHOD_DIRECTION_AT_CAPSULE
                {
                    occlusion = EvaluateCapsuleOcclusion(
                        GetCapsuleIndirectOcclusionFlags(),
                        capsule.indirectDirWS,
                        false,
                        _CapsuleIndirectCosAngle,
                        capsule.centerRWS - positionWS,
                        capsule.axisDirWS,
                        capsule.offset,
                        capsule.radius,
                        capsule.radius*_CapsuleIndirectRangeFactor,
                        normalWS);
                }
#ifdef CAPSULE_TILE_DEBUG
                if (_CapsuleTileDebugMode == CAPSULETILEDEBUGMODE_INDIRECT)
                    ++processedCapsuleCounter;
#endif
            }
            else
            {
                CasterRenderData renderData = s_casterRenderData[casterIndex];
                if (casterType == CAPSULESHADOWCASTERTYPE_DIRECTIONAL)
                {
                    occlusion = EvaluateCapsuleOcclusion(
                        GetCapsuleDirectOcclusionFlags(),
                        renderData.positionWS,
                        false,
                        renderData.maxCosTheta,
                        capsule.centerRWS - positionWS,
                        capsule.axisDirWS,
                        capsule.offset,
                        capsule.radius,
                        renderData.shadowRange,
                        normalWS);
                }
                else // casterType == CAPSULESHADOWCASTERTYPE_POINT
                {
                    float3 surfaceToLightVec = renderData.positionWS - positionWS;
                    float sinTheta = renderData.radiusWS/length(surfaceToLightVec);
                    float cosTheta = min(renderData.maxCosTheta, MatchingSinCos(sinTheta));
                    occlusion = EvaluateCapsuleOcclusion(
                        GetCapsuleDirectOcclusionFlags(),
                        surfaceToLightVec,
                        true,
                        cosTheta,
                        capsule.centerRWS - positionWS,
                        capsule.axisDirWS,
                        capsule.offset,
                        capsule.radius,
                        renderData.shadowRange,
                        normalWS);
                }
#ifdef CAPSULE_TILE_DEBUG
                if (_CapsuleTileDebugMode == CAPSULETILEDEBUGMODE_DIRECT)
                    ++processedCapsuleCounter;
#endif
            }
            UpdateVisibility(flatThreadIndex, casterIndex, occlusion);
        }
    }
}

float2 GetPositionNDC(uint2 pixelCoord, bool isHalfRes)
{
    float2 upscaledPosSS = float2(pixelCoord) + .5f;
    if (isHalfRes) {
        upscaledPosSS *= 2.f;
    }
    return upscaledPosSS * _CapsuleUpscaledSize.zw;
}

[numthreads(TILE_SIZE,TILE_SIZE,1)]
void Main(uint3 dispatchThreadId : SV_DispatchThreadID, uint flatThreadIndex : SV_GroupIndex)
{
    uint2 pixelCoord = dispatchThreadId.xy;
    UNITY_XR_ASSIGN_VIEW_INDEX(dispatchThreadId.z);

    bool isHalfRes = _CapsuleShadowIsHalfRes;

    // would like to load half res depth, but get shading errors when the depth doesn't match the normal
    float deviceDepth = LOAD_TEXTURE2D_X(_CameraDepthTexture, pixelCoord + (isHalfRes ? _FirstDepthMipOffset : 0)).x;
    bool is_sky = (deviceDepth == UNITY_RAW_FAR_CLIP_VALUE);

    float2 upscaledPosNDC = GetPositionNDC(pixelCoord, isHalfRes);
    float4 positionCS = ComputeClipSpacePosition(upscaledPosNDC, deviceDepth);

    // TODO: handle orthographic/oblique
    float4x4 invProj = UNITY_MATRIX_I_P;
    float linearDepth = invProj._m23/(invProj._m32 * positionCS.z + invProj._m33);
    float2 viewFromClipScale = float2(invProj._m00, invProj._m11);
    float2 viewFromClipOffset = float2(invProj._m03, invProj._m13);
    float2 fullResPixelHalfExtentAtUnitDepth = abs(viewFromClipScale*_CapsuleUpscaledSize.zw);

    float2 positionVS_XY = viewFromClipScale*positionCS.xy + viewFromClipOffset;
    float3 positionWS = TransformViewToWorld(ViewspaceFromXY(positionVS_XY, linearDepth));

    uint2 fullResCoord = pixelCoord;
    if (isHalfRes) {
        fullResCoord = fullResCoord*2 + ((asuint(deviceDepth) >> uint2(0, 1)) & 1);
    }

    // TODO: handle scaled view matrix?
    float absWorldFromViewScale = 1.f;

    if (flatThreadIndex < DEPTH_RANGE_COUNT)
    {
        s_depthMinU[flatThreadIndex] = DEPTH_MIN_EMPTY;
        s_depthMaxU[flatThreadIndex] = DEPTH_MAX_EMPTY;
        s_tileRadiusU[flatThreadIndex] = 0;
    }
    for (uint packedIndex = 0; packedIndex < MAX_SLICE_COUNT/2; ++packedIndex)
        s_packedVisibility[packedIndex*TILE_SIZE*TILE_SIZE + flatThreadIndex] = 0xffffffffU; // 1.0
    GroupMemoryBarrierWithGroupSync();

    // TODO: ignore depths beyond the max possible capsule shadow extent from camera
    if (!is_sky)
    {
        float depth = max(MIN_LINEAR_DEPTH, PACK_UNPACK_POSITIVE_DEPTH(linearDepth));
        InterlockedMin(s_depthMinU[0], asuint(depth));
        InterlockedMax(s_depthMaxU[1], asuint(depth));
    }
    GroupMemoryBarrierWithGroupSync();

    // early out if tile is all far clip
    if (s_depthMinU[0] == DEPTH_MIN_EMPTY)
    {
#ifdef CAPSULE_TILE_DEBUG
        if (flatThreadIndex == 0)
            _CapsuleTileDebug[COORD_TEXTURE2D_X(pixelCoord/8)] = 0;
#endif
        return;
    }

    // split the depth range at the midpoint in log-linear space directly (the sign bit is 0 so this does not overflow)
    float depthSplit = asfloat((s_depthMinU[0] + s_depthMaxU[1])/2);
    if (!is_sky)
    {
        float depth = max(MIN_LINEAR_DEPTH, PACK_UNPACK_POSITIVE_DEPTH(linearDepth));
        if (depth < depthSplit)
            InterlockedMax(s_depthMaxU[0], asuint(depth));
        else
            InterlockedMin(s_depthMinU[1], asuint(depth));
    }
    GroupMemoryBarrierWithGroupSync();
    if (flatThreadIndex == 0)
    {
        uint depthMinU0 = s_depthMinU[0];
        uint depthMinU1 = s_depthMinU[1];
        uint depthMaxU0 = s_depthMaxU[0];
        uint depthMaxU1 = s_depthMaxU[1];

        // handle empty region either side of the split
        if (depthMaxU0 == DEPTH_MAX_EMPTY)
            depthMaxU0 = depthMinU0;
        if (depthMinU1 == DEPTH_MIN_EMPTY)
            depthMinU1 = depthMaxU0;

        // revert back to a single depth range if we don't skip much space (for performance)
        float totalDepthRange = asfloat(depthMaxU1) - asfloat(depthMinU0);
        float skipDepthRange = asfloat(depthMinU1) - asfloat(depthMaxU0);
        float tileSizeAtUnitDepth = TILE_SIZE*(isHalfRes ? 4 : 2)*MaxElement(fullResPixelHalfExtentAtUnitDepth);
        float tileSizeAtMaxDepth = tileSizeAtUnitDepth*asfloat(depthMaxU1);
        if (!_CapsuleSplitDepthRange || skipDepthRange < 4.f*tileSizeAtMaxDepth)
        {
            depthMaxU0 = depthMaxU1;
            depthMinU1 = depthMinU0;
        }

        s_depthMinU[0] = depthMinU0;
        s_depthMinU[1] = depthMinU1;
        s_depthMaxU[0] = depthMaxU0;
        s_depthMaxU[1] = depthMaxU1;
    }
    GroupMemoryBarrierWithGroupSync();

    // TODO: splitting planes for froxel
    // TODO: move work to setup pass to run as one tile per thread
    // TODO: save/restore to LDS each pass to free up registers
    if (flatThreadIndex < 2)
    {
        float nearLinearDepth = PACK_UNPACK_POSITIVE_DEPTH(asfloat(s_depthMinU[flatThreadIndex]));
        float farLinearDepth = PACK_UNPACK_POSITIVE_DEPTH(asfloat(s_depthMaxU[flatThreadIndex]));
        float midLinearDepth = 0.5f*(nearLinearDepth + farLinearDepth);
        s_tileCenter[flatThreadIndex] = ViewspaceFromXY(positionVS_XY, midLinearDepth);
    }
    GroupMemoryBarrierWithGroupSync();

    // get bounding sphere radius
    {
        // check one corner on each thread
        uint depthRangeIndex = flatThreadIndex & 1;
        uint cornerIndex = flatThreadIndex >> 1;
        float cornerLinearDepth0 = PACK_UNPACK_POSITIVE_DEPTH(asfloat(s_depthMinU[depthRangeIndex]));
        float cornerLinearDepth1 = PACK_UNPACK_POSITIVE_DEPTH(asfloat(s_depthMaxU[depthRangeIndex]));
        if (cornerIndex < 8)
        {
            float2 tileHalfExtentAtUnitDepth = TILE_SIZE*(isHalfRes ? 2 : 1)*fullResPixelHalfExtentAtUnitDepth;
            float2 cornerVS_XY
                = positionVS_XY
                + float2((cornerIndex & 1) != 0 ? 1.f : -1.f, (cornerIndex & 2) != 0 ? 1.f : -1.f)*tileHalfExtentAtUnitDepth;
            float cornerLinearDepth = ((cornerIndex & 4) != 0 ? cornerLinearDepth1 : cornerLinearDepth0);
            float3 offsetVS = ViewspaceFromXY(cornerVS_XY, cornerLinearDepth) - s_tileCenter[depthRangeIndex];
            float tileRadiusWS = sqrt(dot(offsetVS, offsetVS)) * absWorldFromViewScale;
            InterlockedMax(s_tileRadiusU[depthRangeIndex], asuint(tileRadiusWS));
        }
    }

    // move the sphere center to world space
    if (flatThreadIndex < 2)
        s_tileCenter[flatThreadIndex] = TransformViewToWorld(s_tileCenter[flatThreadIndex]);

    // zero caster state
    s_casterValidBits = 0;
    GroupMemoryBarrierWithGroupSync();

    // check the casters vs the tile as a pre-process
    bool useSecondDepthRange = (s_depthMinU[0] != s_depthMinU[1] || s_depthMaxU[0] != s_depthMaxU[1]);
    if (!CastersIntersectTile(flatThreadIndex, useSecondDepthRange))
    {
#ifdef CAPSULE_TILE_DEBUG
        if (flatThreadIndex == 0)
            _CapsuleTileDebug[COORD_TEXTURE2D_X(pixelCoord/8)] = 0;
#endif
        return;
    }

    // zero working state
    for (uint packedIndex = 0; packedIndex < MAX_SLICE_COUNT/2; ++packedIndex)
        s_packedVisibility[packedIndex*TILE_SIZE*TILE_SIZE + flatThreadIndex] = 0xffffffffU; // 1.0
    GroupMemoryBarrierWithGroupSync();

    // optimise the loop separately depending on whether we are using one or two depth ranges
    uint processedCapsuleCounter = 0;
#ifdef CAPSULE_TILE_DEBUG
    if (_CapsuleTileDebugMode == CAPSULETILEDEBUGMODE_DEPTH_RANGE)
        processedCapsuleCounter = useSecondDepthRange ? 16 : 4;
#endif
    [branch]
    if (useSecondDepthRange)
        CapsuleShadowLoop(fullResCoord, positionWS, flatThreadIndex, true, processedCapsuleCounter);
    else
        CapsuleShadowLoop(fullResCoord, positionWS, flatThreadIndex, false, processedCapsuleCounter);

    // write results
    uint casterValidBits = s_casterValidBits;
    while (casterValidBits != 0)
    {
        uint casterIndex = firstbitlow(casterValidBits);
        casterValidBits &= ~(1U << casterIndex);
        _CapsuleShadowsRenderOutput[uint3(pixelCoord, casterIndex)] = PackCapsuleVisibility(ReadVisibility(flatThreadIndex, casterIndex));
    }
#ifdef CAPSULE_TILE_DEBUG
    if (flatThreadIndex == 0)
        _CapsuleTileDebug[COORD_TEXTURE2D_X(pixelCoord/8)] = processedCapsuleCounter;
#endif
}
