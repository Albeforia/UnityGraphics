#pragma only_renderers d3d11 playstation xboxone xboxseries vulkan metal switch
//#pragma enable_d3d11_debug_symbols

#pragma kernel Main

#include "Packages/com.unity.render-pipelines.core/Runtime/Lighting/CapsuleShadows/CapsuleShadowsCommon.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/NormalBuffer.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/CapsuleShadows/Shaders/CapsuleShadowsGlobals.hlsl"

StructuredBuffer<CapsuleOccluderData> _CapsuleOccluders;
StructuredBuffer<CapsuleShadowCaster> _CapsuleShadowCasters;
RWStructuredBuffer<CapsuleOccluderData> _CapsuleOccluderShadows;
RWBuffer<uint> _CapsuleShadowsIndirectArgs;

uint _CapsuleOccluderCount;
uint _CapsuleCasterCount;

[numthreads(64,1,1)]
void Main(uint dispatchThreadId : SV_DispatchThreadID)
{
	uint casterIndex = dispatchThreadId/_CapsuleOccluderCount;
	uint occluderIndex = dispatchThreadId - casterIndex*_CapsuleOccluderCount;
	if (casterIndex >= _CapsuleCasterCount)
		return;

	CapsuleOccluderData capsule = _CapsuleOccluders[occluderIndex];
	CapsuleShadowCaster caster = _CapsuleShadowCasters[casterIndex];

	// check occluder intersects the light
	if (caster.casterType == CAPSULESHADOWCASTERTYPE_POINT || caster.casterType == CAPSULESHADOWCASTERTYPE_SPOT)
	{
		float capsuleSignedDistance = CapsuleSignedDistance(caster.positionRWS - capsule.centerRWS, capsule.offset, capsule.axisDirWS, capsule.radius);
		if (caster.lightRange < capsuleSignedDistance)
			return;

		// TODO: spot cone
	}
	// TODO: check occluder vs frustum

	capsule.packedData
		= capsule.packedData
		| (caster.casterType << 8)
		| casterIndex
		;

	uint writeIndex;
	InterlockedAdd(_CapsuleShadowsIndirectArgs[CAPSULE_SHADOW_INDIRECT_INDEX_SHADOW_COUNT], 1, writeIndex);
	_CapsuleOccluderShadows[writeIndex] = capsule;
}
