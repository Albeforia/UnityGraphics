#pragma kernel MainUpsample
#pragma kernel MainReprojectLuminance
#pragma only_renderers d3d11 playstation xboxone xboxseries vulkan metal switch

#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/PostProcessing/Shaders/RTUpscale.hlsl"

TEXTURE2D_X_MSAA(float4, _ColorTextureMS);

//#pragma enable_d3d11_debug_symbols

#define THREAD_X 8
#define THREAD_Y 8
#define THREAD_TOTAL (THREAD_X*THREAD_Y)

void FsrSrtmF(inout float3 c)
{
    c*=rcp(max(max(c.r,c.g),c.b)+1.0);
}

// The extra max solves the c=1.0 case (which is a /0).
void FsrSrtmInvF(inout float3 c)
{
    c*=rcp(max(1.0/32768.0,1.0-max(max(c.r,c.g),c.b)));
}

float4 MsssTexF(int2 p, int s)
{
    float4 c = LOAD_TEXTURE2D_X_MSAA(_ColorTextureMS, p, s);
    FsrSrtmF(c.rgb);
    return c;
}

#include "Packages/com.unity.render-pipelines.high-definition/Runtime/PostProcessing/Shaders/MSSS.hlsl"


#define MSSS_INTERPOLATION_TIER_0 0
#define MSSS_INTERPOLATION_TIER_1 1
#define MSSS_INTERPOLATION_TIER_2 2
#define MSSS_INTERPOLATION_MODE MSSS_INTERPOLATION_TIER_1

TEXTURE2D_X(_InputMSSSLuminance);
TEXTURE2D_X(_InputDepthTexture);

RW_TEXTURE2D_X(CTYPE,  _OutputTexture);
RW_TEXTURE2D_X(float,  _OutputDepthTexture);
RW_TEXTURE2D_X(float2, _OutputMotionVectorTexture);
RW_TEXTURE2D_X(float4, _OutputMSSSLuminance);

float4 _SourceSize;
float4 _ViewPortSize;


float GetWeigtedNearestLum(float2 centerPos, int sId)
{
    float2 velocity;
    DecodeMotionVector(LOAD_TEXTURE2D_X(_CameraMotionVectorsTexture, centerPos), velocity);
    float2 repPos = centerPos - velocity * _ScreenSize.xy;
    float4 luminances = LOAD_TEXTURE2D_X(_InputMSSSLuminance, repPos);

    float2 inPixelCoord = frac(repPos) * 2.0 - 1.0;
    float weights = 0.0;
    float luminance = 0.0;
    const float4 masks[] = { {1,0,0,0}, {0,1,0,0}, {0,0,1,0}, {0,0,0,1} };

    static const float2 msaa4xSamplePoints[] = {
        float2(-2.0/8.0, -6.0/8.0),
        float2( 6.0/8.0, -2.0/8.0),
        float2(-6.0/8.0,  2.0/8.0),
        float2( 2.0/8.0,  6.0/8.0)
    };

    for (int i = 0; i < 4; ++i)
    {
        float2 dv = inPixelCoord - msaa4xSamplePoints[i];
        //float2 dv = msaa4xSamplePoints[sId] - msaa4xSamplePoints[i];
        float d = dot(dv, dv);
        float w = rcp(d*d + 1.0);
        w *= w;
        luminance += luminances[i] * w;
        weights += w;
    }

    return luminance / weights;
}

[numthreads(8,8,1)]
void MainReprojectLuminance(uint3 dti : SV_DispatchThreadID)
{
    float2 centerPos = dti.xy + 0.5; //center texel
    float2 uv = (centerPos) * _SourceSize.zw;

#if MSSS_INTERPOLATION_MODE == MSSS_INTERPOLATION_TIER_0
    float2 velocity = float2(0.0, 0.0);
    //Simple dumb interpolation
    DecodeMotionVector(LOAD_TEXTURE2D_X(_CameraMotionVectorsTexture, centerPos), velocity);
    float2 reprojectedPos = centerPos - velocity * _ScreenSize.xy;
    float4 luminances = LOAD_TEXTURE2D_X(_InputMSSSLuminance, reprojectedPos);
#elif MSSS_INTERPOLATION_MODE == MSSS_INTERPOLATION_TIER_1
    float4 luminances = float4(0,0,0,0);
    const float4 masks[] = { {1,0,0,0}, {0,1,0,0}, {0,0,1,0}, {0,0,0,1} };
    static const float2 msaa4xSamplePoints[] = {
        float2(-2.0/8.0, -6.0/8.0),
        float2( 6.0/8.0, -2.0/8.0),
        float2(-6.0/8.0,  2.0/8.0),
        float2( 2.0/8.0,  6.0/8.0)
    };
    for (int i = 0; i < 4; ++i)
    {
        float value = GetWeigtedNearestLum(centerPos + 0.5 * msaa4xSamplePoints[i], i);
        luminances += value * masks[i];
    }
    
#elif MSSS_INTERPOLATION_MODE == MSSS_INTERPOLATION_TIER_2
    #error "Unimplemented"
#endif
    
    _OutputMSSSLuminance[COORD_TEXTURE2D_X(dti.xy)] = luminances;
}

float calcLum(float3 colorIn)
{
    return max(colorIn.r, max(colorIn.g, colorIn.b));
}

#if 1
//non optimized
void writeLuminance(int2 dti, int2 gti)
{
    int2 p = dti.xy;
    if (any(p >= (int2)_SourceSize.xy))
        return;

    float3 sample0 = MsssTexF(p, 0).rgb;
    float3 sample1 = MsssTexF(p, 1).rgb;
    float3 sample2 = MsssTexF(p, 2).rgb;
    float3 sample3 = MsssTexF(p, 3).rgb;

    _OutputMSSSLuminance[COORD_TEXTURE2D_X(p)] = float4(calcLum(sample0), calcLum(sample1), calcLum(sample2), calcLum(sample3));
}
#else
//optimized with LDS
groupshared float s_cachedLum[THREAD_TOTAL];

void writeLuminance(int2 dti, int2 gti)
{
    const int2 halfThreads = int2(THREAD_X >> 1, THREAD_Y >> 1);
    int2 p = dti.xy >> 1;
    int2 target = p & (halfThreads - 1);
    int sampleId = (gti.x & 0x1) + ((gti.y & 0x1) << 0x1);

    int baseLdsIndex = (target.y * halfThreads.x + target.x) * 4;
    s_cachedLum[baseLdsIndex + sampleId] = calcLum(MsssTexF(p, sampleId).rgb);

    GroupMemoryBarrierWithGroupSync();

    if (all(p < _SourceSize.xy) && sampleId == 0)
    {
        _OutputMSSSLuminance[COORD_TEXTURE2D_X(p)] = float4(
            s_cachedLum[baseLdsIndex + 0],
            s_cachedLum[baseLdsIndex + 1],
            s_cachedLum[baseLdsIndex + 2],
            s_cachedLum[baseLdsIndex + 3]);
    }
}
#endif

[numthreads(THREAD_X,THREAD_Y,1)]
void MainUpsample (uint3 dti : SV_DispatchThreadID, int2 gti : SV_GroupThreadID)
{
    UNITY_XR_ASSIGN_VIEW_INDEX(dti.z);
    float2 uvs = ((float2)dti.xy + 0.5f) * _ViewPortSize.zw;
    uint2 colorCoord = dti.xy;

    float2 scale = _SourceSize.xy / _ViewPortSize.xy;
    float4 sampledColor = float4(0,0,0,1);

    writeLuminance((int2)dti.xy, gti);

    sampledColor.rgb = MsssF(
        //  p ....... integer pixel position in the output
        dti.xy,
        //  k0.xy ... input/output resolution
        //  k0.zw ... k0.xy * 0.5 - 0.5
        float4(scale.x,scale.y,scale.x*0.5-0.5,scale.y*0.5-0.5)).rgb;

    FsrSrtmInvF(sampledColor.rgb);
    
    float4 debugLuminance = SAMPLE_TEXTURE2D_X_LOD(_InputMSSSLuminance, s_linear_clamp_sampler, uvs, 0);

#if 1
    _OutputTexture[COORD_TEXTURE2D_X(dti.xy)] = (CTYPE)debugLuminance;
#else
    _OutputTexture[COORD_TEXTURE2D_X(dti.xy)] = sampledColor;
#endif

    _OutputDepthTexture[COORD_TEXTURE2D_X(dti.xy)] = Nearest(_InputDepthTexture, uvs).x;
    _OutputMotionVectorTexture[COORD_TEXTURE2D_X(dti.xy)] = Bilinear(_CameraMotionVectorsTexture, uvs).xy;
}
