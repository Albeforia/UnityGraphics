
        Pass
        {
            Name "IndirectDXR"
            Tags{ "LightMode" = "IndirectDXR" }

            HLSLPROGRAM
            #pragma target 4.5
            #pragma only_renderers d3d11 ps5
            #pragma raytracing surface_shader

            // This pass is used by the sphere primitive
            #define RAY_TRACING_SPHERE_PRIMITIVE

            #define SHADERPASS SHADERPASS_RAYTRACING_VISIBILITY

            // Global includes
            #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/ShaderVariablesRaytracing.hlsl"

            // Need to override the macros for ray tracing
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/RaytracingMacros.hlsl"

            // VFX includes
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/VFXGraph/Shaders/VFXCommon.hlsl"
            #include "Packages/com.unity.visualeffectgraph/Shaders/VFXCommon.hlsl"
            
            // Material includes
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/RaytracingIntersection.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/Common/RayTracingProcedural.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/RayTracingCommon.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/NormalBuffer.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/NormalBuffer.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/Common/AtmosphericScatteringRayTracing.hlsl"

            ${VFXGeneratedBlockFunction}

            [shader("closesthit")]
            void ClosestHit(inout RayIntersection rayIntersection : SV_RayPayload, AttributeData attributeData : SV_IntersectionAttributes)
            {
                UNITY_XR_ASSIGN_VIEW_INDEX(DispatchRaysIndex().z);

                VFXAttributes attributes;
                ZERO_INITIALIZE(VFXAttributes, attributes);

                // Index needs to be available in the context for the attribute load to work
                uint index = PrimitiveIndex();

                // Load the attributes
                ${VFXLoadAttributes}

                // Compute the distance of the ray
                rayIntersection.t = RayTCurrent();
                
                // The first thing that we should do is grab the intersection vertice
                IntersectionVertex currentVertex;
                currentVertex.normalOS = UnpackNormalOctQuadEncode(attributeData.barycentrics);
                currentVertex.tangentOS = float4(0, 0, 1, 0);
                currentVertex.texCoord0 = 0.0;
                currentVertex.texCoord1 = 0.0;
                currentVertex.texCoord2 = 0.0;
                currentVertex.texCoord3 = 0.0;
                currentVertex.color = float4(attributes.color, 1.0);

                // Given that we will be multiplying the final color by the current exposure multiplier outside of this function, we need to make sure that
                // the unlit color is not impacted by that. Thus, we multiply it by the inverse of the current exposure multiplier.
                DirectionalLightData light = _DirectionalLightDatas[0];
                rayIntersection.color = dot(-light.forward, currentVertex.normalOS) * currentVertex.color.xyz * GetInverseCurrentExposureMultiplier();

                // Apply fog attenuation
                ApplyFogAttenuation(WorldRayOrigin(), WorldRayDirection(), rayIntersection.t, rayIntersection.color, true);
            }

            [shader("intersection")]
            void IntersectionShader()
            {
                UNITY_XR_ASSIGN_VIEW_INDEX(DispatchRaysIndex().z);
                
                VFXAttributes attributes;
                ZERO_INITIALIZE(VFXAttributes, attributes);
                
                // Index needs to be available in the context for the attribute load to work
                uint index = PrimitiveIndex();

                // Load the VFX attributes that we need for this
                ${VFXLoadAttributes}
                ${VFXProcessBlocks}
                ${VFXLoadSize}

                // Execute the matching intersection code
                IntersectPrimitive(attributes, size3);
            }
            ENDHLSL
        }
