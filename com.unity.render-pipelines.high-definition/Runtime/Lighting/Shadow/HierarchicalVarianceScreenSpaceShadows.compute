#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/TextureXR.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariablesGlobal.cs.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/Shadow/ShadowMoments.hlsl"

#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Random.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Sampling/Sampling.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/RaytracingSampling.hlsl"

#pragma only_renderers d3d11 playstation xboxone xboxseries vulkan metal switch

// #pragma enable_d3d11_debug_symbols

#pragma kernel RaymarchScreenSpaceShadowsVSM32 RaymarchScreenSpaceShadows=RaymarchScreenSpaceShadowsVSM32  KERNEL_SIZE=8 _HVSSS_MODE_VSM_32
#pragma kernel RaymarchScreenSpaceShadowsVSM16 RaymarchScreenSpaceShadows=RaymarchScreenSpaceShadowsVSM16 KERNEL_SIZE=8 _HVSSS_MODE_VSM_16
#pragma kernel RaymarchScreenSpaceShadowsMoments16 RaymarchScreenSpaceShadows=RaymarchScreenSpaceShadowsMoments16 KERNEL_SIZE=8 _HVSSS_MODE_MOMENTS_16
#pragma kernel RaymarchScreenSpaceShadowsEVSM32 RaymarchScreenSpaceShadows=RaymarchScreenSpaceShadowsEVSM32  KERNEL_SIZE=8 _HVSSS_MODE_EVSM_32
#pragma kernel RaymarchScreenSpaceShadowsEVSM16 RaymarchScreenSpaceShadows=RaymarchScreenSpaceShadowsEVSM16 KERNEL_SIZE=8 _HVSSS_MODE_EVSM_16

#pragma kernel RaymarchScreenSpaceShadowsVSM32TransmissionAccumulator RaymarchScreenSpaceShadows=RaymarchScreenSpaceShadowsVSM32TransmissionAccumulator KERNEL_SIZE=8 _HVSSS_MODE_VSM_32 TRANSMISSION_ACCUMULATOR_ENABLED
#pragma kernel RaymarchScreenSpaceShadowsVSM16TransmissionAccumulator RaymarchScreenSpaceShadows=RaymarchScreenSpaceShadowsVSM16TransmissionAccumulator KERNEL_SIZE=8 _HVSSS_MODE_VSM_16 TRANSMISSION_ACCUMULATOR_ENABLED
#pragma kernel RaymarchScreenSpaceShadowsMoments16TransmissionAccumulator RaymarchScreenSpaceShadows=RaymarchScreenSpaceShadowsMoments16TransmissionAccumulator KERNEL_SIZE=8 _HVSSS_MODE_MOMENTS_16 TRANSMISSION_ACCUMULATOR_ENABLED
#pragma kernel RaymarchScreenSpaceShadowsEVSM32TransmissionAccumulator RaymarchScreenSpaceShadows=RaymarchScreenSpaceShadowsEVSM32TransmissionAccumulator KERNEL_SIZE=8 _HVSSS_MODE_EVSM_32 TRANSMISSION_ACCUMULATOR_ENABLED
#pragma kernel RaymarchScreenSpaceShadowsEVSM16TransmissionAccumulator RaymarchScreenSpaceShadows=RaymarchScreenSpaceShadowsEVSM16TransmissionAccumulator KERNEL_SIZE=8 _HVSSS_MODE_EVSM_16 TRANSMISSION_ACCUMULATOR_ENABLED

#pragma kernel SeperableBilateralBlurVSM32 SeperableBilateralBlur=SeperableBilateralBlurVSM32 KERNEL_SIZE=8 _HVSSS_MODE_VSM_32
#pragma kernel SeperableBilateralBlurVSM16 SeperableBilateralBlur=SeperableBilateralBlurVSM16 KERNEL_SIZE=8 _HVSSS_MODE_VSM_16
#pragma kernel SeperableBilateralBlurMoments16 SeperableBilateralBlur=SeperableBilateralBlurMoments16 KERNEL_SIZE=8 _HVSSS_MODE_MOMENTS_16
#pragma kernel SeperableBilateralBlurEVSM32 SeperableBilateralBlur=SeperableBilateralBlurEVSM32 KERNEL_SIZE=8 _HVSSS_MODE_EVSM_32
#pragma kernel SeperableBilateralBlurEVSM16 SeperableBilateralBlur=SeperableBilateralBlurEVSM16 KERNEL_SIZE=8 _HVSSS_MODE_EVSM_16

#pragma kernel BilateralUpsampleVSM32 BilateralUpsample=BilateralUpsampleVSM32 KERNEL_SIZE=8 _HVSSS_MODE_VSM_32
#pragma kernel BilateralUpsampleVSM16 BilateralUpsample=BilateralUpsampleVSM16 KERNEL_SIZE=8 _HVSSS_MODE_VSM_16
#pragma kernel BilateralUpsampleMoments16 BilateralUpsample=BilateralUpsampleMoments16 KERNEL_SIZE=8 _HVSSS_MODE_MOMENTS_16
#pragma kernel BilateralUpsampleEVSM32 BilateralUpsample=BilateralUpsampleEVSM32 KERNEL_SIZE=8 _HVSSS_MODE_EVSM_32
#pragma kernel BilateralUpsampleEVSM16 BilateralUpsample=BilateralUpsampleEVSM16 KERNEL_SIZE=8 _HVSSS_MODE_EVSM_16

// #define HIGH_QUALITY_UPSAMPLE_ENABLED
// #define SCREEN_EDGE_VIGNETTE_ENABLED

TEXTURE2D_X(_DepthMomentsMipChain);
TEXTURE2D_X(_HVSSSSourceTexture);
RW_TEXTURE2D_X(float4, _HVSSSDestinationTexture);

CBUFFER_START(cb)
    float4 _SrcOffsetAndLimit; // {x, y, w - 1, h - 1}
    float4 _DstOffsetAndLimit; // {x, y, w - 1, h - 1}
    float4 _LODCurrentAndNextAndMax; // {current, next, max, channel}
    float4 _HVSSSLightPositionRWS;
    float4 _DepthMomentsMipChainSize;
    float4 _HVSSSCascadeRaymarchDistancePixelsStartEnd;
    float4 _HVSSSDepthMinMax;
    float4 _HVSSSDepthScaleBias;
    float4 _HVSSSThickness; // {min, max, 0, 0}
    float4 _HVSSSRaymarchLODBiasMinMax;
    float4 _HVSSSUpsampleBlurRadiusPixelsAndInverseSquared; // {radius, 1.0 / (radius * radius), 0.0, 0.0}
    float4 _HVSSSContrastAndBlackpointAndDitherMode; // {contrast, blackpoint, ditherMode, 0.0}
    float4 _HVSSSEVSMExponents;
CBUFFER_END

float ComputeChebyshevsInequalityWithThickness(float2 sampleMoments, float sampleDepth, float thickness, float varianceMin, float lightLeakBiasMax)
{
    // variance sig^2 = E(x^2) - E(x)^2
    float sampleVariance = max(sampleMoments.y - (sampleMoments.x * sampleMoments.x), 1e-7);

    float deviation = sampleDepth - sampleMoments.x;
    float deviationThickness = (sampleDepth + thickness) - sampleMoments.x;
    deviation = abs(deviation) <= abs(deviationThickness) ? deviation : deviationThickness;
    float p = sampleVariance / (sampleVariance + deviation * deviation);

    // Automatically compute a bias such that the midpoint between our distributions (halfway through our virtual walls),
    // which is the minimum probabilistic upper bound,
    // remaps to zero.
    // When the distributions heavily overlap (when thickness is small), the estimate is noisy, so avoid biasing too much.
    float lightLeakBias = min(lightLeakBiasMax, sampleVariance / (sampleVariance + thickness * thickness * 0.25));
    p = saturate((p - lightLeakBias) / (1.0 - lightLeakBias));
    
    return ((sampleDepth <= sampleMoments.x) || (sampleDepth > (sampleMoments.x + thickness))) ? 1.0 : p;
}

float ComputeChebyshevsInequalityWithThicknessTransmission(float2 sampleMoments, float sampleDepth, float thickness, float varianceMin, float blackpoint)
{
    float sampleVariance = max(sampleMoments.y - (sampleMoments.x * sampleMoments.x), varianceMin);
    float deviation = sampleDepth - sampleMoments.x;
    float deviationThickness = deviation - thickness;

    float sampleProbability = (deviation < 0.0) ? 1.0 : (sampleVariance / (sampleVariance + deviation * deviation));
    float sampleThicknessProbability = (deviationThickness > 0.0) ? 1.0 : (sampleVariance / (sampleVariance + deviationThickness * deviationThickness));

    float sampleShadow = (1.0 - sampleProbability) - sampleThicknessProbability;
    return saturate((sampleShadow - blackpoint) / (1.0 - blackpoint));
}

float ComputeHVSSSRaymarchSampleShadowVSM(float sampleDepth, float2 sampleMoments, float samplesStartEndAlpha, uint lodCurrent, float thicknessScale, float blackpoint)
{
    float sampleShadow = 1.0;

    // probabilistic upper bound
    // Because we are raymarching, rather than doing standard shadow map VSM evaluation, we evaluate 2x distributions:
    // 1) The depthMean
    // 2) the depthMean + Thickness
    // and take the max probabilistic upper bound of the two distributions.
    // Rather than evaluating the probabilistic upper bound of both, we can simply evaluate it once, using the nearest distribution.
    // This works because the variance used for both distributions is the same.
    float thickness = thicknessScale * lerp(1.0, 2.0, samplesStartEndAlpha);

#if defined(TRANSMISSION_ACCUMULATOR_ENABLED)
    sampleShadow = ComputeChebyshevsInequalityWithThicknessTransmission(sampleMoments, sampleDepth, thickness, 1e-7, blackpoint);
#else

    const float LIGHT_LEAK_BIAS_MAX = 0.0;
    sampleShadow = ComputeChebyshevsInequalityWithThickness(sampleMoments, sampleDepth, thickness, 1e-7, blackpoint);
#endif
    return sampleShadow;
}

float ComputeHVSSSRaymarchSampleShadowEVSM(float sampleDepthLinear, float4 sampleMoments, float samplesStartEndAlpha, uint lodCurrent, float thicknessScale, float4 hvsssDepthScaleBias, float4 hvsssEVSMExponents, float blackpoint)
{
    float sampleShadow = 1.0;

    // probabilistic upper bound
    // Because we are raymarching, rather than doing standard shadow map VSM evaluation, we evaluate 2x distributions:
    // 1) The depthMean
    // 2) the depthMean + Thickness
    // and take the max probabilistic upper bound of the two distributions.
    // Rather than evaluating the probabilistic upper bound of both, we can simply evaluate it once, using the nearest distribution.
    // This works because the variance used for both distributions is the same.
    float thickness = thicknessScale * lerp(1.0, 2.0, samplesStartEndAlpha);

    float sampleDepthNormalized = sampleDepthLinear * hvsssDepthScaleBias.x + hvsssDepthScaleBias.y;
    float2 sampleDepthWarped = ShadowMoments_WarpDepth(sampleDepthNormalized, hvsssEVSMExponents.xy);

    // Derivative of warping at depth
    float2 depthScale = 1e-7 * hvsssEVSMExponents.xy * sampleDepthWarped;
    float2 varianceMin = depthScale * depthScale;

    // 0.1 tuned to match rough visual appearance of VSM so that they are comparable.
    float2 thicknessWarped = float2(0.1, -0.1) * thickness * hvsssEVSMExponents.xy * sampleDepthWarped;

#if defined(TRANSMISSION_ACCUMULATOR_ENABLED)
    float contributionPositive = ComputeChebyshevsInequalityWithThicknessTransmission(sampleMoments.xz, sampleDepthWarped.x, thicknessWarped.x, varianceMin.x, blackpoint);
    float contributionNegative = ComputeChebyshevsInequalityWithThicknessTransmission(sampleMoments.yw, sampleDepthWarped.y, thicknessWarped.y, varianceMin.y, blackpoint);
    sampleShadow = max(contributionPositive, contributionNegative);
#else
  const float LIGHT_LEAK_BIAS_MAX = 0.0;
  float contributionPositive = ComputeChebyshevsInequalityWithThickness(sampleMoments.xz, sampleDepthWarped.x, thicknessWarped.x, varianceMin.x, blackpoint);
  float contributionNegative = ComputeChebyshevsInequalityWithThickness(sampleMoments.yw, sampleDepthWarped.y, thicknessWarped.y, varianceMin.y, blackpoint);
  sampleShadow = min(contributionPositive, contributionNegative);
#endif

    return sampleShadow;
}

float ComputeHVSSSRaymarchSampleShadowFourMomentsInner(float sampleDepthNormalized, float4 sampleMomentsDecoded, float blackpoint)
{
    float3 z;
    float4 b;
    const float MOMENT_BIAS = 0.05;
    ShadowMoments_SolveMSM(sampleMomentsDecoded, sampleDepthNormalized, MOMENT_BIAS, z, b);

    return (z[1] < 0.0 || z[2] > 1.0) ? ShadowMoments_SolveDelta4MSM(z, b, blackpoint) : ShadowMoments_SolveDelta3MSM(z, b.xy, blackpoint);
} 

float ComputeHVSSSRaymarchSampleShadowFourMoments(float sampleDepth, float4 sampleMoments, float samplesStartEndAlpha, uint lodCurrent, float thicknessScale, float4 hvsssDepthScaleBias, float blackpoint)
{
    sampleMoments = ShadowMoments_Decode16MSM(sampleMoments);
    sampleDepth = sampleDepth * hvsssDepthScaleBias.x + hvsssDepthScaleBias.y;

    float thickness = thicknessScale * lerp(1.0, 2.0, samplesStartEndAlpha);
    float depthThicknessMidpoint = sampleMoments.x + (thickness * 0.5 * hvsssDepthScaleBias.x);

#if defined(TRANSMISSION_ACCUMULATOR_ENABLED)
    float sampleProbability = ComputeHVSSSRaymarchSampleShadowFourMomentsInner(sampleDepth, sampleMoments, blackpoint);
    float sampleDepthThickness = sampleDepth;

    sampleDepthThickness += sampleDepthThickness + thickness * hvsssDepthScaleBias.x;
    float sampleThicknessProbability = ComputeHVSSSRaymarchSampleShadowFourMomentsInner(sampleDepthThickness, sampleMoments, blackpoint);
    return max(0.0, (1.0 - sampleThicknessProbability) - sampleProbability);
#else
    if (sampleDepth > depthThicknessMidpoint)
    {
        // In order to gracefully handle our second thickness distribution, simply mirror our depth value about the thickness midpoint.
        // This makes it effectively fade out as it exits the thickness.
        sampleDepth -= (sampleDepth - depthThicknessMidpoint) + thickness * 0.5 * hvsssDepthScaleBias.x;
    }

    return ComputeHVSSSRaymarchSampleShadowFourMomentsInner(sampleDepth, sampleMoments, blackpoint);
#endif
}

float ComputeHVSSSRaymarchSampleShadow(float sampleDepth, float4 sampleMoments, float samplesStartEndAlpha, uint lodCurrent, float thicknessScale, float4 hvsssDepthScaleBias, float4 hvsssEVSMExponents, float blackpoint)
{
#if defined(_HVSSS_MODE_MOMENTS_16)
    return ComputeHVSSSRaymarchSampleShadowFourMoments(sampleDepth, sampleMoments, samplesStartEndAlpha, lodCurrent, thicknessScale, hvsssDepthScaleBias, blackpoint);
#elif defined(_HVSSS_MODE_VSM_16) || defined(_HVSSS_MODE_VSM_32)
    return ComputeHVSSSRaymarchSampleShadowVSM(sampleDepth, sampleMoments.xy, samplesStartEndAlpha, lodCurrent, thicknessScale, blackpoint);
#elif defined(_HVSSS_MODE_EVSM_16) || defined(_HVSSS_MODE_EVSM_32)
    return ComputeHVSSSRaymarchSampleShadowEVSM(sampleDepth, sampleMoments, samplesStartEndAlpha, lodCurrent, thicknessScale, hvsssDepthScaleBias, hvsssEVSMExponents, blackpoint);
#else
    #error "ComputeHVSSSRaymarchSampleShadow not implemented for variant"
#endif
}

// Taken from ContactShadows.compute
float GetDepthCompareThreshold(float step, float rayStartZ, float rayOrthoZ)
{
    return abs(rayOrthoZ - rayStartZ) * max(0.07, step);
}

float3 ComputePositionVS(float2 uv, float depthLinear)
{
    float3 positionVS = ComputeViewSpacePosition(uv, 1.0, UNITY_MATRIX_I_P);
    positionVS.xyz /= positionVS.z;
    positionVS.xyz *= float3(depthLinear.x, depthLinear.x, -depthLinear.x);
    return positionVS;
}

float CompositeShadows(float a, float b)
{
#if defined(TRANSMISSION_ACCUMULATOR_ENABLED)
    return a * b;
#else
    return min(a, b);
#endif
}

bool IsFinalBlit(bool isRaymarchPass)
{
    return isRaymarchPass
        ? (_LODCurrentAndNextAndMax.x == 0)
        : (_LODCurrentAndNextAndMax.y == 0);
}

float ComputeContrast(float x)
{
    return pow(abs(x), lerp(1.0, 4.0, _HVSSSContrastAndBlackpointAndDitherMode.x));
}

float4 ComputeContrast(float4 x)
{
    return pow(abs(x), lerp(1.0, 4.0, _HVSSSContrastAndBlackpointAndDitherMode.x));
}

float ReadChannelDynamicBranch(float4 data, int channel)
{
    float res = 0.0;
    if (channel == 0) { res = data.x; }
    else if (channel == 1) { res = data.y; }
    else if (channel == 2) { res = data.z; }
    else if (channel == 3) { res = data.w; }
    return res;
}

float4 WriteChannelDynamicBranch(float source, float4 destination, int channel)
{
    float4 res = destination;
    if (channel == 0) { res.x = source; }
    else if (channel == 1) { res.y = source; }
    else if (channel == 2) { res.z = source; }
    else if (channel == 3) { res.w = source; }
    return res;
}

float LoadDepthLinearFromTexelCoord(uint2 sampleDepthLODTexelCoord, float4 hvsssDepthScaleBias, float4 hvsssEVSMExponents)
{
#if defined(_HVSSS_MODE_MOMENTS_16)
    float4 sampleMoments = LOAD_TEXTURE2D_X(_DepthMomentsMipChain, sampleDepthLODTexelCoord);
    sampleMoments = ShadowMoments_Decode16MSM(sampleMoments);
    sampleMoments.x = sampleMoments.x * hvsssDepthScaleBias.z + hvsssDepthScaleBias.w;
#elif defined(_HVSSS_MODE_VSM_16)
    float2 sampleMoments = LOAD_TEXTURE2D_X(_DepthMomentsMipChain, sampleDepthLODTexelCoord).xy;
    sampleMoments = ShadowMoments_Decode16VSM(sampleMoments);
    sampleMoments.x = sampleMoments.x * hvsssDepthScaleBias.z + hvsssDepthScaleBias.w;
#elif defined(_HVSSS_MODE_VSM_32)
    float2 sampleMoments = LOAD_TEXTURE2D_X(_DepthMomentsMipChain, sampleDepthLODTexelCoord).xy;
#elif defined(_HVSSS_MODE_EVSM_32)
    float4 sampleMoments = LOAD_TEXTURE2D_X(_DepthMomentsMipChain, sampleDepthLODTexelCoord);

    // sampleMoments.x = e^(exponent * sampleDepth)
    // log(sampleMoments.x) = log(e^(exponent * sampleDepth))
    // log(sampleMoments.x) = exponent * sampleDepth
    // log(sampleMoments.x) / exponent = sampleDepth
    sampleMoments.x = log(sampleMoments.x) * hvsssEVSMExponents.z * 0.5 + 0.5; // [-1, 1] -> [0.0, 1.0] space
    sampleMoments.x = sampleMoments.x * hvsssDepthScaleBias.z + hvsssDepthScaleBias.w;
#elif defined(_HVSSS_MODE_EVSM_16)
    float4 sampleMoments = LOAD_TEXTURE2D_X(_DepthMomentsMipChain, sampleDepthLODTexelCoord);
    sampleMoments = ShadowMoments_Decode16EVSM(sampleMoments, hvsssEVSMExponents.xy);

    // sampleMoments.x = e^(exponent * sampleDepth)
    // log(sampleMoments.x) = log(e^(exponent * sampleDepth))
    // log(sampleMoments.x) = exponent * sampleDepth
    // log(sampleMoments.x) / exponent = sampleDepth
    sampleMoments.x = log(sampleMoments.x) * hvsssEVSMExponents.z * 0.5 + 0.5; // [-1, 1] -> [0.0, 1.0] space
    sampleMoments.x = sampleMoments.x * hvsssDepthScaleBias.z + hvsssDepthScaleBias.w;
#else
    #error "LoadDepthLinearFromTexelCoord not implemented for variant"
#endif

    return sampleMoments.x;  
}

float ComputeVignetteWeight(float2 positionNDC)
{
    float2 sampleVignetteUV = saturate(positionNDC);
    float2 sampleVignetteCS = sampleVignetteUV * 2.0 - 1.0;
    float sampleVignetteWeight = saturate(max(abs(sampleVignetteCS.x), abs(sampleVignetteCS.y)) * 2.5 - 1.5);
    sampleVignetteWeight *= sampleVignetteWeight;
    return sampleVignetteWeight;
}

float ComputeThicknessScale(
    float2 thicknessMinMax,
    float2 positionNDC,
    float surfaceToLightDistanceNDC,
    float4 lightPositionNonHomogenizedCS,
    float sampleCountScale,
    float2 sampleRayDistanceNormalizedStartEnd,
    float4 zBufferParams,
    float4 projectionParams,
    float lodCurrent,
    float raymarchLODBias,
    float raymarchLODMin)
{
    float thicknessScale = lerp(thicknessMinMax.x, thicknessMinMax.y, saturate(max(abs(positionNDC.x * 2.0 - 1.0), abs(positionNDC.y * 2.0 - 1.0))));

    float4 rayOrthoViewSpace = float4(lightPositionNonHomogenizedCS.xyz * lightPositionNonHomogenizedCS.w, lightPositionNonHomogenizedCS.w) + float4(GetViewToHClipMatrix()[0][2], GetViewToHClipMatrix()[1][2], GetViewToHClipMatrix()[2][2], GetViewToHClipMatrix()[3][2]) * surfaceToLightDistanceNDC;
    rayOrthoViewSpace = rayOrthoViewSpace / rayOrthoViewSpace.w;

    float compareThreshold = GetDepthCompareThreshold(sampleCountScale / (sampleRayDistanceNormalizedStartEnd.y - sampleRayDistanceNormalizedStartEnd.x), lightPositionNonHomogenizedCS.z, rayOrthoViewSpace.z);

    thicknessScale *= (LinearEyeDepth(compareThreshold, zBufferParams) - projectionParams.y) * exp2(max(0.0, lodCurrent - raymarchLODBias + raymarchLODMin));

#if defined(_HVSSS_MODE_VSM_32) || defined(_HVSSS_MODE_VSM_16) || defined(_HVSSS_MODE_EVSM_32) || defined(_HVSSS_MODE_EVSM_16)
    thicknessScale *= 0.000225;
#elif defined(_HVSSS_MODE_MOMENTS_16)
    thicknessScale *= 0.002;
#else
    #error "ComputeThicknessScale not implemented for variant"
#endif

    return thicknessScale;
}

float4 ComputeSampleJitter(uint2 centerTexelCoord, int ditherMode, uint frameCount)
{
    float4 sampleJitter = 0.5;
    if (ditherMode == 1)
    {
        sampleJitter = float4(
            GetBNDSequenceSample(centerTexelCoord, frameCount & 7u, 0),
            GetBNDSequenceSample(centerTexelCoord, frameCount & 7u, 1),
            GetBNDSequenceSample(centerTexelCoord, frameCount & 7u, 2),
            GetBNDSequenceSample(centerTexelCoord, frameCount & 7u, 3)
        );
    }
    return sampleJitter;
}

float ComputeShadowAccumulatorTransform(float sampleShadow, int sampleIndex, float sampleCountScale, float sampleCountBias, float3 centerPositionVS, float3 samplePositionVSStart, float3 samplePositionVSEnd, float samplesStartEndAlpha, inout float rayDistancePrevious)
{
#if defined(TRANSMISSION_ACCUMULATOR_ENABLED)
    float rayDistanceCurrent = length(lerp(samplePositionVSStart, samplePositionVSEnd, (sampleIndex * sampleCountScale + sampleCountBias).xxx) - samplePositionVSStart);
    float stepDistance = rayDistanceCurrent - rayDistancePrevious;
    rayDistancePrevious = rayDistanceCurrent;

    float3 samplePositionVS = lerp(samplePositionVSStart, samplePositionVSEnd, samplesStartEndAlpha);
    float distanceWeight = stepDistance / (sampleCountScale * length(samplePositionVS - centerPositionVS));
    sampleShadow = exp(-sampleShadow * distanceWeight);
#endif
    return sampleShadow;
}

float4 SampleMomentsFromDepthMomentsMipChain(float2 sampleUV)
{
#if defined(_HVSSS_MODE_MOMENTS_16) || defined(_HVSSS_MODE_EVSM_16) || defined(_HVSSS_MODE_EVSM_32)
    float4 sampleMoments = SAMPLE_TEXTURE2D_X_LOD(_DepthMomentsMipChain, s_linear_clamp_sampler, sampleUV, 0);
#elif defined(_HVSSS_MODE_VSM_16) || defined(_HVSSS_MODE_VSM_32)
    float4 sampleMoments = float4(SAMPLE_TEXTURE2D_X_LOD(_DepthMomentsMipChain, s_linear_clamp_sampler, sampleUV, 0).xy, 0.0, 0.0); 
#else
    #error "SampleMomentsFromDepthMomentsMipChain not implemented for variant"
#endif

    return sampleMoments;
}

float4 DecodeMomentsForEvaluation(float4 moments, float4 hvsssDepthScaleBias, float4 hvsssEVSMExponents)
{
#if defined(_HVSSS_MODE_VSM_16)
    moments.xy = ShadowMoments_Decode16VSM(moments.xy);

    moments.x = moments.x * hvsssDepthScaleBias.z + hvsssDepthScaleBias.w;
    moments.y = pow(sqrt(moments.y) * hvsssDepthScaleBias.z + hvsssDepthScaleBias.w, 2.0);

#elif defined(_HVSSS_MODE_EVSM_16)
    moments = ShadowMoments_Decode16EVSM(moments, hvsssEVSMExponents.xy);

    // EVSM evaluation function expects moments in a [0, exponentMax] exponential space,
    // unlike VSM_16 no conversion from [0, 1] to [0, depthMax] occurs. 
#endif

    return moments;
}

[numthreads(KERNEL_SIZE, KERNEL_SIZE, 1)]
void RaymarchScreenSpaceShadows(uint3 dispatchThreadId : SV_DispatchThreadID)
{
    UNITY_XR_ASSIGN_VIEW_INDEX(dispatchThreadId.z);

    uint2 hvsssTexelCoord = dispatchThreadId.xy;

    uint2 depthLODDstOffset = _DstOffsetAndLimit.xy;
    uint2 depthLODDstLimit = _DstOffsetAndLimit.zw;
    uint2 depthLODDstSize = (depthLODDstLimit + 1u) - depthLODDstOffset;
    uint2 depthLODDstTexelCoord = depthLODDstOffset + hvsssTexelCoord;

    uint2 depthLODRaymarchOffset = _SrcOffsetAndLimit.xy;
    uint2 depthLODRaymarchLimit = _SrcOffsetAndLimit.zw;
    uint2 depthLODRaymarchSize = (depthLODRaymarchLimit + 1u) - depthLODRaymarchOffset;
    uint2 depthLODRaymarchTexelCoord = depthLODRaymarchOffset + hvsssTexelCoord * ((float2)depthLODRaymarchSize / (float2)depthLODDstSize);

    if (all(hvsssTexelCoord <= (depthLODDstLimit - depthLODDstOffset)))
    {
        uint lodCurrent = _LODCurrentAndNextAndMax.x;
        uint lodMax = _LODCurrentAndNextAndMax.z;
        uint channel = _LODCurrentAndNextAndMax.w;
        float3 lightPositionRWS = _HVSSSLightPositionRWS.xyz;
        float3 lightPositionVS = TransformWorldToView(lightPositionRWS);
        float lightDepthLinear = abs(lightPositionVS.z);
        float4 lightPositionCS = TransformWorldToHClip(lightPositionRWS);
        lightPositionCS.xyz /= lightPositionCS.w;
        float2 lightPositionNDC = lightPositionCS.xy * 0.5 + 0.5;
        lightPositionNDC.y = 1.0 - lightPositionNDC.y;
        float2 lightPositionSS = lightPositionNDC * depthLODRaymarchSize;
        lightPositionSS = clamp(lightPositionSS, 0, depthLODRaymarchLimit - depthLODRaymarchOffset);

        float centerDepth = LoadDepthLinearFromTexelCoord(depthLODDstTexelCoord, _HVSSSDepthScaleBias, _HVSSSEVSMExponents);

        float2 centerPositionSS = (float2)hvsssTexelCoord + 0.5;
        centerPositionSS *= (float2)depthLODRaymarchSize / (float2)depthLODDstSize;

        float2 centerPositionNDC = centerPositionSS / depthLODRaymarchSize;
        float3 centerPositionVS = ComputePositionVS(centerPositionNDC, centerDepth);

        float2 surfaceToLightOffsetSS = lightPositionSS - centerPositionSS;
        float surfaceToLightDistancePixels = length(surfaceToLightOffsetSS);

        // Avoid self shadowing artifacts by ignoring the first pixel in our raymarch - our center position
        // aka: do not bother testing for shadowing with ourselves.
        float raymarchOnePixelDistance = exp2(_LODCurrentAndNextAndMax.x - clamp(_HVSSSRaymarchLODBiasMinMax.x + _LODCurrentAndNextAndMax.x, 0.0, _LODCurrentAndNextAndMax.z));
        float cascadeRaymarchDistanceStart = clamp(_HVSSSCascadeRaymarchDistancePixelsStartEnd.x + raymarchOnePixelDistance, 0.0, surfaceToLightDistancePixels);
        float cascadeRaymarchDistanceEnd = clamp(_HVSSSCascadeRaymarchDistancePixelsStartEnd.y, cascadeRaymarchDistanceStart, surfaceToLightDistancePixels);
        
        float shadowData = 1.0;

        // Do not raymarch outside of the depth range of our light sources.
        // With this current check - if we had multiple light sources raymarching, this would be a conservative test that only earlys out
        // when outside of the range of all light sources. Could add some additional data to constrain the raymarch range per light.
        bool killRay = abs(0.5 - (centerDepth * _HVSSSDepthScaleBias.x + _HVSSSDepthScaleBias.y)) > 0.5;

        float3 lightOffsetVS = centerPositionVS.xyz - lightPositionVS.xyz;
        float lightDistanceSquaredVS = dot(lightOffsetVS, lightOffsetVS);
        float lightRangeSquared = _HVSSSLightPositionRWS.w * _HVSSSLightPositionRWS.w;
        killRay = killRay || (lightDistanceSquaredVS >= lightRangeSquared);

        if (!killRay)
        {
            int sampleCount = (int)ceil(cascadeRaymarchDistanceEnd - cascadeRaymarchDistanceStart);
            float sampleCountScale = 1.0 / sampleCount;
            float surfaceToLightDistancePixelsNormalization = surfaceToLightDistancePixels > 1e-5 ? (1.0 / surfaceToLightDistancePixels) : 0.0;
            float2 surfaceToLightDirectionSS = surfaceToLightOffsetSS * surfaceToLightDistancePixelsNormalization;

            float4 samplePositionSSStartEnd = surfaceToLightDirectionSS.xyxy * float2(cascadeRaymarchDistanceStart, cascadeRaymarchDistanceEnd).xxyy + centerPositionSS.xyxy;
            float4 sampleUVStartEnd = samplePositionSSStartEnd + (float4)depthLODRaymarchOffset.xyxy;
            sampleUVStartEnd *= _DepthMomentsMipChainSize.zwzw;
            float4 sampleUVBoundsMinMax = float4((float2)depthLODRaymarchOffset + 0.5, depthLODRaymarchLimit + 0.5) * _DepthMomentsMipChainSize.zwzw;
            float2 sampleRayDistanceNormalizedStartEnd = float2(cascadeRaymarchDistanceStart, cascadeRaymarchDistanceEnd) * surfaceToLightDistancePixelsNormalization;
            float2 sampleDepthStartEnd = lerp(centerDepth, lightDepthLinear, sampleRayDistanceNormalizedStartEnd);
            float3 samplePositionVSStart = lerp(centerPositionVS, lightPositionVS, sampleRayDistanceNormalizedStartEnd.x);
            float3 samplePositionVSEnd = lerp(centerPositionVS, lightPositionVS, sampleRayDistanceNormalizedStartEnd.y);

            float2 centerUV = centerPositionSS / depthLODRaymarchSize;
            float2 surfaceToLightOffsetNDC = surfaceToLightOffsetSS / depthLODRaymarchSize;
            float surfaceToLightDistanceNDC = length(surfaceToLightOffsetNDC);
            float thicknessScale = ComputeThicknessScale(_HVSSSThickness.xy, centerUV, surfaceToLightDistanceNDC, lightPositionCS, sampleCountScale, sampleRayDistanceNormalizedStartEnd, _ZBufferParams, _ProjectionParams, _LODCurrentAndNextAndMax.x, _HVSSSRaymarchLODBiasMinMax.x, _HVSSSRaymarchLODBiasMinMax.y);

            int ditherMode = (int)floor(_HVSSSContrastAndBlackpointAndDitherMode.z + 0.5);
            float4 sampleCountBias = sampleCountScale * ComputeSampleJitter(hvsssTexelCoord, ditherMode, _FrameCount);

            float rayDistancePrevious = 0.0;
            [loop] for (int i = 0; (i < sampleCount) && (shadowData > 1e-5); i += 4)
            {
                float4 samplesStartEndAlpha = saturate(float4(i, i + 1, i + 2, i + 3) * sampleCountScale + sampleCountBias);

                float2 sampleUV0 = lerp(sampleUVStartEnd.xy, sampleUVStartEnd.zw, samplesStartEndAlpha.x);
                sampleUV0 = clamp(sampleUV0, sampleUVBoundsMinMax.xy, sampleUVBoundsMinMax.zw);

                float2 sampleUV1 = lerp(sampleUVStartEnd.xy, sampleUVStartEnd.zw, samplesStartEndAlpha.y);
                sampleUV1 = clamp(sampleUV1, sampleUVBoundsMinMax.xy, sampleUVBoundsMinMax.zw);

                float2 sampleUV2 = lerp(sampleUVStartEnd.xy, sampleUVStartEnd.zw, samplesStartEndAlpha.z);
                sampleUV2 = clamp(sampleUV2, sampleUVBoundsMinMax.xy, sampleUVBoundsMinMax.zw);

                float2 sampleUV3 = lerp(sampleUVStartEnd.xy, sampleUVStartEnd.zw, samplesStartEndAlpha.w);
                sampleUV3 = clamp(sampleUV3, sampleUVBoundsMinMax.xy, sampleUVBoundsMinMax.zw);

                float4 samplesDepth = lerp(sampleDepthStartEnd.xxxx, sampleDepthStartEnd.yyyy, samplesStartEndAlpha);

                float4 sampleMoments0 = SampleMomentsFromDepthMomentsMipChain(sampleUV0);
                float4 sampleMoments1 = SampleMomentsFromDepthMomentsMipChain(sampleUV1);
                float4 sampleMoments2 = SampleMomentsFromDepthMomentsMipChain(sampleUV2);
                float4 sampleMoments3 = SampleMomentsFromDepthMomentsMipChain(sampleUV3);

                sampleMoments0 = DecodeMomentsForEvaluation(sampleMoments0, _HVSSSDepthScaleBias, _HVSSSEVSMExponents);
                sampleMoments1 = DecodeMomentsForEvaluation(sampleMoments1, _HVSSSDepthScaleBias, _HVSSSEVSMExponents);
                sampleMoments2 = DecodeMomentsForEvaluation(sampleMoments2, _HVSSSDepthScaleBias, _HVSSSEVSMExponents);
                sampleMoments3 = DecodeMomentsForEvaluation(sampleMoments3, _HVSSSDepthScaleBias, _HVSSSEVSMExponents);

                float sampleShadow0 = ComputeHVSSSRaymarchSampleShadow(samplesDepth.x, sampleMoments0, samplesStartEndAlpha.x, lodCurrent, thicknessScale, _HVSSSDepthScaleBias, _HVSSSEVSMExponents, _HVSSSContrastAndBlackpointAndDitherMode.y);
                sampleShadow0 = ComputeShadowAccumulatorTransform(sampleShadow0, i + 0, sampleCountScale, sampleCountBias.x, centerPositionVS.xyz, samplePositionVSStart, samplePositionVSEnd, samplesStartEndAlpha.x, rayDistancePrevious);
                shadowData = CompositeShadows(shadowData, sampleShadow0);

                float sampleShadow1 = ComputeHVSSSRaymarchSampleShadow(samplesDepth.y, sampleMoments1, samplesStartEndAlpha.y, lodCurrent, thicknessScale, _HVSSSDepthScaleBias, _HVSSSEVSMExponents, _HVSSSContrastAndBlackpointAndDitherMode.y);
                sampleShadow1 = ComputeShadowAccumulatorTransform(sampleShadow1, i + 1, sampleCountScale, sampleCountBias.y, centerPositionVS.xyz, samplePositionVSStart, samplePositionVSEnd, samplesStartEndAlpha.y, rayDistancePrevious);
                shadowData = CompositeShadows(shadowData, sampleShadow1);

                float sampleShadow2 = ComputeHVSSSRaymarchSampleShadow(samplesDepth.z, sampleMoments2, samplesStartEndAlpha.z, lodCurrent, thicknessScale, _HVSSSDepthScaleBias, _HVSSSEVSMExponents, _HVSSSContrastAndBlackpointAndDitherMode.y);
                sampleShadow2 = ComputeShadowAccumulatorTransform(sampleShadow2, i + 2, sampleCountScale, sampleCountBias.z, centerPositionVS.xyz, samplePositionVSStart, samplePositionVSEnd, samplesStartEndAlpha.z, rayDistancePrevious);
                shadowData = CompositeShadows(shadowData, sampleShadow2);
                
                float sampleShadow3 = ComputeHVSSSRaymarchSampleShadow(samplesDepth.w, sampleMoments3, samplesStartEndAlpha.w, lodCurrent, thicknessScale, _HVSSSDepthScaleBias, _HVSSSEVSMExponents, _HVSSSContrastAndBlackpointAndDitherMode.y);
                sampleShadow3 = ComputeShadowAccumulatorTransform(sampleShadow3, i + 3, sampleCountScale, sampleCountBias.w, centerPositionVS.xyz, samplePositionVSStart, samplePositionVSEnd, samplesStartEndAlpha.w, rayDistancePrevious);
                shadowData = CompositeShadows(shadowData, sampleShadow3);
            }
        }

#if defined(SCREEN_EDGE_VIGNETTE_ENABLED)
        float sampleVignetteWeight = ComputeVignetteWeight(centerPositionNDC);
        shadowData = lerp(shadowData, 1.0, sampleVignetteWeight);
#endif

        float4 hvsss = _HVSSSDestinationTexture[COORD_TEXTURE2D_X(hvsssTexelCoord)];

        float hvsssCurrent = ReadChannelDynamicBranch(hvsss, channel);
        hvsssCurrent = (_LODCurrentAndNextAndMax.x == _LODCurrentAndNextAndMax.z) ? 1.0 : hvsssCurrent;
        hvsssCurrent = CompositeShadows(hvsssCurrent, shadowData);
        if (IsFinalBlit(true))
        {
            hvsssCurrent = ComputeContrast(hvsssCurrent);
        }
        hvsss = WriteChannelDynamicBranch(hvsssCurrent, hvsss, channel);

        _HVSSSDestinationTexture[COORD_TEXTURE2D_X(hvsssTexelCoord)] = hvsss;
    }
}

float ComputeGaussianWeight(float sampleDistancePixels, float gaussianRadiusInverseSquared)
{
    // Sharpness of 3.375 is the exp2 equivalent of an exp sharpness of 2.29.
    // 2.29 is from the gaussian fit of a blackman-harris filter, used in TAA resolve.
    // Just a reasonably good gaussian filter for discrete kernels of fairly small sizes.
    const float SHARPNESS = 3.375;
    return exp2(-SHARPNESS * gaussianRadiusInverseSquared * sampleDistancePixels * sampleDistancePixels);
}

float ComputeBilateralDepthSimilarityWeight(float sharpness, float depthA, float depthB, float lodCurrent)
{
    float depthDifference = depthB - depthA;

    // * exp2(-x) == 1.0 / exp2(x)
    return exp2(-sharpness * depthDifference * depthDifference * exp2(-lodCurrent));
}

[numthreads(KERNEL_SIZE, KERNEL_SIZE, 1)]
void SeperableBilateralBlur(uint3 dispatchThreadId : SV_DispatchThreadID)
{
    UNITY_XR_ASSIGN_VIEW_INDEX(dispatchThreadId.z);

    uint2 hvsssTexelCoord = dispatchThreadId.xy;

    uint2 depthLODOffset = _SrcOffsetAndLimit.xy;
    uint2 depthLODLimit  = _SrcOffsetAndLimit.zw;
    uint2 depthLODSize = (depthLODLimit + 1u) - depthLODOffset;
    uint2 depthLODTexelCoord = depthLODOffset + hvsssTexelCoord;

    uint2 hvsssLimit = depthLODLimit - depthLODOffset;

    bool axis = (uint)_LODCurrentAndNextAndMax.w == 1u;

    if (all(hvsssTexelCoord <= hvsssLimit))
    {
        float centerDepth = LoadDepthLinearFromTexelCoord(depthLODTexelCoord, _HVSSSDepthScaleBias, _HVSSSEVSMExponents);

        float4 shadowDataAccumulated = 0.0;
        float weightAccumulated = 0.0;
        int kernelRadius = (int)floor(_HVSSSUpsampleBlurRadiusPixelsAndInverseSquared.x + 0.5);
        for (int i = -kernelRadius; i <= kernelRadius; ++i)
        {
            int2 sampleTexelOffset = axis ? int2(0, i) : int2(i, 0);
            int2 sampleTexelCoord = (int2)hvsssTexelCoord + sampleTexelOffset;
            sampleTexelCoord = clamp(sampleTexelCoord, 0, (int2)hvsssLimit);
            uint2 sampleDepthLODTexelCoord = (uint2)sampleTexelCoord + depthLODOffset;

            float sampleDepth = LoadDepthLinearFromTexelCoord(sampleDepthLODTexelCoord, _HVSSSDepthScaleBias, _HVSSSEVSMExponents);

            float4 shadowData = _HVSSSSourceTexture[COORD_TEXTURE2D_X((uint2)sampleTexelCoord)];

            float weight = (kernelRadius > 1) ? ComputeGaussianWeight((float)i, _HVSSSUpsampleBlurRadiusPixelsAndInverseSquared.y) : 1.0;
            const float BILATERAL_DEPTH_SIMILARITY_SHARPNESS = 100.0;
            weight *= ComputeBilateralDepthSimilarityWeight(BILATERAL_DEPTH_SIMILARITY_SHARPNESS, sampleDepth, centerDepth, (float)_LODCurrentAndNextAndMax.x);
            weight = max(1e-5, weight);
            
            weightAccumulated += weight;
            shadowDataAccumulated += shadowData * weight;
        }
        shadowDataAccumulated *= (weightAccumulated > 1e-5) ? rcp(weightAccumulated) : 0.0;

        _HVSSSDestinationTexture[COORD_TEXTURE2D_X(hvsssTexelCoord)] = shadowDataAccumulated;
    }


}

float ComputeWeightBicubic(float x, float x2, float b, float c)
{
  float x3 = x2 * x;

  return (x < 2.0)
    ? ((x < 1.0)
      ? ((2.0 - 1.5 * b - c) * x3 + (-3.0 + 2.0 * b + c) * x2 + (1.0 - b / 3.0))
      : ((-b / 6.0 - c) * x3 + (b + 5.0 * c) * x2 + (-2.0 * b - 8.0 * c) * x + (4.0 / 3.0 * b + 4.0 * c)))
    : 0.0;
}

[numthreads(KERNEL_SIZE, KERNEL_SIZE, 1)]
void BilateralUpsample(uint3 dispatchThreadId : SV_DispatchThreadID)
{
    UNITY_XR_ASSIGN_VIEW_INDEX(dispatchThreadId.z);

    uint2 hvsssDestinationTexelCoord = dispatchThreadId.xy;

    uint2 depthLODSourceOffset = _SrcOffsetAndLimit.xy;
    uint2 depthLODSourceLimit  = _SrcOffsetAndLimit.zw;
    uint2 depthLODSourceSize = (depthLODSourceLimit + 1u) - depthLODSourceOffset;

    uint2 depthLODDestinationOffset = _DstOffsetAndLimit.xy;
    uint2 depthLODDestinationLimit  = _DstOffsetAndLimit.zw;
    uint2 depthLODDestinationSize = (depthLODDestinationLimit + 1u) - depthLODDestinationOffset;

    uint2 depthLODDestinationTexelCoord = depthLODDestinationOffset + hvsssDestinationTexelCoord;
    
    uint2 hvsssDestinationLimit = depthLODDestinationLimit - depthLODDestinationOffset;

    if (all(hvsssDestinationTexelCoord <= hvsssDestinationLimit))
    {
#if defined(HIGH_QUALITY_UPSAMPLE_ENABLED)
        float2 centerDestinationPixel = hvsssDestinationTexelCoord + float2(0.5, 0.5);
        float2 centerSourcePixel = centerDestinationPixel * 0.5;
        uint2 centerDepthLODTexelCoord = depthLODDestinationOffset + hvsssDestinationTexelCoord;
        uint2 hvsssSourceLimit = depthLODSourceLimit - depthLODSourceOffset;
        float4 shadowDataAccumulated = 0.0;
        float weightAccumulated = 0.0;

        float centerDepth = LoadDepthLinearFromTexelCoord(min(centerDepthLODTexelCoord + uint2(0u, 0u), depthLODDestinationLimit), _HVSSSDepthScaleBias, _HVSSSEVSMExponents);

        for (int x = -2; x < 2; ++x)
        {
            for (int y = -2; y < 2; ++y)
            {
                float2 sampleSourcePixel = centerSourcePixel + float2(x, y) + 0.5;
                sampleSourcePixel = clamp(sampleSourcePixel, 0.5, (depthLODDestinationLimit - depthLODDestinationOffset) + 0.5);
                float2 sampleKernelOffset = sampleSourcePixel - centerSourcePixel;
                float weight = ComputeWeightBicubic(length(sampleKernelOffset), dot(sampleKernelOffset, sampleKernelOffset), 3.0 / 3.0, 0.0 / 3.0);
                uint2 sampleDepthLODSourceTexelCoord = (uint2)floor(sampleSourcePixel) + depthLODDestinationOffset;
                sampleDepthLODSourceTexelCoord = min(sampleDepthLODSourceTexelCoord, depthLODDestinationLimit);

                float sampleDepth = LoadDepthLinearFromTexelCoord(sampleDepthLODSourceTexelCoord, _HVSSSDepthScaleBias, _HVSSSEVSMExponents);

                const float SHARPNESS_DEPTH_COMPARE = 0.5;
                weight *= ComputeBilateralDepthSimilarityWeight(SHARPNESS_DEPTH_COMPARE, sampleDepth, centerDepth, (float)_LODCurrentAndNextAndMax.y);

                weight = max(1e-4, weight);

                weightAccumulated += weight;
                shadowDataAccumulated += weight * _HVSSSSourceTexture[COORD_TEXTURE2D_X(min((uint2)floor(sampleSourcePixel), hvsssSourceLimit))];
            }
        }
        float weightAccumulatedNormalization = (weightAccumulated > 1e-5) ? rcp(weightAccumulated) : 0.0;
        shadowDataAccumulated *= weightAccumulatedNormalization;

#else
        uint2 hvsssSourceTexelCoordUL = hvsssDestinationTexelCoord >> 1;
        uint2 sampleDepthLODTexelCoordUL = depthLODSourceOffset + hvsssSourceTexelCoordUL;
        uint2 centerDepthLODTexelCoord = depthLODDestinationOffset + hvsssDestinationTexelCoord;

        float centerDepth = LoadDepthLinearFromTexelCoord(min(centerDepthLODTexelCoord + uint2(0u, 0u), depthLODDestinationLimit),  _HVSSSDepthScaleBias, _HVSSSEVSMExponents);

        float sampleDepth00 = LoadDepthLinearFromTexelCoord(min(sampleDepthLODTexelCoordUL + uint2(0u, 0u), depthLODSourceLimit), _HVSSSDepthScaleBias, _HVSSSEVSMExponents);
        float sampleDepth10 = LoadDepthLinearFromTexelCoord(min(sampleDepthLODTexelCoordUL + uint2(1u, 0u), depthLODSourceLimit), _HVSSSDepthScaleBias, _HVSSSEVSMExponents);
        float sampleDepth01 = LoadDepthLinearFromTexelCoord(min(sampleDepthLODTexelCoordUL + uint2(0u, 1u), depthLODSourceLimit), _HVSSSDepthScaleBias, _HVSSSEVSMExponents);
        float sampleDepth11 = LoadDepthLinearFromTexelCoord(min(sampleDepthLODTexelCoordUL + uint2(1u, 1u), depthLODSourceLimit), _HVSSSDepthScaleBias, _HVSSSEVSMExponents);

        const float SHARPNESS = 100.0;
        float weight00 = ComputeBilateralDepthSimilarityWeight(SHARPNESS, sampleDepth00, centerDepth, (float)_LODCurrentAndNextAndMax.y);
        float weight10 = ComputeBilateralDepthSimilarityWeight(SHARPNESS, sampleDepth10, centerDepth, (float)_LODCurrentAndNextAndMax.y);
        float weight01 = ComputeBilateralDepthSimilarityWeight(SHARPNESS, sampleDepth01, centerDepth, (float)_LODCurrentAndNextAndMax.y);
        float weight11 = ComputeBilateralDepthSimilarityWeight(SHARPNESS, sampleDepth11, centerDepth, (float)_LODCurrentAndNextAndMax.y);

        weight00 = max(1e-4, weight00);
        weight10 = max(1e-4, weight10);
        weight01 = max(1e-4, weight01);
        weight11 = max(1e-4, weight11);

        float weightAccumulated = weight00 + weight10 + weight01 + weight11;
        
        const float BILATERAL_WEIGHT_THRESHOLD = 1e-2;
        weight00 = (weightAccumulated > BILATERAL_WEIGHT_THRESHOLD) ? weight00 : 0.25;
        weight10 = (weightAccumulated > BILATERAL_WEIGHT_THRESHOLD) ? weight10 : 0.25;
        weight01 = (weightAccumulated > BILATERAL_WEIGHT_THRESHOLD) ? weight01 : 0.25;
        weight11 = (weightAccumulated > BILATERAL_WEIGHT_THRESHOLD) ? weight11 : 0.25;
        weightAccumulated = (weightAccumulated > BILATERAL_WEIGHT_THRESHOLD) ? weightAccumulated : 1.0;

        float weightNormalization = rcp(weightAccumulated);

        uint2 hvsssSourceLimit = depthLODSourceLimit - depthLODSourceOffset;
        float4 shadowDataAccumulated = 0.0;
        shadowDataAccumulated += weight00 * _HVSSSSourceTexture[COORD_TEXTURE2D_X(min(hvsssSourceTexelCoordUL + uint2(0u, 0u), hvsssSourceLimit))];
        shadowDataAccumulated += weight10 * _HVSSSSourceTexture[COORD_TEXTURE2D_X(min(hvsssSourceTexelCoordUL + uint2(1u, 0u), hvsssSourceLimit))];
        shadowDataAccumulated += weight01 * _HVSSSSourceTexture[COORD_TEXTURE2D_X(min(hvsssSourceTexelCoordUL + uint2(0u, 1u), hvsssSourceLimit))];
        shadowDataAccumulated += weight11 * _HVSSSSourceTexture[COORD_TEXTURE2D_X(min(hvsssSourceTexelCoordUL + uint2(1u, 1u), hvsssSourceLimit))];
        shadowDataAccumulated *= weightNormalization;
#endif

        if (IsFinalBlit(false))
        {
            shadowDataAccumulated = ComputeContrast(shadowDataAccumulated);
        }

        _HVSSSDestinationTexture[COORD_TEXTURE2D_X(hvsssDestinationTexelCoord)] = shadowDataAccumulated;
    }
}
