#ifdef SURFACE_GRADIENT
#undef SURFACE_GRADIENT
#endif
#ifdef DECAL_SURFACE_GRADIENT
#undef DECAL_SURFACE_GRADIENT
#endif

#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/TextureXR.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Visibility/VisibilityOITResources.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/PostProcessing/Shaders/PostProcessDefines.hlsl"

#define VARIANT_DIR_PUNCTUAL_AREA_ENV 1
#define HAS_LIGHTLOOP

#define DISABLE_APPLY_DEBUG_TO_LIGHTING

#define SHADERPASS SHADERPASS_VBUFFER_LIGHTING_OFFSCREEN

#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/LitProperties.hlsl"

#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/Lighting.hlsl"

#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/ShaderPass/LitDepthPass.hlsl"

#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoopDef.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoop.hlsl"

#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/LitData.hlsl"

#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/CommonLighting.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/EntityLighting.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Sky/SkyUtils.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/SDF2D.hlsl"

#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariablesFunctions.hlsl"

//#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/HDShadow.hlsl"
//#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoopDef.hlsl"
//#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/PunctualLightCommon.hlsl"
//#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoop.cs.hlsl"
//#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Builtin/BuiltinData.hlsl"
//#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoop.hlsl"

#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Visibility/VisibilityOITResources.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Visibility/VBufferDeferredMaterialCommon.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Visibility/BTDF.hlsl"

#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Random.hlsl" // TODO: replace with blue noise helper and scramble textures
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Visibility/BTDF.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/ImageBasedLighting.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/RaytracingSampling.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/RayTracingCommon.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariablesGlobal.cs.hlsl"

//#pragma enable_d3d11_debug_symbols
#pragma only_renderers d3d11 playstation xboxone xboxseries vulkan metal switch

#pragma kernel MainResolveOffscreenLighting

#define GROUP_SIZE 8

#if UNITY_REVERSED_Z
# define MIN_DEPTH(a, b) max(a, b)
#else
# define MIN_DEPTH(a, b) min(a, b)
#endif

TEXTURE2D_X(_DepthTexture);
RW_TEXTURE2D_X(float4, _OutputTexture);

float4 _VBufferLightingOffscreenParams;
int _OITHiZMaxMip;
StructuredBuffer<int2> _DepthPyramidMipLevelOffsets;

uint GetOffscreenLightBufferWidth()
{
    return asuint(_VBufferLightingOffscreenParams.x);
}

BuiltinData GetBuiltinData(float3 normal, float roughness, float3 diffuseAlbedo)
{
    BuiltinData builtinData;
    ZERO_INITIALIZE(BuiltinData, builtinData);

    //builtinData.opacity = 0.5f;
//    real alphaClipTreshold;
//    real3 bakeDiffuseLighting;
//    real3 backBakeDiffuseLighting;
    builtinData.shadowMask0 = 1.0f;
    builtinData.shadowMask1 = 1.0f;
    builtinData.shadowMask2 = 1.0f;
    builtinData.shadowMask3 = 1.0f;
    builtinData.emissiveColor = 0.0f;
//    real2 motionVector;
//    real2 distortion;
//    real distortionBlur;
//    uint isLightmap;
//    uint renderingLayers;
//    float depthOffset;
//#if defined(UNITY_VIRTUAL_TEXTURING)
//    real4 vtPackedFeedback;
//#endif

    return builtinData;
}

SurfaceData GetSurfaceData(float3 normal, float roughness, float3 diffuseAlbedo)
{
    SurfaceData surfaceData;
    ZERO_INITIALIZE(SurfaceData, surfaceData);

    //uint materialFeatures;
    surfaceData.baseColor = diffuseAlbedo;
    surfaceData.specularOcclusion = 1.0f;
    surfaceData.normalWS = normal;
    surfaceData.perceptualSmoothness = RoughnessToPerceptualSmoothness(roughness);
    surfaceData.ambientOcclusion = 1.0f;
    surfaceData.metallic = 0.0f;
    //real coatMask;
    surfaceData.specularColor = DEFAULT_SPECULAR_VALUE;
    //uint diffusionProfileHash;
    //real subsurfaceMask;
    //real thickness;
    //float3 tangentWS;
    //real anisotropy;
    //real iridescenceThickness;
    //real iridescenceMask;
    //real3 geomNormalWS;
    //real ior;
    //real3 transmittanceColor;
    //real atDistance;
    //real transmittanceMask;

    return surfaceData;
}

BSDFData GetBSDFData(float3 normal, float roughness, float3 diffuseAlbedo)
{
    BSDFData outBSDF;
    ZERO_INITIALIZE(BSDFData, outBSDF);

    outBSDF.materialFeatures = MATERIALFEATUREFLAGS_LIT_STANDARD | MATERIALFEATUREFLAGS_LIT_TRANSMISSION | MATERIALFEATUREFLAGS_LIT_SPECULAR_COLOR;
    outBSDF.diffuseColor = diffuseAlbedo;
    outBSDF.fresnel0 = DEFAULT_SPECULAR_VALUE;
    outBSDF.ambientOcclusion = 1.0f;
    outBSDF.specularOcclusion = 1.0f;
    outBSDF.normalWS = normal;
    outBSDF.perceptualRoughness = RoughnessToPerceptualRoughness(roughness);
    //real coatMask;
    //uint diffusionProfileIndex;
    //real subsurfaceMask;
    //real thickness;
    //bool useThickObjectMode;
    //real3 transmittance;
    //float3 tangentWS;
    //float3 bitangentWS;
    //real roughnessT;
    //real roughnessB;
    //real anisotropy;
    //real iridescenceThickness;
    //real iridescenceMask;
    //real coatRoughness;
    outBSDF.geomNormalWS = normal;
    //real ior;
    //real3 absorptionCoefficient;
    //real transmittanceMask;

    return outBSDF;
}

// Weight for SSR where Fresnel == 1 (returns value/pdf)
float GetSSRSampleWeight(float3 V, float3 L, float roughness)
{
    // Simplification:
    // value = D_GGX / (lambdaVPlusOne + lambdaL);
    // pdf = D_GGX / lambdaVPlusOne;

    const float lambdaVPlusOne = Lambda_GGX(roughness, V) + 1.0;
    const float lambdaL = Lambda_GGX(roughness, L);

    return lambdaVPlusOne / (lambdaVPlusOne + lambdaL);
}

#define SSR_TRACE_EPS               0.000488281f // 2^-11, should be good up to 4K
#define MIN_GGX_ROUGHNESS           0.00001f
#define MAX_GGX_ROUGHNESS           0.99999f

// Specialization without Fresnel (see PathTracingBSDF.hlsl for the reference implementation)
bool SampleGGX_VNDF(float roughness_,
    float3x3 localToWorld,
    float3 V,
    float2 inputSample,
    out float3 outgoingDir,
    out float weight)
{
    weight = 0.0f;

    float roughness = clamp(roughness_, MIN_GGX_ROUGHNESS, MAX_GGX_ROUGHNESS);

    float VdotH;
    float3 localV, localH;
    SampleGGXVisibleNormal(inputSample.xy, V, localToWorld, roughness, localV, localH, VdotH);

    // Compute the reflection direction
    float3 localL = 2.0 * VdotH * localH - localV;
    outgoingDir = mul(localL, localToWorld);

    if (localL.z < 0.001)
    {
        return false;
    }

    weight = GetSSRSampleWeight(localV, localL, roughness);

    if (weight < 0.001)
        return false;

    return true;
}

[numthreads(GROUP_SIZE, GROUP_SIZE, 1)]
void MainResolveOffscreenLighting(int3 dispatchThreadId : SV_DispatchThreadID)
{
    UNITY_XR_ASSIGN_VIEW_INDEX(dispatchThreadId.z);
    if (any((float2)dispatchThreadId.xy > _ScreenSize.xy))
        return;

    PositionInputs posInputRaw = GetPositionInput(float2(dispatchThreadId.xy), _ScreenSize.zw, uint2(GROUP_SIZE, GROUP_SIZE));

    uint pixelOffset = posInputRaw.positionSS.y * _ScreenSize.x + posInputRaw.positionSS.x;
    uint listCount, listOffset;
    VisibilityOIT::GetPixelList(pixelOffset, listCount, listOffset);
    if (listCount == 0)
        return;

    float foundDepth = 0.0;
    uint foundSampleIdx = -1;
    uint a = 0;
    {
        int globalOffset = a + listOffset;
        uint2 offscreenCoord = uint2(globalOffset % GetOffscreenLightBufferWidth(), globalOffset / GetOffscreenLightBufferWidth());

        Visibility::VisibilityData unusedVisData;
        uint2 unusedTexelCoord;
        float depthValue;
        VisibilityOIT::GetVisibilitySample(a, listOffset, unusedVisData, unusedTexelCoord, depthValue);

        if (depthValue > foundDepth)
        {
            foundSampleIdx = a;
            foundDepth = depthValue;
            //break;
        }
    }

    float startDeviceDepth = foundDepth;
    float deviceDepth = foundDepth;

    ////for (uint i = 0; i < listCount; ++i)
    //uint i = foundSampleIdx;
    //
    //int globalOffset = foundSampleIdx + listOffset;
    //uint2 offscreenCoord = uint2(globalOffset % GetOffscreenLightBufferWidth(), globalOffset / GetOffscreenLightBufferWidth());
    //
    //float3 lightingSource = _VisOITOffscreenDirectReflectionLighting[COORD_TEXTURE2D_X(offscreenCoord)].rgb;

    int2 tileCoord = (float2)posInputRaw.positionSS.xy / GetTileSize();
    PositionInputs posInput = GetPositionInput(posInputRaw.positionSS.xy, _ScreenSize.zw, deviceDepth, UNITY_MATRIX_I_VP, GetWorldToViewMatrix(), tileCoord);

    //float3 wo = GetWorldSpaceNormalizeViewDir(posInput.positionWS);
    //float3 wo = GetWorldSpaceNormalizeViewDir(positionWS);

    float2 positionNDC = posInputRaw.positionSS.xy * _ScreenSize.zw + (0.5 * _ScreenSize.zw); // Should we precompute the half-texel bias? We seem to use it a lot.
    float3 positionWS = ComputeWorldSpacePosition(positionNDC, deviceDepth, UNITY_MATRIX_I_VP); // Jittered

    float3 camPosWS = GetCurrentViewPosition();

    //float3 wi = -wo;
    //float internalIORSource = 1.0f;
    //float internalIORMedium = Fresnel0ToIor(f0);
    //float internalIORMedium = 1.5f;
    //float3 wi = refract(-wo, n.xyz, internalIORSource / internalIORMedium);
    //float3 wi = refract(-wo, n.xyz, internalIORMedium / internalIORSource);
    //float3 wi = -wo;
    //float3 wi = refract(-wo, n.xyz, 0.95);
    //float3 wi = refract(-wo, n.xyz, 1.25);
    //float3 Incident = -wo;
    //float eta = internalIORSource / internalIORMedium;
    //float cos0 = dot(Incident, n);
    //float kc = 1.0 - eta * eta * (1.0 - cos0 * cos0);
    ////float3 wi = k >= 0.0 ? eta * Incident - (eta * cos0 + sqrt(k)) * n : reflect(Incident, n);
    //float3 wi = kc >= 0.0 ? eta * Incident - (eta * cos0 + sqrt(kc)) * n : -n;
    ////float3 wi;
    //float3 rIntensity = 1.0f;
    //float3 rIntensity = F_Transm_Schlick(IorToFresnel0(internalIORMedium, internalIORSource), -cos0);
    //float3 rIntensity = F_FresnelDielectric(internalIORMedium / internalIORSource, -cos0);
    //float3 wi;
    //float3 rIntensity;
    //BTDF::RefractIntensity(wi, rIntensity, -wo, n, internalIORSource, internalIORMedium);

    //positionWS = camPosWS - (positionWS - camPosWS) * (1.0f - 0.001 * rcp(max(dot(n, wo), FLT_EPS)));
    //positionWS += wi * 0.001f;
    //positionWS -= wi * (1.0f - 0.001 * rcp(max(dot(n, wo), FLT_EPS)));
    //positionWS -= wi * rcp(max(dot(n, wo), FLT_EPS));
    //positionWS -= wi * 0.01f;
    //deviceDepth = ComputeNormalizedDeviceCoordinatesWithZ(positionWS, UNITY_MATRIX_VP).z;

    ////bool killRay = minDepth == UNITY_RAW_FAR_CLIP_VALUE;

    //float3 rayOrigin = float3(posInputRaw.positionSS + 0.5, deviceDepth);

    //float3 reflPosWS = positionWS + wi;
    //float3 reflPosNDC = ComputeNormalizedDeviceCoordinatesWithZ(reflPosWS, UNITY_MATRIX_VP); // Jittered
    //float3 reflPosSS = float3(reflPosNDC.xy * _ScreenSize.xy, reflPosNDC.z);
    //float3 rayDir = reflPosSS - rayOrigin;
    //float3 rcpRayDir = rcp(rayDir);
    //int2   rayStep = int2(rcpRayDir.x >= 0 ? 1 : 0,
    //    rcpRayDir.y >= 0 ? 1 : 0);
    //float3 raySign = float3(rcpRayDir.x >= 0 ? 1 : -1,
    //    rcpRayDir.y >= 0 ? 1 : -1,
    //    rcpRayDir.z >= 0 ? 1 : -1);
    ////bool   rayTowardsEye  =  rcpRayDir.z >= 0;

    int mipLevel = 0;
    //float3 rayPos;

    //// Start ray marching from the next texel to avoid self-intersections.
    //float t;
    //float deltaT;
    //{
    //    // 'rayOrigin' is the exact texel center.
    //    float2 dist = abs(0.5 * rcpRayDir.xy);
    //    deltaT = min(dist.x, dist.y);
    //    t = deltaT;
    //}

    bool hit = false;
    int hitOffset = 0;
    float3 hitNDC = 0;
    int iterFull = 0;

    float3 output = 0.0f;

    //float3 wo_0 = GetWorldSpaceNormalizeViewDir(posInput.positionWS);
    float3 wo_0 = GetWorldSpaceNormalizeViewDir(positionWS);

    float transport = 1.0f;

    float3 wi = -wo_0;
    // Bounce loop
    for (int b = 0; b < 5; ++b)
    {
        //
        int globalOffset_b = foundSampleIdx + listOffset;
        uint2 offscreenCoord_b = uint2(globalOffset_b % GetOffscreenLightBufferWidth(), globalOffset_b / GetOffscreenLightBufferWidth());

        float3 lightingSource = _VisOITOffscreenDirectReflectionLighting[COORD_TEXTURE2D_X(offscreenCoord_b)].rgb;

        // Sample GBuffer
        uint4 packedOITGBuffer0 = _VisOITOffscreenGBuffer0[COORD_TEXTURE2D_X(offscreenCoord_b)].rgba;
        uint packedOITGBuffer1 = _VisOITOffscreenGBuffer1[COORD_TEXTURE2D_X(offscreenCoord_b)].r;
        float3 n;
        float roughness;
        float3 baseColor;
        float metalness;
        VisibilityOIT::UnpackOITGBufferData(packedOITGBuffer0, packedOITGBuffer1, n, roughness, baseColor, metalness);

        //float3 f0 = lerp(DEFAULT_SPECULAR_VALUE, baseColor, metalness);

        const float iorAir = 1.0f;
        const float iorMedium = 1.5f;

        float ni = b % 2 == 0 ? iorAir : iorMedium; // modulo are slow TODO: replace
        float nt = b % 2 == 0 ? iorMedium : iorAir; // modulo are slow TODO: replace

        const float MAX_ImIOR_Kt = 3.5f;
        float eta_k = smoothstep(0.5f, 1.0f, metalness) * MAX_ImIOR_Kt; // Imaginary IOR

        float f0 = (1.0f - (4.0f * ni * nt) / (eta_k * eta_k + Sq(ni + nt)));

        float3 wo = -wi;
        float cos0i = dot(n, wo);
        float sin0i2 = 1.0f - cos0i * cos0i;
        float cos0t2 = 1.0f - (Sq(nt) * sin0i2) / Sq(nt);

        float iorEstimated = iorMedium;

        //float eta = internalIORMedium / internalIORSource;
        //float eta = ni / nt;
        float eta = nt / ni;

        //float Fresnel = F_FresnelDielectric(eta, dot(-n, wi));
        float cos0t = sqrt(cos0t2);
        float mCos = 1.0f - cos0t;
        float mCos2 = mCos * mCos;
        float mCos4 = mCos2 * mCos2;
        float mCos5 = mCos4 * mCos;
        float Fresnel = saturate(f0 + (1.0f - f0) * mCos5);

        float3 specularAlbedo = lerp(DEFAULT_SPECULAR_VALUE, baseColor, Fresnel);

        deviceDepth = ComputeNormalizedDeviceCoordinatesWithZ(positionWS, UNITY_MATRIX_VP).z;

        float3 rayOrigin = float3(posInputRaw.positionSS + 0.5, deviceDepth);

        float3 Xi;
        Xi.x = GetBNDSequenceSample(offscreenCoord_b, _FrameCount, 3 * b + 0);
        Xi.y = GetBNDSequenceSample(offscreenCoord_b, _FrameCount, 3 * b + 1);
        Xi.z = GetBNDSequenceSample(offscreenCoord_b, _FrameCount, 3 * b + 2);

        float weight;
        //float coefBias = 0.1 / roughness;
        //Xi.x = lerp(Xi.x, 0.0f, roughness * coefBias);
        UNITY_BRANCH
        if (Xi.z > Fresnel)
        {
            //wi = reflect(-wo, n);
            float3x3 localToWorld = GetLocalFrame(n);
            float3 dir = wo;
            //float3 wi;// = dir;
            SampleGGX_VNDF(roughness,
                           localToWorld,
                           dir,
                           Xi.xy,
                           wi,
                           weight);
        }
        else
        {
            UNITY_BRANCH
            if (Xi.z > roughness)
            {
                wi = refract(-wo, -n.xyz, 1.0f / eta);
                weight = 1.0f - roughness;
            }
            else
            {
                float3x3 localToWorld = GetLocalFrame(-n);
                //float3 dir = lerp(refract(-wo, n.xyz, eta), -wo, roughness);
                float3 dir = refract(-wo, -n.xyz, 1.0f / eta);
                //float3 dir = -wo;
                //float3 wi;// = dir;
                SampleGGX_VNDF(roughness,
                    localToWorld,
                    dir,
                    Xi.xy,
                    wi,
                    weight);
            }
        }
        //BTDF::GGXSampleWSOmega_w(wo, n, Xi, roughness, wi);
        //wi *= -1;

        //wi = refract(-wo, n.xyz, 0.95);
        //wi = lerp(refract(-wo, n.xyz, 0.95), -wo, roughness);

        float cos0 = dot(wo, n);

        float3 reflPosWS = positionWS + wi;
        float3 reflPosNDC = ComputeNormalizedDeviceCoordinatesWithZ(reflPosWS, UNITY_MATRIX_VP); // Jittered
        float3 reflPosSS = float3(reflPosNDC.xy * _ScreenSize.xy, reflPosNDC.z);
        float3 rayDir = reflPosSS - rayOrigin;
        float3 rcpRayDir = rcp(rayDir);
        int2   rayStep = int2(rcpRayDir.x >= 0 ? 1 : 0,
            rcpRayDir.y >= 0 ? 1 : 0);
        float3 raySign = float3(rcpRayDir.x >= 0 ? 1 : -1,
            rcpRayDir.y >= 0 ? 1 : -1,
            rcpRayDir.z >= 0 ? 1 : -1);

        //positionWS = camPosWS - (positionWS - camPosWS) * (1.0f - 0.001 * rcp(max(dot(n, wo), FLT_EPS)));
        positionWS = camPosWS - (positionWS - camPosWS) * (1.0f - 0.001f * rcp(max(dot(n, wo), FLT_EPS)));
        //positionWS += wi * 0.01f;

        float t;
        float deltaT;
        {
            // 'rayOrigin' is the exact texel center.
            float2 dist = abs(0.5 * rcpRayDir.xy);
            deltaT = min(dist.x, dist.y);
            t = deltaT;
        }

        float3 startWS = positionWS;

        float3 rayPos;
        for (int k = 0; k < 512; ++k)
        {
            //rayPos = rayOrigin + (0.0125f * ((float)k)) * rayDir;
            //rayPos = rayOrigin + (0.01f * ((float)k)) * rayDir;
            //rayPos = rayOrigin + (1003.1f * ((float)k)) * rayDir;
            //rayPos = rayOrigin + (0.001f * ((float)k)) * rayDir;
            //rayPos = rayOrigin + (0.015f * ((float)k)) * rayDir;
            rayPos = rayOrigin + (t)*rayDir;
            //t += deltaT * 0.5f;
            //t += deltaT * 0.0125f;
            t += deltaT * 0.125f;
            //t += 1.0f * min(rayDir.x, rayDir.y);
            //t += deltaT * 10.5;

            // Ray position often ends up on the edge. To determine (and look up) the right cell,
            // we need to bias the position by a small epsilon in the direction of the ray.
        //   float2 sgnEdgeDist = round(rayPos.xy) - rayPos.xy;
        //   float2 satEdgeDist = clamp(raySign.xy * sgnEdgeDist + SSR_TRACE_EPS, 0, SSR_TRACE_EPS);
        //   rayPos.xy += raySign.xy * satEdgeDist;

            int2 mipCoord = (int2)rayPos.xy >> mipLevel;
            int2 mipOffset = _DepthPyramidMipLevelOffsets[mipLevel];

            // Bounds define 4 faces of a cube:
            // 2 walls in front of the ray, and a floor and a base below it.

            float4 bounds;
            bounds.xy = (mipCoord + rayStep) << mipLevel;

            float2 depthBound = LOAD_TEXTURE2D_X(_OITTileHiZ, mipOffset + mipCoord).rg;
            //float currentDepth = LOAD_TEXTURE2D_X(_OITTileHiZ, mipOffset + mipCoord).r;
            //bounds.z = LOAD_TEXTURE2D_X(_OITTileHiZ, mipOffset + mipCoord).r;

            float2 currentNDC_xy = floor(rayPos.xy) * _ScreenSize.zw + (0.5 * _ScreenSize.zw);
            positionWS = ComputeWorldSpacePosition(currentNDC_xy.xy, rayPos.z, UNITY_MATRIX_I_VP);
            float3 currentNDC = ComputeNormalizedDeviceCoordinatesWithZ(positionWS, UNITY_MATRIX_VP);
            float currentDepth = currentNDC.z;

            if (currentDepth > depthBound.g && currentDepth < depthBound.r)
            {
                t += deltaT;
                ++iterFull;
                continue;
            }

            float measureMax = 0.25f;
            //for (int k = listCount - 1; k >= 0; --k)
            for (uint k = 0; k < listCount; ++k)
            {
                //uint pixelOffset_k = floor(rayPos.y) * _ScreenSize.x + floor(rayPos.x);
                uint pixelOffset_k = floor(rayPos.y * _ScreenSize.x + rayPos.x);
                uint listCount_k, listOffset_k;
                VisibilityOIT::GetPixelList(pixelOffset_k, listCount_k, listOffset_k);

                int globalOffset_k = k + listOffset_k;
                uint2 offscreenCoord_k = uint2(globalOffset_k % GetOffscreenLightBufferWidth(), globalOffset_k / GetOffscreenLightBufferWidth());

                Visibility::VisibilityData unusedVisData_k;
                uint2 unusedTexelCoord_k;
                float depthValue_k;
                VisibilityOIT::GetVisibilitySample(k, listOffset_k, unusedVisData_k, unusedTexelCoord_k, depthValue_k);

                ++iterFull;
                if (currentDepth < depthValue_k)
                {
                    float3 currentWS = ComputeWorldSpacePosition(currentNDC.xy, depthValue_k, UNITY_MATRIX_I_VP);
                    float3 toSrc = normalize(positionWS - currentWS);
                    float measure = dot(-wi, toSrc);
                    if (measure > measureMax)
                    {
                        //hit = true;
                        hitOffset = k;
                        hitNDC = float3(currentNDC.xy, depthValue_k);
                        //hitNDC.xy = floor(rayPos.xy) * _ScreenSize.zw + (0.5 * _ScreenSize.zw);
                        hitNDC.xy = rayPos.xy * _ScreenSize.zw + (0.5 * _ScreenSize.zw);
                        //hitNDC.z = depthValue_k;
                        measureMax = measure;
                        //break;
                    }
                }
                //else
                //{
                //    break;
                //}
            }

            hit = measureMax > 0.95f;

            ++iterFull;
            if (hit)
                break;
        }

        if (!hit)
        {
            transport *= 0.0f;
            break;
        }

        float2 currentNDC_xy = floor(rayPos.xy) * _ScreenSize.zw + (0.5 * _ScreenSize.zw);
        float3 endWS = ComputeWorldSpacePosition(currentNDC_xy.xy, rayPos.z, UNITY_MATRIX_I_VP);

        float distance = length(startWS - endWS);
        const float distColor = 1000.0f;
        float3 sigma = -log2(baseColor) / distColor;

        float3 absorption = exp2(-sigma * distance);

        transport *= max(absorption.r, max(absorption.g, absorption.b)) * max(1.0f - Fresnel, 0.0f);

        float2 remap = round(hitNDC.xy * _ScreenSize.xy);
        uint pixelOffset_k = remap.y * _ScreenSize.x + remap.x;
        uint listCount_k, listOffset_k;
        VisibilityOIT::GetPixelList(pixelOffset_k, listCount_k, listOffset_k);

        int globalOffset_k = hitOffset + listOffset_k;
        uint2 offscreenCoord_k = uint2(globalOffset_k % GetOffscreenLightBufferWidth(), globalOffset_k / GetOffscreenLightBufferWidth());

        float3 outRes = _VisOITOffscreenDirectReflectionLighting[COORD_TEXTURE2D_X(offscreenCoord_k)].rgb;

        output += Fresnel * lightingSource + (1.0f - Fresnel) * outRes * absorption;
        //output += lightingSource;

        if (transport < 0.01f)
            break;
    }


    float3 fineRefraction = float3(0, 0, 0);
    if (hit)
    {
        //uint pixelOffset_k = rayPos.y * _ScreenSize.x + rayPos.x;
        //float2 remap = round(hitNDC.xy * _ScreenSize.xy);
        //uint pixelOffset_k = remap.y  * _ScreenSize.x + remap.x;
        //uint listCount_k, listOffset_k;
        //VisibilityOIT::GetPixelList(pixelOffset_k, listCount_k, listOffset_k);
        //
        //int globalOffset_k = hitOffset + listOffset_k;
        //uint2 offscreenCoord_k = uint2(globalOffset_k % GetOffscreenLightBufferWidth(), globalOffset_k / GetOffscreenLightBufferWidth());
        //
        //float3 outRes = _VisOITOffscreenDirectReflectionLighting[COORD_TEXTURE2D_X(offscreenCoord_k)].rgb;

        //_OutputTexture[COORD_TEXTURE2D_X(posInputRaw.positionSS.xy)] = float4((1.0f - rIntensity) * lightingSource + (rIntensity) * outRes, 1.0);
        //_OutputTexture[COORD_TEXTURE2D_X(posInputRaw.positionSS.xy)] = float4(output, 1.0);
        //_OutputTexture[COORD_TEXTURE2D_X(posInputRaw.positionSS.xy)] = float4(0.0f, ((float)iterFull)/512.0f, 0.0, 1.0);
        fineRefraction = output;
    }
    else
    {
        //_OutputTexture[COORD_TEXTURE2D_X(posInputRaw.positionSS.xy)] = float4(((float)iterFull) / 512.0f, 0.0, 0.0, 1.0);
        //_OutputTexture[COORD_TEXTURE2D_X(posInputRaw.positionSS.xy)] = float4(1.0f, 0.0, 0.0, 1.0);
        //_OutputTexture[COORD_TEXTURE2D_X(posInputRaw.positionSS.xy)] = float4(output, 1.0);
        fineRefraction = output;
    }

    float3 coarseRefraction = float3(0,0,0);
    {
        float4 radianceVal = float4(0,0,0,0);
        for (uint a = 0; a < listCount; ++a)
        {
            int gOffset = a + listOffset;
            uint2 offscreenCoord = uint2(gOffset % GetOffscreenLightBufferWidth(), gOffset / GetOffscreenLightBufferWidth());
            float4 radSample = _VisOITOffscreenPhotonRadianceLighting[COORD_TEXTURE2D_X(offscreenCoord)];
            radianceVal += float4(radSample.xyz, radSample.a);
        }

        //float4 radianceVal = float4(0,0,0,0);
        //{
        //    uint2 offscreenCoord = uint2(listOffset % GetOffscreenLightBufferWidth(), listOffset / GetOffscreenLightBufferWidth());
        //    radianceVal = _VisOITOffscreenPhotonRadianceLighting[COORD_TEXTURE2D_X(offscreenCoord)];
        //}

        coarseRefraction = radianceVal.xyz / radianceVal.a;
    }
    _OutputTexture[COORD_TEXTURE2D_X(posInputRaw.positionSS.xy)] = float4(lerp(coarseRefraction, fineRefraction, 0.4), 1.0);
}
