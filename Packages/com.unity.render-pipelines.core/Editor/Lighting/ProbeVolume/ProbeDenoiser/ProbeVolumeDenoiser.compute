#pragma kernel PopulateCache
#pragma kernel EstimateVariance
#pragma kernel KernelFilter

#pragma only_renderers d3d11 playstation xboxone xboxseries vulkan metal switch

#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/CommonLighting.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/EntityLighting.hlsl"

#include "Packages/com.unity.render-pipelines.core/Runtime/Lighting/ProbeVolume/ProbeVolume.hlsl" 
#include "Packages/com.unity.render-pipelines.core/Editor/Lighting/ProbeVolume/RawSphericalHarmonicsL2.cs.hlsl"

CBUFFER_START(APVDilation)
    float4                          _CacheLowerBound;
    float4                          _CacheDims;
    float                           _ProbeDelta;
    int                             _NumCachedProbes;
    int                             _NumOutputProbes;
    int                             _KernelFilterType;
    int                             _N;
    float4                          _NLMParams;
    float4                          _FineTuneParams;
    int                             _DebugFlags;
CBUFFER_END

StructuredBuffer<float3>            _ProbePositionsBuffer;
RWStructuredBuffer<float3>          _CachedCoeffs;
RWStructuredBuffer<float3>          _CachedCoeffsVar;
RWStructuredBuffer<int>             _CachedValidities;
RWStructuredBuffer<RawSphericalHarmonicsL2> _OutputCoeffs;

#define kFltMax             3.402823466e+38f
#define kZero               float3(0.0f, 0.0f, 0.0f)
#define kOne                float3(1.0f, 1.0f, 1.0f)
#define sqr(x)              ((x)*(x))
#define cwiseMax(v)         max(v.x, max(v.y, v.z))

#define kSHCoeffsPerProbe   9
#define kInvalidOffset      -1

// Kernel filter types
#define kFilterBox          0
#define kFilterEpanechnikov 1
#define kFilterNLM          2

// Debug flags
#define kIsDebugMode        ((_DebugFlags & 1) != 0)
#define kIsIsolatedCell     ((_DebugFlags & 2) != 0)
#define kShowInvalidProbes  ((_DebugFlags & 4) != 0)

#define kSHTexture3DSampler s_linear_clamp_sampler
//#define kSHTexture3DSampler s_point_clamp_sampler

#define kSamplerBias _FineTuneParams.x
#define kWeightThresholdEpsilon 1e-10
#define kNLMDistanceEpsilon float3(1e-10f, 1e-10f, 1e-10f)

uint __GetIndexData(APVResources apvRes, float3 posWS, out int diag)
{
    diag = 0;

    float3 entryPos = floor(posWS / _GlobalIndirectionEntryDim);
    float3 topLeftEntryWS = entryPos * _GlobalIndirectionEntryDim;

    bool isALoadedCell = all(entryPos >= _MinLoadedCellInEntries && entryPos <= _MaxLoadedCellInEntries);

    // Make sure we start from 0
    int3 entryPosInt = (int3)(entryPos - _MinEntryPosition);

    int flatIdx = dot(entryPosInt, int3(1, (int)_GlobalIndirectionDimension.x, ((int)_GlobalIndirectionDimension.x * (int)_GlobalIndirectionDimension.y)));

    int stepSize = 0;
    int3 minRelativeIdx, maxRelativeIdx;
    int chunkIdx = -1;
    bool isValidBrick = true;
    int locationInPhysicalBuffer = 0;

    if (isALoadedCell && LoadCellIndexMetaData(flatIdx, chunkIdx, stepSize, minRelativeIdx, maxRelativeIdx))
    {
        float3 residualPosWS = posWS - topLeftEntryWS;
        int3 localBrickIndex = floor(residualPosWS / (_MinBrickSize * stepSize));

        // Out of bounds.
        if (!all(localBrickIndex >= minRelativeIdx && localBrickIndex < maxRelativeIdx))
        {
            isValidBrick = false;
        }

        int3 sizeOfValid = maxRelativeIdx - minRelativeIdx;
        // Relative to valid region
        int3 localRelativeIndexLoc = (localBrickIndex - minRelativeIdx);
        int flattenedLocationInCell = dot(localRelativeIndexLoc, int3(sizeOfValid.y, 1, sizeOfValid.x * sizeOfValid.y));

        locationInPhysicalBuffer = chunkIdx * (int)_IndexChunkSize + flattenedLocationInCell;

    }
    else
    {
        isValidBrick = false;
    }

    if (isValidBrick && apvRes.index[locationInPhysicalBuffer] == -1) diag = 1;

    return isValidBrick ? apvRes.index[locationInPhysicalBuffer] : 0xffffffff;
}

bool __TryToGetPoolUVWAndSubdiv(APVResources apvRes, float3 posWSForSample, out float3 uvw, out uint subdiv, out int diag)
{
    // resolve the index
    uint packed_pool_idx = __GetIndexData(apvRes, posWSForSample.xyz, diag);

    //if (packed_pool_idx == 0xffffffff) diag = 1;

    // unpack pool idx
    // size is encoded in the upper 4 bits
    subdiv = (packed_pool_idx >> 28) & 15;
    float  cellSize = pow(3.0, subdiv);

    float   flattened_pool_idx = packed_pool_idx & ((1 << 28) - 1);
    float3 pool_idx;
    pool_idx.z = floor(flattened_pool_idx * _RcpPoolDimXY);
    flattened_pool_idx -= (pool_idx.z * (_PoolDim.x * _PoolDim.y));
    pool_idx.y = floor(flattened_pool_idx * _RcpPoolDim.x);
    pool_idx.x = floor(flattened_pool_idx - (pool_idx.y * _PoolDim.x));

    // calculate uv offset and scale
    float3 posRS = posWSForSample.xyz / _MinBrickSize;
    float3 offset = frac(posRS / (float)cellSize);  // [0;1] in brick space
    //offset    = clamp( offset, 0.25, 0.75 );      // [0.25;0.75] in brick space (is this actually necessary?)

    uvw = (pool_idx + 0.5 + (3.0 * offset)) * _RcpPoolDim; // add offset with brick footprint converted to text footprint in pool texel space

    // no valid brick loaded for this index, fallback to ambient probe
    // Note: we could instead early return when we know we'll have invalid UVs, but some bade code gen on Vulkan generates shader warnings if we do.
    return packed_pool_idx != 0xffffffffu;
}

bool __TryToGetPoolUVWAndSubdiv(APVResources apvRes, float3 posWS, float3 normalWS, float3 viewDirWS, out float3 uvw, out uint subdiv, out float3 biasedPosWS, out int diag)
{
    biasedPosWS = (posWS + normalWS * _NormalBias) + viewDirWS * _ViewBias;
    return __TryToGetPoolUVWAndSubdiv(apvRes, biasedPosWS, uvw, subdiv, diag);
}

bool __TryToGetPoolUVW(APVResources apvRes, float3 posWS, float3 normalWS, float3 viewDir, out float3 uvw, out int diag)
{
    uint unusedSubdiv;
    float3 unusedPos;
    return __TryToGetPoolUVWAndSubdiv(apvRes, posWS, normalWS, viewDir, uvw, unusedSubdiv, unusedPos, diag);
}


void SampleProbeVolume(APVResources ctx, float3 uvw, int idx, float3 cacheAlpha)
{
    float4 L0_L1Rx = SAMPLE_TEXTURE3D_LOD(ctx.L0_L1Rx, kSHTexture3DSampler, uvw, 0).rgba;
    float4 L1G_L1Ry = SAMPLE_TEXTURE3D_LOD(ctx.L1G_L1Ry, kSHTexture3DSampler, uvw, 0).rgba;
    float4 L1B_L1Rz = SAMPLE_TEXTURE3D_LOD(ctx.L1B_L1Rz, kSHTexture3DSampler, uvw, 0).rgba;

    float4 l2_R = SAMPLE_TEXTURE3D_LOD(ctx.L2_0, kSHTexture3DSampler, uvw, 0).rgba;
    float4 l2_G = SAMPLE_TEXTURE3D_LOD(ctx.L2_1, kSHTexture3DSampler, uvw, 0).rgba;
    float4 l2_B = SAMPLE_TEXTURE3D_LOD(ctx.L2_2, kSHTexture3DSampler, uvw, 0).rgba;
    float4 l2_C = SAMPLE_TEXTURE3D_LOD(ctx.L2_3, kSHTexture3DSampler, uvw, 0).rgba;

    float validity = SAMPLE_TEXTURE3D_LOD(ctx.Validity, s_point_clamp_sampler, uvw, 0).r;
    //V = l2_c.w;

    int probeOffset = idx * kSHCoeffsPerProbe;
    _CachedCoeffs[probeOffset] = L0_L1Rx.xyz;

    _CachedCoeffs[probeOffset + 1] = float3(L0_L1Rx.w, L1G_L1Ry.x, L1B_L1Rz.x);
    _CachedCoeffs[probeOffset + 2] = float3(L1G_L1Ry.w, L1G_L1Ry.y, L1B_L1Rz.y);
    _CachedCoeffs[probeOffset + 3] = float3(L1B_L1Rz.w, L1G_L1Ry.z, L1B_L1Rz.z);

    _CachedCoeffs[probeOffset + 4] = float3(l2_R.x, l2_G.x, l2_B.x);
    _CachedCoeffs[probeOffset + 5] = float3(l2_R.y, l2_G.y, l2_B.y);
    _CachedCoeffs[probeOffset + 6] = float3(l2_R.z, l2_G.z, l2_B.z);
    _CachedCoeffs[probeOffset + 7] = float3(l2_R.w, l2_G.w, l2_B.w);
    _CachedCoeffs[probeOffset + 8] = float3(l2_C.x, l2_C.y, l2_C.z);

    /*float3 val = ((length(cacheAlpha) < 2.0) ? kOne : kZero) * 2.;
    _CachedCoeffs[probeOffset] = val;
    _CachedCoeffs[probeOffset + 1] = val;
    _CachedCoeffs[probeOffset + 2] = val;
    _CachedCoeffs[probeOffset + 3] = val;
    _CachedCoeffs[probeOffset + 4] = val;
    _CachedCoeffs[probeOffset + 5] = val;
    _CachedCoeffs[probeOffset + 6] = val;
    _CachedCoeffs[probeOffset + 7] = val;
    _CachedCoeffs[probeOffset + 8] = val;*/

    _CachedValidities[idx] = int(validity * 255.f) & 0xff;
  
     /*for (int i = 0; i < kSHCoeffsPerProbe; ++i)
     {
         _CachedCoeffs[coeffIdx + i] *= 0.;// = cacheAlpha * 5.;
     }
     _CachedCoeffs[coeffIdx] = cacheAlpha * 5.;*/
}

[numthreads(64, 1, 1)]
void PopulateCache(uint3 id : SV_DispatchThreadID)
{
    if (id.x < uint(_NumCachedProbes))
    {
        int3 cacheDims = int3(_CacheDims.xyz);
        int3 probeIdx = int3(id.x % cacheDims.x, (id.x / cacheDims.x) % cacheDims.y, id.x / (cacheDims.x * cacheDims.y));
        float3 samplePos = _CacheLowerBound.xyz + (float3(probeIdx) - kOne * kSamplerBias) * _ProbeDelta;

        float3 sampleUVW;
        APVResources ctx = FillAPVResources();
        int diag = 0;
        if (__TryToGetPoolUVW(ctx, samplePos, 0, 0, sampleUVW, diag))
        {
            //float3 cacheAlpha = 1.f * (samplePos * 0.5f + float3(0.5f, 0.5f, 0.5f));
            float3 cacheAlpha = samplePos;// float3(probeIdx)*_ProbeDelta / _CacheDims.xyz;
            SampleProbeVolume(ctx, sampleUVW, id.x, cacheAlpha);
        }

        if(diag == 1 && kShowInvalidProbes)
        {
            _CachedCoeffs[id.x * kSHCoeffsPerProbe] = float3(1.f, 0.f, 0.f) * 100.;
        }
    }
}

int3 GetCachedIdxFromProbePos(uint3 id : SV_DispatchThreadID)
{
    float3 probePos = _ProbePositionsBuffer[id.x];
    return int3((probePos - _CacheLowerBound.xyz + kOne * kSamplerBias) / _ProbeDelta);
}

int GetProbeOffsetFromIdx(int3 pIdx)
{
    return  pIdx.z * int(_CacheDims.x) * int(_CacheDims.y) + pIdx.y * int(_CacheDims.x) + pIdx.x;
}

bool IntersectsCache(int3 pIdx)
{
    return all(pIdx >= 0) && all(pIdx < int3(_CacheDims.xyz));
}

bool IsValidProbe(int offset)
{
    return (_CachedValidities[offset] & 1) != 0;
}

/*bool IsValidProbe(int3 pIdx)
{
    return IsValidProbe(pIdx.z * int(_CacheDims.x) * int(_CacheDims.y) + pIdx.y * int(_CacheDims.x) + pIdx.x);
}*/

int GetProbeSHOffset(int3 pIdx)
{
    return IntersectsCache(pIdx) ? (kSHCoeffsPerProbe * GetProbeOffsetFromIdx(pIdx)) : kInvalidOffset;
}

int GetValidProbeSHOffset(int3 pIdx)
{
    if (IntersectsCache(pIdx))
    {
        int offset = pIdx.z * int(_CacheDims.x) * int(_CacheDims.y) + pIdx.y * int(_CacheDims.x) + pIdx.x;
        return IsValidProbe(offset) ? (kSHCoeffsPerProbe * offset) : kInvalidOffset;
    }
    return kInvalidOffset;
}

[numthreads(64, 1, 1)]
void EstimateVariance(uint3 id : SV_DispatchThreadID)
{
    if (id.x < uint(_NumCachedProbes))
    {
        int3 cacheDims = int3(_CacheDims.xyz);
        int3 originIdx = int3(id.x % cacheDims.x, (id.x / cacheDims.x) % cacheDims.y, id.x / (cacheDims.x * cacheDims.y));

        float sumWeights = 0.f;
        float3 m[kSHCoeffsPerProbe], mSqr[kSHCoeffsPerProbe];
        int coeffIdx;
        for (coeffIdx = 0; coeffIdx < kSHCoeffsPerProbe; ++coeffIdx) { m[coeffIdx] = kZero; mSqr[coeffIdx] = kZero; }

        for (int w = -1; w <= 1; ++w)
        {
            for (int v = -1; v <= 1; ++v)
            {
                for (int u = -1; u <= 1; ++u)
                {
                    int shOffset = GetValidProbeSHOffset(originIdx + int3(u, v, w));
                    if(shOffset != kInvalidOffset)
                    {
                        for (coeffIdx = 0; coeffIdx < kSHCoeffsPerProbe; ++coeffIdx, ++shOffset)
                        {
                            float3 coeff = _CachedCoeffs[shOffset];
                            m[coeffIdx] += coeff;
                            mSqr[coeffIdx] += sqr(coeff);
                        }
                        sumWeights += 1.;   
                    }               
                }
            }
        }

        int probeOffset = id.x * kSHCoeffsPerProbe;
        for (coeffIdx = 0; coeffIdx < kSHCoeffsPerProbe; ++coeffIdx, ++probeOffset)
        {
            _CachedCoeffsVar[probeOffset] = mSqr[coeffIdx] / max(1.f, sumWeights) -
                                            sqr(m[coeffIdx] / max(1.f, sumWeights));
            //_CachedCoeffsVar[probeOffset] = kZero;
        }
    }
}

float EvaluateNLMWeight(int3 pIdx, int3 qIdx)
{
    float weights[kSHCoeffsPerProbe];
    int numValidWeights = 0;
    int coeffIdx;
    for (coeffIdx = 0; coeffIdx < kSHCoeffsPerProbe; ++coeffIdx) { weights[coeffIdx] = 0.f; }

    // Accumulate weighted neighbours
    int M = int(_NLMParams.x);
    for (int k = -M; k <= M; ++k)
    {
        for (int j = -M; j <= M; ++j)
        {
            for (int i = -M; i <= M; ++i)
            {
                int pOffset = GetValidProbeSHOffset(pIdx + int3(i, j, k));
                int qOffset = GetValidProbeSHOffset(qIdx + int3(i, j, k));
                if(pOffset != kInvalidOffset && qOffset != kInvalidOffset)
                {
                    //float3 meanP0 = _CachedCoeffs[pOffset];
                    //float3 meanQ0 = _CachedCoeffs[qOffset];
                    //if (all(meanP0 < 1e0) || all(meanQ0 < 1e0)) continue;

                    for (int coeffIdx = 0; coeffIdx < kSHCoeffsPerProbe; ++coeffIdx, ++pOffset, ++qOffset)
                    {
                        float3 meanP = _CachedCoeffs[pOffset];
                        float3 meanQ = _CachedCoeffs[qOffset];
                        float3 varP = _CachedCoeffsVar[pOffset];
                        float3 varQ = _CachedCoeffsVar[qOffset];                        

                        // Compute the distance from P to Q
                        float3 d2 = (sqr(meanQ - meanP) - sqr(_NLMParams.y) * (varQ + min(varP, varQ))) /
                                    (kNLMDistanceEpsilon + sqr(_NLMParams.z) * (varP + varQ));
                        //d2 = sqr(meanQ - meanP) / kNLMDistanceEpsilon;

                        // Derive the weight from the distance
                        weights[coeffIdx] += exp(-max(0.f, cwiseMax(d2)));
                    }
                    ++numValidWeights;
                }
            }
        }
    }

    // Find the coefficient with the minimum weight and return
    float maxWeight = kFltMax;
    for (coeffIdx = 0; coeffIdx < kSHCoeffsPerProbe; ++coeffIdx)
    {
        maxWeight = min(maxWeight, weights[coeffIdx]);
    }
    return maxWeight / float(max(1, numValidWeights));
}

[numthreads(64, 1, 1)]
void KernelFilter(uint3 id : SV_DispatchThreadID)
{
    if (id.x < uint(_NumOutputProbes))
    {
        int3 originIdx = GetCachedIdxFromProbePos(id);
        float sumWeights = 0.;
        float3 accum[kSHCoeffsPerProbe];
        int coeffIdx;

        // Clear the coefficient accumulator
        for (coeffIdx = 0; coeffIdx < kSHCoeffsPerProbe; ++coeffIdx) { accum[coeffIdx] = kZero; }
        
        // Accumulate keighted neighbours
        for (int w = -_N; w <= _N; ++w)
        {
            for (int v = -_N; v <= _N; ++v)
            {
                for (int u = -_N; u <= _N; ++u)
                {
                    int3 kIdx = originIdx + int3(u, v, w);
                    int shOffset = GetValidProbeSHOffset(kIdx);
                    if (shOffset != kInvalidOffset)
                    {
                        /*accum[0] += (!IsValidProbe(shOffset / kSHCoeffsPerProbe) ? float3(1.f, 0.0f, 0.0f) : float3(0.0f, 1.f, 0.f)) * 5.;
                        sumWeights += 1.;
                        continue;*/

                        float weight = 1.;
                        if (any(int3(u, v, w) != 0))
                        {
                            switch (_KernelFilterType)
                            {
                                case kFilterEpanechnikov:
                                {
                                    float d = length(float3(u, v, w)) / (float(_N) + 0.5f);
                                    weight = saturate(1.0 - sqr(d));
                                    break;
                                }
                                case kFilterNLM:
                                {
                                    weight = EvaluateNLMWeight(originIdx, kIdx);
                                    break;
                                }
                            }
                        }

                        if (weight > kWeightThresholdEpsilon)
                        {
                            for (coeffIdx = 0; coeffIdx < kSHCoeffsPerProbe; ++coeffIdx, ++shOffset)
                            {
                                accum[coeffIdx] += _CachedCoeffs[shOffset] * weight;
                                //accum[coeffIdx] += _CachedCoeffsVar[shOffset] * weight;
                            }
                            sumWeights += weight;
                        }
                    }
                }
            }
        }

        // Normalise the accumulated coefficients
        //float3 cacheAlpha = float3(originIdx) / _CacheDims.xyz;
        for (coeffIdx = 0; coeffIdx < kSHCoeffsPerProbe; ++coeffIdx)
        {
            accum[coeffIdx] /= max(1.f, sumWeights);
            //accum[coeffIdx] *= cacheAlpha;
        }

        //int offset = kSHCoeffsPerProbe * (originIdx.z * cacheDims.x * cacheDims.y + originIdx.y * cacheDims.x + originIdx.x)

        RawSphericalHarmonicsL2 sh = { accum[0], accum[1], accum[2], accum[3], accum[4], accum[5], accum[6], accum[7], accum[8] };
        /*sh.L0 *= float3(1., 1., 1.);
        sh.L1_0 *= float3(1., 1., 1.);
        sh.L1_1 *= float3(1., 1., 1.);
        sh.L1_2 *= float3(1., 1., 1.);
        sh.L2_0 *= float3(1., 1., 1.);
        sh.L2_1 *= float3(1., 1., 1.);
        sh.L2_2 *= float3(1., 1., 1.);
        sh.L2_3 *= float3(1., 1., 1.);
        sh.L2_4 *= float3(1., 1., 1.);*/
        _OutputCoeffs[id.x] = sh;
    } 
}
