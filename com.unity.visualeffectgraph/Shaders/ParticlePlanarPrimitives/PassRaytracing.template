
        Pass
        {
            Name "IndirectDXR"
            Tags{ "LightMode" = "IndirectDXR" }

            HLSLPROGRAM
            #pragma target 4.5
            #pragma only_renderers d3d11 ps5
            #pragma raytracing surface_shader

            #define PROCEDURAL_RAY_TRACING
            #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/RaytracingIntersection.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/NormalBuffer.hlsl"

            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/VFXGraph/Shaders/VFXCommon.hlsl"
            #include "Packages/com.unity.visualeffectgraph/Shaders/VFXCommon.hlsl"

            struct AABB
            {
                float3 boxMin;
                float3 boxMax;
            };

            StructuredBuffer<AABB> aabbBuffer;

            [shader("closesthit")]
            void ClosestHit(inout RayIntersection rayIntersection : SV_RayPayload, AttributeData attributeData : SV_IntersectionAttributes)
            {
                uint index = PrimitiveIndex();
                VFXAttributes attributes = (VFXAttributes)0;
                ${VFXLoadAttributes}
                rayIntersection.color = attributes.color * 1000;
            }

            bool RayBoxIntersectionTest(in float3 rayWorldOrigin, in float3 rayWorldDirection, in float3 boxPosWorld, in float3 boxHalfSize, out float outHitT)
            {
                // convert from world to box space
                float3 rd = rayWorldDirection;
                float3 ro = rayWorldOrigin - boxPosWorld;

                // ray-box intersection in box space
                float3 m = 1.0 / rd;
                float3 s = float3(
                    (rd.x < 0.0) ? 1.0 : -1.0,
                    (rd.y < 0.0) ? 1.0 : -1.0,
                    (rd.z < 0.0) ? 1.0 : -1.0);

                float3 t1 = m * (-ro + s * boxHalfSize);
                float3 t2 = m * (-ro - s * boxHalfSize);

                float tN = max(max(t1.x, t1.y), t1.z);
                float tF = min(min(t2.x, t2.y), t2.z);

                if (tN > tF || tF < 0.0)
                    return false;

                outHitT = tN;
                return true;
            }

            [shader("intersection")]
            void IntersectionShader()
            {
                AABB particleAABB = aabbBuffer[PrimitiveIndex()];
                float3 aabbPos = (particleAABB.boxMin + particleAABB.boxMax) * 0.5f - _WorldSpaceCameraPos;
                float3 aabbSize = particleAABB.boxMax - particleAABB.boxMin;

                float outHitT = 0;

                if (RayBoxIntersectionTest(WorldRayOrigin(), WorldRayDirection(), aabbPos, aabbSize * 0.5, outHitT))
                {
                    AttributeData attributeData;
                    attributeData.barycentrics = float2(0.5, 0.5);
                    ReportHit(outHitT, 0, attributeData);
                }
                else
                {
                    AttributeData attributeData;
                    attributeData.barycentrics = float2(0.5, 0.5);
                    ReportHit(0.0f, 0, attributeData);
                }
            }
            ENDHLSL
        }
