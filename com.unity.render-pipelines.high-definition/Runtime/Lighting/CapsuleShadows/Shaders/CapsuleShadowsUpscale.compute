#pragma only_renderers d3d11 playstation xboxone xboxseries vulkan metal switch
//#pragma enable_d3d11_debug_symbols

#pragma kernel Main

#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/CapsuleShadows/Shaders/CapsuleShadowsUpscale.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/CapsuleShadows/ShaderVariablesCapsuleShadows.cs.hlsl"

RW_TEXTURE2D_ARRAY(float, _CapsuleShadowsVisibilityOutput);
TEXTURE2D_ARRAY(_CapsuleShadowsVisibility);
TEXTURE2D_X_UINT(_CapsuleShadowsTileBits);
StructuredBuffer<CapsuleShadowsUpscaleTile> _CapsuleShadowsTileList;

// 4x4 half res pixels with a border of 2, stored with row stride of 9 to avoid bank conflicts
#define TEMP_ROW_STRIDE 9
groupshared float s_tileTemp[TEMP_ROW_STRIDE*8];
uint TempIndex(uint2 coordInTile)   { return coordInTile.y*TEMP_ROW_STRIDE + coordInTile.x; }

float4 LoadTempRow(uint baseIndex)  { return float4(s_tileTemp[baseIndex], s_tileTemp[baseIndex + 1], s_tileTemp[baseIndex + 2], s_tileTemp[baseIndex + 3]); }

[numthreads(8,8,1)]
void Main(uint2 pixelCoordInTile : SV_GroupThreadID, uint2 groupID : SV_GroupID)
{
    uint2 subTileCoord = uint2(groupID.x, groupID.x >> 1) & 1;
    uint entryIndex = groupID.x/4;
    UNITY_XR_ASSIGN_VIEW_INDEX(groupID.y);

    CapsuleShadowsUpscaleTile tile = _CapsuleShadowsTileList[entryIndex];
    uint2 outputTileCoord = GetUpscaleTileCoord(tile);
    uint outputTileBits = GetUpscaleTileBits(tile);

    uint writeTempIndex = TempIndex(pixelCoordInTile);
    uint readTempIndexBase = TempIndex((pixelCoordInTile + 1)/2);

    // each list entry is for a 2x2 region of the output, so offset to the subregion for this threadgroup
    outputTileCoord = 2*outputTileCoord + subTileCoord - 1;
    if (any(outputTileCoord >= _CapsuleUpscaledSizeInTiles))
        return;

    uint2 outputPixelCoord = outputTileCoord * 8 + pixelCoordInTile;
    int2 inputLoadBase = int2(outputTileCoord * 4) - 2;

    // cache half resolution depth in LDS
    {
        uint2 loadCoord = uint2(max(inputLoadBase + int2(pixelCoordInTile), int2(0, 0)));
        float deviceDepth = LOAD_TEXTURE2D_X(_CameraDepthTexture, _FirstDepthMipOffset + loadCoord).x;
        s_tileTemp[writeTempIndex] = LinearEyeDepth(deviceDepth, _ZBufferParams);
    }
    GroupMemoryBarrierWithGroupSync();

    // initialize spatial filter weights (1-2-1 filter interpolated)
    float2 halfResPositionSS = .5f*(float2(outputPixelCoord) + .5f);
    float2 t = frac(halfResPositionSS + .5f);
    float4 wx = lerp(float4(1.f, 2.f, 1.f, 0.f), float4(0.f, 1.f, 2.f, 1.f), t.x);
    float4 wy = lerp(float4(1.f, 2.f, 1.f, 0.f), float4(0.f, 1.f, 2.f, 1.f), t.y);

    // multiply in depth weights
    float targetLinearDepth = LinearEyeDepth(LOAD_TEXTURE2D_X(_CameraDepthTexture, outputPixelCoord).x, _ZBufferParams);
    CapsuleShadowDepthWeightParams params = GetCapsuleShadowsDepthWeightParams(targetLinearDepth, _CapsuleUpscaledSize.zw);
    float4 w0 = wx * wy.x * GetCapsuleShadowsDepthWeight(LoadTempRow(readTempIndexBase + 0*TEMP_ROW_STRIDE), params);
    float4 w1 = wx * wy.y * GetCapsuleShadowsDepthWeight(LoadTempRow(readTempIndexBase + 1*TEMP_ROW_STRIDE), params);
    float4 w2 = wx * wy.z * GetCapsuleShadowsDepthWeight(LoadTempRow(readTempIndexBase + 2*TEMP_ROW_STRIDE), params);
    float4 w3 = wx * wy.w * GetCapsuleShadowsDepthWeight(LoadTempRow(readTempIndexBase + 3*TEMP_ROW_STRIDE), params);
    float norm = 1.f/SumElements(float4(SumElements(w0), SumElements(w1), SumElements(w2), SumElements(w3)));
    GroupMemoryBarrierWithGroupSync();

    // upscale only the casters we need for this tile
    while (outputTileBits != 0)
    {
        uint casterIndex = firstbitlow(outputTileBits);
        uint casterBit = 1U << casterIndex;
        outputTileBits &= ~casterBit;

        // cache to LDS
        {
            uint2 loadCoord = uint2(max(inputLoadBase + int2(pixelCoordInTile), int2(0, 0)));
            uint tileBits = LOAD_TEXTURE2D_X(_CapsuleShadowsTileBits, loadCoord/8);
            float packedVisibility = 0.f;
            if ((tileBits & casterBit) != 0)
                packedVisibility = LOAD_TEXTURE2D_ARRAY(_CapsuleShadowsVisibility, loadCoord, casterIndex).x;
            s_tileTemp[writeTempIndex] = packedVisibility;
        }
        GroupMemoryBarrierWithGroupSync();

        // apply the filter
        float4 v0 = LoadTempRow(readTempIndexBase + 0*TEMP_ROW_STRIDE);
        float4 v1 = LoadTempRow(readTempIndexBase + 1*TEMP_ROW_STRIDE);
        float4 v2 = LoadTempRow(readTempIndexBase + 2*TEMP_ROW_STRIDE);
        float4 v3 = LoadTempRow(readTempIndexBase + 3*TEMP_ROW_STRIDE);
        float result = (dot(v0, w0) + dot(v1, w1) + dot(v2, w2) + dot(v3, w3))*norm;
        _CapsuleShadowsVisibilityOutput[uint3(outputPixelCoord, casterIndex)] = result;
        GroupMemoryBarrierWithGroupSync();
    }
}
