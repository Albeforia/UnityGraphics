#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/TextureXR.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Random.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Sampling/Sampling.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/RaytracingSampling.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariablesGlobal.cs.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/Shadow/ShadowMoments.hlsl"

#pragma only_renderers d3d11 playstation xboxone xboxseries vulkan metal switch

// #pragma enable_d3d11_debug_symbols

#pragma kernel DepthMomentsLinearizeVSM32 DepthMomentsLinearize=DepthMomentsLinearizeVSM32 KERNEL_SIZE=8 _HVSSS_MODE_VSM_32
#pragma kernel DepthMomentsLinearizeVSM16 DepthMomentsLinearize=DepthMomentsLinearizeVSM16 KERNEL_SIZE=8 _HVSSS_MODE_VSM_16
#pragma kernel DepthMomentsLinearizeMoments16 DepthMomentsLinearize=DepthMomentsLinearizeMoments16 KERNEL_SIZE=8 _HVSSS_MODE_MOMENTS_16
#pragma kernel DepthMomentsLinearizeEVSM32 DepthMomentsLinearize=DepthMomentsLinearizeEVSM32 KERNEL_SIZE=8 _HVSSS_MODE_EVSM_32
#pragma kernel DepthMomentsLinearizeEVSM16 DepthMomentsLinearize=DepthMomentsLinearizeEVSM16 KERNEL_SIZE=8 _HVSSS_MODE_EVSM_16

#pragma kernel DepthMomentsDownsampleVSM32 DepthMomentsDownsample=DepthMomentsDownsampleVSM32 KERNEL_SIZE=8 _HVSSS_MODE_VSM_32
#pragma kernel DepthMomentsDownsampleVSM16 DepthMomentsDownsample=DepthMomentsDownsampleVSM16 KERNEL_SIZE=8 _HVSSS_MODE_VSM_16
#pragma kernel DepthMomentsDownsampleMoments16 DepthMomentsDownsample=DepthMomentsDownsampleMoments16 KERNEL_SIZE=8 _HVSSS_MODE_MOMENTS_16
#pragma kernel DepthMomentsDownsampleEVSM32 DepthMomentsDownsample=DepthMomentsDownsampleEVSM32 KERNEL_SIZE=8 _HVSSS_MODE_EVSM_32
#pragma kernel DepthMomentsDownsampleEVSM16 DepthMomentsDownsample=DepthMomentsDownsampleEVSM16 KERNEL_SIZE=8 _HVSSS_MODE_EVSM_16

// #define HIGH_QUALITY_DOWNSAMPLE_ENABLED

// #define KAHAN_SUMMATION_ENABLED

#if defined(_HVSSS_MODE_VSM_16) || defined(_HVSSS_MODE_MOMENTS_16) || defined(_HVSSS_MODE_EVSM_16)
#define DITHER_ENABLED
#endif

TEXTURE2D_X(_DepthTexture);

#if defined(_HVSSS_MODE_MOMENTS_16)
    #define MOMENTS_TYPE float4
#elif defined(_HVSSS_MODE_VSM_16)
    #define MOMENTS_TYPE float2
#elif defined(_HVSSS_MODE_VSM_32)
    #define MOMENTS_TYPE float2
#elif defined(_HVSSS_MODE_EVSM_16)
    #define MOMENTS_TYPE float4
#elif defined(_HVSSS_MODE_EVSM_32)
    #define MOMENTS_TYPE float4
#else
    #error "Undefined MOMENTS_TYPE for variant"
#endif

RW_TEXTURE2D_X(MOMENTS_TYPE, _DepthMomentsMipChain);

CBUFFER_START(cb)
    float4 _SrcOffsetAndLimit; // {x, y, w - 1, h - 1}
    float4 _DstOffsetAndLimit; // {x, y, w - 1, h - 1}
    float4 _HVSSSDepthMinMax;
    float4 _HVSSSDepthScaleBias;
    float4 _HVSSSEVSMExponents;
CBUFFER_END

float NoiseDitherRemapTriangularDistribution(float v)
{
    float orig = v * 2.0 - 1.0;
    float c0 = 1.0 - sqrt(saturate(1.0 - abs(orig)));
    return 0.5 + ((orig.x >= 0.0) ? c0.x : -c0.x);
}

// https://www.shadertoy.com/view/WsfcRj
// Approximate (conservative) floating point dither.
float ComputeFQuantumConservativeApproximate32(float f)
{
    // return exp2(floor(log2(f)) - float(nbitsMantissa));
    // Conservatively approximate f's quantum by dropping floor() from the calculation.
    // return exp2(log2(f) - float(nbitsMantissa));
    // return f / exp2(float(nbitsMantissa));
    // return f / exp2(23.0);
    return f * (1.0 / 8388608.0);
}

// https://www.shadertoy.com/view/WsfcRj
// Approximate (conservative) floating point dither.
float ComputeFQuantumConservativeApproximate16(float f)
{
    // return exp2(floor(log2(f)) - float(nbitsMantissa));
    // Conservatively approximate f's quantum by dropping floor() from the calculation.
    // return exp2(log2(f) - float(nbitsMantissa));
    // return f / exp2(float(nbitsMantissa));
    // return f / exp2(10.0f);
    return f * (1.0 / 1024.0);
}

MOMENTS_TYPE ComputeDither(uint2 texelCoord, uint frameCount)
{
    MOMENTS_TYPE dither = 0.0;

#if defined(DITHER_ENABLED)

#if defined(_HVSSS_MODE_MOMENTS_16)
    dither = float4(
        GetBNDSequenceSample(texelCoord, frameCount & 7u, 0),
        GetBNDSequenceSample(texelCoord, frameCount & 7u, 1),
        GetBNDSequenceSample(texelCoord, frameCount & 7u, 2),
        GetBNDSequenceSample(texelCoord, frameCount & 7u, 3)
    );
    dither = float4(
        NoiseDitherRemapTriangularDistribution(dither.x),
        NoiseDitherRemapTriangularDistribution(dither.y),
        NoiseDitherRemapTriangularDistribution(dither.z),
        NoiseDitherRemapTriangularDistribution(dither.w)
    );
    dither *= 1.0 / (float)((1 << 16) - 1);
#elif defined(_HVSSS_MODE_VSM_32)
    dither.xy = float2(
        GetBNDSequenceSample(texelCoord, frameCount & 7u, 0),
        GetBNDSequenceSample(texelCoord, frameCount & 7u, 1)
    );
    dither.xy = float2(
        NoiseDitherRemapTriangularDistribution(dither.x),
        NoiseDitherRemapTriangularDistribution(dither.y)
    );
    dither.xy *= float2(
        ComputeFQuantumConservativeApproximate32(moments.x),
        ComputeFQuantumConservativeApproximate32(moments.y)
    );
#elif defined(_HVSSS_MODE_VSM_16)
    dither.xy = float2(
        GetBNDSequenceSample(texelCoord, frameCount & 7u, 0),
        GetBNDSequenceSample(texelCoord, frameCount & 7u, 1)
    );
    dither.xy = float2(
        NoiseDitherRemapTriangularDistribution(dither.x),
        NoiseDitherRemapTriangularDistribution(dither.y)
    );
    dither.xy *= 1.0 / (float)((1 << 16) - 1);
#elif defined(_HVSSS_MODE_EVSM_32)
    dither = float4(
        GetBNDSequenceSample(texelCoord, frameCount & 7u, 0),
        GetBNDSequenceSample(texelCoord, frameCount & 7u, 1),
        GetBNDSequenceSample(texelCoord, frameCount & 7u, 2),
        GetBNDSequenceSample(texelCoord, frameCount & 7u, 3)
    );
    dither = float4(
        NoiseDitherRemapTriangularDistribution(dither.x),
        NoiseDitherRemapTriangularDistribution(dither.y),
        NoiseDitherRemapTriangularDistribution(dither.z),
        NoiseDitherRemapTriangularDistribution(dither.w)
    );
    dither *= float4(
        ComputeFQuantumConservativeApproximate32(moments.x),
        ComputeFQuantumConservativeApproximate32(moments.y),
        ComputeFQuantumConservativeApproximate32(moments.z),
        ComputeFQuantumConservativeApproximate32(moments.w)
    );
#elif defined(_HVSSS_MODE_EVSM_16)
    dither = float4(
        GetBNDSequenceSample(texelCoord, frameCount & 7u, 0),
        GetBNDSequenceSample(texelCoord, frameCount & 7u, 1),
        GetBNDSequenceSample(texelCoord, frameCount & 7u, 2),
        GetBNDSequenceSample(texelCoord, frameCount & 7u, 3)
    );
    dither = float4(
        NoiseDitherRemapTriangularDistribution(dither.x),
        NoiseDitherRemapTriangularDistribution(dither.y),
        NoiseDitherRemapTriangularDistribution(dither.z),
        NoiseDitherRemapTriangularDistribution(dither.w)
    );
    dither *= 1.0 / (float)((1 << 16) - 1);
#else
    #error "ComputeDither not implemented for variant"
#endif

#endif

    return dither;
}

MOMENTS_TYPE ApplyDither(MOMENTS_TYPE moments, MOMENTS_TYPE dither)
{
#if defined(_HVSSS_MODE_EVSM_32)
    MOMENTS_TYPE res = moments + dither;
    // moments.y is all negative due to -exp(-exponent * depth) encoding.
    // All other channels are strictly positive.
    res.y = min(0.0, res.y);
    res.xzw = max(0.0, res.xzw);
    return res;
#else
    return max(0.0, moments + dither);
#endif
}

MOMENTS_TYPE EncodeMomentsFromLinearDepth(float linearDepth, float4 hvsssDepthScaleBias, float4 hvsssEVSMExponents)
{
#if defined(_HVSSS_MODE_MOMENTS_16)
    return ShadowMoments_Encode16MSM(saturate(linearDepth * hvsssDepthScaleBias.x + hvsssDepthScaleBias.y));
#elif defined(_HVSSS_MODE_VSM_16)
    return ShadowMoments_Encode16VSM(saturate(linearDepth * hvsssDepthScaleBias.x + hvsssDepthScaleBias.y));
#elif defined(_HVSSS_MODE_VSM_32)
    return float2(linearDepth, linearDepth * linearDepth);
#elif defined(_HVSSS_MODE_EVSM_32)
    float2 warpedDepth = ShadowMoments_WarpDepth(saturate(linearDepth * hvsssDepthScaleBias.x + hvsssDepthScaleBias.y), hvsssEVSMExponents.xy);
    // warpedDepth.y = -warpedDepth.y;
    return float4(warpedDepth, warpedDepth * warpedDepth);
#elif defined(_HVSSS_MODE_EVSM_16)
    return ShadowMoments_Encode16EVSM(saturate(linearDepth * hvsssDepthScaleBias.x + hvsssDepthScaleBias.y), hvsssEVSMExponents.xy);
#else
    #error "EncodeMomentsFromLinearDepth not implemented for variant"
#endif
}

// The size of the dispatch is (DstMipSize / KernelSize).
[numthreads(KERNEL_SIZE, KERNEL_SIZE, 1)]
void DepthMomentsLinearize(uint3 dispatchThreadId : SV_DispatchThreadID)
{
    UNITY_XR_ASSIGN_VIEW_INDEX(dispatchThreadId.z);

    uint2 srcOffset = _SrcOffsetAndLimit.xy;
    uint2 srcLimit  = _SrcOffsetAndLimit.zw;
    uint2 dstOffset = _DstOffsetAndLimit.xy;
    uint2 dstLimit = _DstOffsetAndLimit.zw;

    uint2 dstPixel = dstOffset + dispatchThreadId.xy;

    if (all(dstPixel >= dstOffset) && all(dstPixel <= dstLimit))
    {
        uint2 srcPixel = srcOffset + dispatchThreadId.xy;

        float deviceDepth = LOAD_TEXTURE2D_X(_DepthTexture, min(srcPixel, srcLimit)).r;
        float linearDepth = LinearEyeDepth(deviceDepth, _ZBufferParams);

        MOMENTS_TYPE moments = EncodeMomentsFromLinearDepth(linearDepth, _HVSSSDepthScaleBias, _HVSSSEVSMExponents);
        MOMENTS_TYPE dither = ComputeDither(dispatchThreadId.xy, _FrameCount);
        moments = ApplyDither(moments, dither);

        _DepthMomentsMipChain[COORD_TEXTURE2D_X(dstPixel)] = moments;
    }
}

MOMENTS_TYPE LoadMoments(uint2 texelCoord)
{
#if defined(_HVSSS_MODE_MOMENTS_16) || defined(_HVSSS_MODE_EVSM_32) || defined(_HVSSS_MODE_EVSM_16)
    return _DepthMomentsMipChain[COORD_TEXTURE2D_X(texelCoord)];
#elif defined(_HVSSS_MODE_VSM_16)
    return _DepthMomentsMipChain[COORD_TEXTURE2D_X(texelCoord)].xy;
#elif defined(_HVSSS_MODE_VSM_32)
    return _DepthMomentsMipChain[COORD_TEXTURE2D_X(texelCoord)].xy;
#else
    #error "LoadMoments not implemented for variant"
#endif 
}

struct MomentsAccumulator
{
    MOMENTS_TYPE moments;
    float weight;
#if defined(KAHAN_SUMMATION_ENABLED)
    MOMENTS_TYPE momentsCompensation;
    float weightCompensation;
#endif
};

void AccumulateMoments(inout MomentsAccumulator momentsAccumulator, MOMENTS_TYPE sampleMoments, float sampleWeight)
{
#if defined(KAHAN_SUMMATION_ENABLED)
    MOMENTS_TYPE accumulatedMomentsY = sampleWeight * sampleMoments - momentsAccumulator.momentsCompensation;
    MOMENTS_TYPE accumulatedMomentsT = sampleWeight * sampleMoments + momentsAccumulator.moments;
    momentsAccumulator.momentsCompensation = (accumulatedMomentsT - momentsAccumulator.moments) - accumulatedMomentsY;
    momentsAccumulator.moments = accumulatedMomentsT;

    float accumulatedWeightY = sampleWeight - momentsAccumulator.weightCompensation;
    float accumulatedWeightT = sampleWeight + momentsAccumulator.weight;
    momentsAccumulator.weightCompensation = (accumulatedWeightT - momentsAccumulator.weight) - accumulatedWeightY;
    momentsAccumulator.weight = accumulatedWeightT;
#else
    momentsAccumulator.moments += sampleWeight * sampleMoments;
    momentsAccumulator.weight += sampleWeight;
#endif
}

void ComputeSamplePixelAndTexelCoord(out float2 sampleSourcePixel, out float2 sampleSourceTexelCoord, float2 centerSourcePixel, float2 sampleOffsetPixel, uint2 srcOffset, uint2 srcLimit)
{
    sampleSourcePixel = centerSourcePixel + sampleOffsetPixel + 0.5;
    sampleSourcePixel = clamp(sampleSourcePixel, 0.5, (srcLimit - srcOffset) + 0.5);
    sampleSourceTexelCoord = (uint2)floor(sampleSourcePixel) + srcOffset;
    sampleSourceTexelCoord = min(sampleSourceTexelCoord, srcLimit);
}

float ComputeGaussianWeight(float sharpness, float2 sampleKernelOffsetPixels)
{
    return exp2(-sharpness * dot(sampleKernelOffsetPixels, sampleKernelOffsetPixels));
}

MOMENTS_TYPE ComputeDepthMomentsDownsampleHighQuality(uint2 dispatchThreadId, uint2 srcOffset, uint2 srcLimit, uint2 dstOffset, uint2 dstLimit)
{
    float2 centerSourcePixel = (float2)(dispatchThreadId << 1) + float2(1.0, 1.0);

    MomentsAccumulator momentsAccumulator;
    ZERO_INITIALIZE(MomentsAccumulator, momentsAccumulator);

    const float SHARPNESS = 1.5;
    for (int x = -2; x < 2; ++x)
    {
        for (int y = -2; y < 2; ++y)
        {
            float2 sampleSourcePixel;
            uint2 sampleSourceTexelCoord;
            ComputeSamplePixelAndTexelCoord(sampleSourcePixel, sampleSourceTexelCoord, centerSourcePixel, float2(x, y), srcOffset, srcLimit);

            MOMENTS_TYPE sampleMoments = LoadMoments(sampleSourceTexelCoord);

            float2 sampleKernelOffsetPixels = sampleSourcePixel - centerSourcePixel;
            float sampleWeight = ComputeGaussianWeight(SHARPNESS, sampleKernelOffsetPixels);

            AccumulateMoments(momentsAccumulator, sampleMoments, sampleWeight);

        }
    }
    float accumulatedWeightNormalization = (momentsAccumulator.weight > 1e-5) ? rcp(momentsAccumulator.weight) : 0.0;
    MOMENTS_TYPE moments = momentsAccumulator.moments * accumulatedWeightNormalization;
    return moments;
}

MOMENTS_TYPE ComputeDepthMomentsDownsampleLowQuality(uint2 dispatchThreadId, uint2 srcOffset, uint2 srcLimit, uint2 dstOffset, uint2 dstLimit)
{
    // Upper-left pixel coordinate of quad that this thread will read
    uint2 srcPixelUL = srcOffset + (dispatchThreadId.xy << 1);

    MOMENTS_TYPE moments00 = LoadMoments(min(srcPixelUL + uint2(0u, 0u), srcLimit));
    MOMENTS_TYPE moments10 = LoadMoments(min(srcPixelUL + uint2(1u, 0u), srcLimit));
    MOMENTS_TYPE moments01 = LoadMoments(min(srcPixelUL + uint2(0u, 1u), srcLimit));
    MOMENTS_TYPE moments11 = LoadMoments(min(srcPixelUL + uint2(1u, 1u), srcLimit));

    MOMENTS_TYPE moments = moments00 * 0.25 + moments10 * 0.25 + moments01 * 0.25 + moments11 * 0.25;
    return moments;
}

MOMENTS_TYPE ComputeDepthMomentsDownsampleSelectedQuality(uint2 dispatchThreadId, uint2 srcOffset, uint2 srcLimit, uint2 dstOffset, uint2 dstLimit)
{
#if defined(HIGH_QUALITY_DOWNSAMPLE_ENABLED)
        return ComputeDepthMomentsDownsampleHighQuality(dispatchThreadId, srcOffset, srcLimit, dstOffset, dstLimit);
#else
        return ComputeDepthMomentsDownsampleLowQuality(dispatchThreadId, srcOffset, srcLimit, dstOffset, dstLimit);
#endif
}

// The size of the dispatch is (DstMipSize / KernelSize).
[numthreads(KERNEL_SIZE, KERNEL_SIZE, 1)]
void DepthMomentsDownsample(uint3 dispatchThreadId : SV_DispatchThreadID)
{
    UNITY_XR_ASSIGN_VIEW_INDEX(dispatchThreadId.z);

    uint2 srcOffset = _SrcOffsetAndLimit.xy;
    uint2 srcLimit  = _SrcOffsetAndLimit.zw;
    uint2 dstOffset = _DstOffsetAndLimit.xy;
    uint2 dstLimit = _DstOffsetAndLimit.zw;

    uint2 dstPixel = dstOffset + dispatchThreadId.xy;
    if (all(dstPixel >= dstOffset) && all(dstPixel <= dstLimit))
    {
        MOMENTS_TYPE moments = ComputeDepthMomentsDownsampleSelectedQuality(dispatchThreadId.xy, srcOffset, srcLimit, dstOffset, dstLimit);

        MOMENTS_TYPE dither = ComputeDither(dispatchThreadId.xy, _FrameCount);
        moments = ApplyDither(moments, dither);
    
        _DepthMomentsMipChain[COORD_TEXTURE2D_X(dstPixel)] = moments;
    }
}