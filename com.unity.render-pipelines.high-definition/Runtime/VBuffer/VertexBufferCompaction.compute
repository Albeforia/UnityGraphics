#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Builtin/BuiltinData.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Packing.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/VBuffer/HDRenderPipeline.VertexBufferCompaction.cs.hlsl"

#pragma kernel VBCompactionKernel
#pragma kernel IBCompactionKernelUINT32
#pragma kernel IBCompactionKernelUINT16
#pragma enable_d3d11_debug_symbols


float4 _UVCompactionParams;
float4 _NormalCompactionParams;
float4 _PosCompactionParams;
float4 _TangentCompactionParams;


#define _UVVBBias (uint)_UVCompactionParams.x
#define _NormalVBBias (uint)_NormalCompactionParams.x
#define _PosVBBias (uint)_PosCompactionParams.x
#define _TangentVBBias (uint)_TangentCompactionParams.x

#define _VBCount (uint)_UVCompactionParams.y

#define _UVVBStride (uint)_UVCompactionParams.z
#define _NormalVBStride (uint)_NormalCompactionParams.z
#define _PosVBStride (uint)_PosCompactionParams.z
#define _TangentVBStride (uint)_TangentCompactionParams.z

#define _VBOutputBias (uint)_UVCompactionParams.w


float4 _IBCompactionParams;

#define _IBCount (uint)_IBCompactionParams.x
#define _IBOutputBias (uint)_IBCompactionParams.y
#define _IBValueShift (uint)_IBCompactionParams.z
#define _IBInputStart (uint)_IBCompactionParams.w


ByteAddressBuffer _InputUVVB;
ByteAddressBuffer _InputNormalVB;
ByteAddressBuffer _InputPosVB;
ByteAddressBuffer _InputTangentVB;

RWStructuredBuffer<CompactVertex> _OutputVB;

CompactVertex GetCompactVertex(float2 uv, float3 pos, float3 N, float4 T)
{
    CompactVertex vtx;
    vtx.pos = pos;
    vtx.uv = uv;

    vtx.N = N;
    vtx.T = T;

    return vtx;
}

[numthreads(64, 1, 1)]
void VBCompactionKernel(uint3 id : SV_DispatchThreadID)
{
    if (id.x < _VBCount)
    {
        int vertexIdx = id.x;

        // Sample from inputs
        float2 uv = asfloat(_InputUVVB.Load2(vertexIdx * _UVVBStride + _UVVBBias));
        float3 pos = asfloat(_InputPosVB.Load3(vertexIdx * _PosVBStride + _PosVBBias));
        float3 N = asfloat(_InputNormalVB.Load3(vertexIdx * _NormalVBStride + _NormalVBBias));
        float4 T = asfloat(_InputTangentVB.Load4(vertexIdx * _TangentVBStride + _TangentVBBias));

        CompactVertex vtx = GetCompactVertex(uv, pos, N, T);
        _OutputVB[_VBOutputBias + vertexIdx] = vtx;
    }
}

RWStructuredBuffer<uint> _OutputIB;
ByteAddressBuffer _InputIB;

[numthreads(64, 1, 1)]
void IBCompactionKernelUINT32(uint3 id : SV_DispatchThreadID)
{
    if (id.x < _IBCount)
    {
        _OutputIB[_IBOutputBias + id.x] = asuint(_InputIB.Load(id.x + _IBInputStart)) + _IBValueShift;
    }
}


[numthreads(64, 1, 1)]
void IBCompactionKernelUINT16(uint3 id : SV_DispatchThreadID)
{
    if (id.x < _IBCount)
    {
        uint startIdx = (_IBInputStart + id.x);
        uint accessIdx = (startIdx / 2);
        uint inputCouple = asuint(_InputIB.Load(accessIdx * 4));

        uint outputIdx = 0;
        if ((startIdx & 1) == 0)
        {
            outputIdx = inputCouple & 0xffff;
        }
        else
        {
            outputIdx = inputCouple >> 16;
        }

        _OutputIB[_IBOutputBias + id.x] = outputIdx + _IBValueShift;
    }
}
