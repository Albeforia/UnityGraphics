#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Packing.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl"


#pragma kernel ExtractData 
#pragma enable_d3d11_debug_symbols
#define GROUP_SIZE 64
#define AXIS_COUNT 14

float4 _RayAxis[AXIS_COUNT];
float4 _ProbeValidity[GROUP_SIZE / 4];
float4 _ExtractParameters;
float4x4 _SkewMatrix;

#define _ProbeIndexOffset _ExtractParameters.x
#define _BatchSize _ExtractParameters.y
#define _SearchDistance _ExtractParameters.z


TEXTURECUBE_ARRAY(_CubemapPoolAlbedo);
TEXTURECUBE_ARRAY(_CubemapPoolNormal);
TEXTURECUBE_ARRAY(_CubemapPoolDepth);

RWStructuredBuffer<uint3>  _PackedProbeExtraData;

uint PackAxisDir(float4 axis)
{
    uint axisType = (axis.w == 1.0f) ? 0u : 1u;

    uint encodedX = axis.x < 0 ? 0u :
        axis.x == 0 ? 1u :
        2u;

    uint encodedY = axis.y < 0 ? 0u :
        axis.y == 0 ? 1u :
        2u;

    uint encodedZ = axis.z < 0 ? 0u :
        axis.z == 0 ? 1u :
        2u;

    uint output = 0;
    // Encode type of axis in bit 7
    output |= (axisType << 6);
    // Encode axis signs in [5:6] [3:4] [1:2]
    output |= (encodedZ << 4);
    output |= (encodedY << 2);
    output |= (encodedX << 0);

    return output;
}

uint PackNormalAndAxis(float2 octNormalWS, int axisIndex)
{
    uint packedOutput = 0;

    uint i0 = (uint)(octNormalWS.x * 4095.5f); uint i1 = (uint)(octNormalWS.y * 4095.5f);
    uint hi0 = i0 >> 8; uint hi1 = i1 >> 8;
    uint lo0 = hi0 & 255; uint lo1 = hi1 & 255;

    packedOutput |= (lo0 << 0);
    packedOutput |= (lo1 << 8);
    packedOutput |= ((hi0 | (hi1 << 4)) << 16);
    packedOutput |= (PackAxisDir(_RayAxis[axisIndex]) << 24);

    return packedOutput;
}

uint PackAlbedo(float3 color, float distance)
{
    float albedoR = saturate(color.x);
    float albedoG = saturate(color.y);
    float albedoB = saturate(color.z);

    // TODO_FCC: TODO! REMOVE NEAR PLANE THINGIE.
    float searchDistance = _SearchDistance; // TODO: PUT ACTUAL VALUES HERE... search dist * sqrt(3) for normalizing.
    float normalizedDistance = saturate(distance / searchDistance);

    uint packedOutput = 0;

    packedOutput |= ((uint)(albedoR * 255.5f) << 0);
    packedOutput |= ((uint)(albedoG * 255.5f) << 8);
    packedOutput |= ((uint)(albedoB * 255.5f) << 16);
    packedOutput |= ((uint)(normalizedDistance * 255.5f) << 24);

    return packedOutput;
}

uint PackIndexAndValidity(uint probeIndex, uint axisIndex, float validity)
{
    uint output = 0;

    output |= axisIndex;
    output |= ((uint)(validity * 255.5f) << 5);
    output |= (probeIndex << 13);

    return output;
}



[numthreads(GROUP_SIZE, 1, 1)]
void ExtractData(uint3 id : SV_DispatchThreadID)
{
    uint indexInPool = id.x;
    if (indexInPool < _BatchSize)
    {
        uint probeIndex = _ProbeIndexOffset + indexInPool;

        float probeValidity = _ProbeValidity[indexInPool / 4][indexInPool % 4];

        for (int i = 0; i < AXIS_COUNT; ++i)
        {
            float4 axis = _RayAxis[i];

            // Skew the axis as the rendering was skewed to start with.
            //float3 actualAxis = mul(_SkewMatrix, float4(normalize(axis.xyz), 0.0f)).xyz;
            float3 sampleAxis = normalize(axis.xyz);

            float3 albedo = SAMPLE_TEXTURECUBE_ARRAY_LOD(_CubemapPoolAlbedo, s_trilinear_clamp_sampler, sampleAxis, indexInPool, 0).xyz;
            float2 N = SAMPLE_TEXTURECUBE_ARRAY_LOD(_CubemapPoolNormal, s_trilinear_clamp_sampler, sampleAxis, indexInPool, 0).xy;
            float depth = SAMPLE_TEXTURECUBE_ARRAY_LOD(_CubemapPoolDepth, s_trilinear_clamp_sampler, sampleAxis, indexInPool, 0).x;

            uint3 packedData = 0;
            packedData.x = PackAlbedo(albedo, depth);
            packedData.y = PackNormalAndAxis(N, i);
            packedData.z = PackIndexAndValidity(probeIndex, i, probeValidity);

            _PackedProbeExtraData[probeIndex * AXIS_COUNT + i] = packedData;
        }
    }
}

