
        Pass
        {
            Name "IndirectDXR"
            Tags{ "LightMode" = "IndirectDXR" }

            HLSLPROGRAM
            #pragma target 4.5
            #pragma only_renderers d3d11 ps5
            #pragma raytracing surface_shader

            #define PROCEDURAL_RAY_TRACING
    //Temporary to workaround the missing _RayTracingLODBias
            //#include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/RaytracingMacros.hlsl"

            #ifdef SAMPLE_TEXTURE2D
            #undef SAMPLE_TEXTURE2D
            #define SAMPLE_TEXTURE2D(textureName, samplerName, coord2)                              textureName.SampleLevel(samplerName, coord2, 0)
            #endif

            #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/RaytracingIntersection.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/NormalBuffer.hlsl"

            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/VFXGraph/Shaders/VFXCommon.hlsl"
            #include "Packages/com.unity.visualeffectgraph/Shaders/VFXCommon.hlsl"


            #define SHADER_STAGE_RAY_TRACING
            ${VFXGeneratedBlockFunction}

            struct AABB
            {
                float3 boxMin;
                float3 boxMax;
            };

            StructuredBuffer<AABB> aabbBuffer;

            [shader("closesthit")]
            void ClosestHit(inout RayIntersection rayIntersection : SV_RayPayload, AttributeData attributeData : SV_IntersectionAttributes)
            {
                uint index = PrimitiveIndex();
                VFXAttributes attributes = (VFXAttributes)0;
                ${VFXLoadAttributes}
                rayIntersection.color = SampleTexture(VFX_SAMPLER(mainTexture), attributeData.barycentrics) * (1.0f/GetCurrentExposureMultiplier()) *  attributes.color;
            }

            bool RayBoxIntersectionTest(in float3 rayWorldOrigin, in float3 rayWorldDirection, in float3 boxPosWorld, in float3 boxHalfSize, out float outHitT)
            {
                // convert from world to box space
                float3 rd = rayWorldDirection;
                float3 ro = rayWorldOrigin - boxPosWorld;

                // ray-box intersection in box space
                float3 m = 1.0 / rd;
                float3 s = float3(
                    (rd.x < 0.0) ? 1.0 : -1.0,
                    (rd.y < 0.0) ? 1.0 : -1.0,
                    (rd.z < 0.0) ? 1.0 : -1.0);

                float3 t1 = m * (-ro + s * boxHalfSize);
                float3 t2 = m * (-ro - s * boxHalfSize);

                float tN = max(max(t1.x, t1.y), t1.z);
                float tF = min(min(t2.x, t2.y), t2.z);

                if (tN > tF || tF < 0.0)
                    return false;

                outHitT = tN;
                return true;
            }


             bool RayPlaneIntersection(in float3 rayObjectOrigin, in float3 rayObjectDirection, in float3 planeNormal, in float3 planeOrigin, out float outHitT, out float3 hitPoint)
            {
               outHitT = dot((planeOrigin - rayObjectOrigin), planeNormal)/dot(rayObjectDirection, planeNormal);
               if(outHitT < 0.0f)
               {
                    hitPoint = float3(0,0,0);
                    return false;
               }
               else
               {
                    hitPoint = rayObjectOrigin + outHitT * rayObjectDirection;
               }
               return true;
            }
            bool RayQuadIntersection(in float3 rayObjectOrigin, in float3 rayObjectDirection, in float4x4 elementToVFX, in float4x4 vfxToElement, in float3 size3, out float outHitT, out float2 uv)
            {
                float3 hitPoint = float3(0,0,0);
                float3 planeNormal = -elementToVFX._m02_m12_m22;
                float3 planeOrigin = elementToVFX._m03_m13_m23;
                if(RayPlaneIntersection(rayObjectOrigin, rayObjectDirection, planeNormal, planeOrigin, outHitT, hitPoint))
                {
                    uv = mul(vfxToElement, float4(hitPoint,1.0f)).xy + 0.5f;
                    if(any(uv < 0.0f) || any(uv > 1.0f) )
                        return false;
                    return true;
                }
                return false;
            }




            [shader("intersection")]
            void IntersectionShader()
            {
                uint index = PrimitiveIndex();

                AABB particleAABB = aabbBuffer[index];
                float3 boxMin = TransformObjectToWorld(particleAABB.boxMin);
                float3 boxMax = TransformObjectToWorld(particleAABB.boxMax); //Works for non rotated effects
                float3 aabbPos = (boxMin + boxMax) * 0.5f;
                float3 aabbSize = boxMax - boxMin;
                float outHitT = 0;
                float2 uv = float2(0,0);

		        VFXAttributes attributes = (VFXAttributes)0;
	            ${VFXLoadAttributes}
	            ${VFXProcessBlocks}
	            ${VFXLoadSize}


                const float4x4 elementToVFX = GetElementToVFXMatrix(
		            attributes.axisX,
		            attributes.axisY,
		            attributes.axisZ,
		            float3(attributes.angleX,attributes.angleY,attributes.angleZ),
		            float3(attributes.pivotX,attributes.pivotY,attributes.pivotZ),
		            size3,
		            attributes.position);

                const float4x4 vfxToElement = GetVFXToElementMatrix(
		            attributes.axisX,
		            attributes.axisY,
		            attributes.axisZ,
		            float3(attributes.angleX,attributes.angleY,attributes.angleZ),
		            float3(attributes.pivotX,attributes.pivotY,attributes.pivotZ),
		            size3,
		            attributes.position);

                if (RayQuadIntersection(ObjectRayOrigin(), ObjectRayDirection(), elementToVFX, vfxToElement, size3, outHitT, uv))
                {
                    AttributeData attributeData;
                    attributeData.barycentrics = uv;
                    float alpha = SampleTexture(VFX_SAMPLER(mainTexture),uv).a;
                    if(alpha > 0.5f)
                        ReportHit(outHitT, 0, attributeData);
                }
            }
            ENDHLSL
        }
