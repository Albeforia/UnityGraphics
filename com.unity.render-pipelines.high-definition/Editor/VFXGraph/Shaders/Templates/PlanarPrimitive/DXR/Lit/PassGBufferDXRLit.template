
        Pass
        {
            Name "GBufferDXR"
            Tags{ "LightMode" = "GBufferDXR" }

            HLSLPROGRAM
            #pragma target 4.5
            #pragma only_renderers d3d11 ps5
            #pragma raytracing surface_shader
            #pragma multi_compile _ MINIMAL_GBUFFER
            #pragma multi_compile PROBE_VOLUMES_OFF PROBE_VOLUMES_L1 PROBE_VOLUMES_L2

            // Global includes
            #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl"

            // Define the shader pass
            #define SHADERPASS SHADERPASS_RAYTRACING_GBUFFER

            // Need to override the macros for ray tracing
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/RaytracingMacros.hlsl"

            // Shader variables
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/ShaderVariablesRaytracing.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/Deferred/RaytracingIntersectonGBuffer.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/NormalBuffer.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/StandardLit/StandardLit.hlsl"

            // VFX includes
            ${VFXIncludeRP("Templates/PlanarPrimitive/DXR/Common/RayTracingInputStructure.template")}
            ${VFXHDRPLitVaryingsMacros}
            ${VFXPerPassInclude}
            ${VFXIncludeRP("VFXLit.template")}

            // Needs to be included after the VFX includes
            ${VFXIncludeRP("Templates/PlanarPrimitive/DXR/Lit/IntersectionFunctions.template")}

            // Lighting and material includes
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/Common/RayTracingProcedural.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/RayTracingCommon.hlsl"

            // Defines for the attributes
            ${VFXIncludeRP("VFXLitVaryings.template")}

            // Graph functions
            ${VFXGeneratedBlockFunction}

            [shader("closesthit")]
            void ClosestHit(inout RayIntersectionGBuffer rayIntersectionGbuffer : SV_RayPayload, AttributeData attributeData : SV_IntersectionAttributes)
            {
                UNITY_XR_ASSIGN_VIEW_INDEX(DispatchRaysIndex().z);

                // Compute the distance of the ray
                rayIntersectionGbuffer.t = RayTCurrent();

                // Evaluate the view direction
                float3 viewWS = -WorldRayDirection();

                // Evaluate the position
                float3 positionRWS = WorldRayOrigin() + rayIntersectionGbuffer.t * WorldRayDirection();

                // Evaluate the position input
                PositionInputs posInput = GetPositionInput(0, _ScreenSize.zw, positionRWS);

                // Index needs to be available in the context for the attribute load to work
                ${VFXGetIndexFromRTPrimitiveIndex}

                // Attributes of the paticle
                VFXAttributes attributes;
                ZERO_INITIALIZE(VFXAttributes, attributes);

                // Load the VFX attributes that we need for this
                ${VFXLoadAttributes}
                ${VFXProcessBlocks}
                ${VFXLoadSizeRT}

                // Build the "varying" input
                rt_input o;
                ZERO_INITIALIZE(rt_input, o);

                // Fill the attributes
                ${VFXVertexCommonProcess}

                // Object <-> primtive matrices
                const float4x4 objectToPrimitive = GetVFXToElementMatrix(attributes.axisX, attributes.axisY, attributes.axisZ,
                    float3(attributes.angleX, attributes.angleY, attributes.angleZ),
                    float3(attributes.pivotX, attributes.pivotY, attributes.pivotZ),
                    size3, attributes.position);

                // TODO have the real normal here
                float3 normalOS = normalize(-objectToPrimitive[2].xyz);

                // Build the uv data
                VFXUVData uvData;
                uvData.uvs = float4(attributeData.barycentrics, 0, 0);
                uvData.blend = 0;
                uvData.mvs = 0;

                // Output structures
                SurfaceData surfaceData = (SurfaceData)0;
                BuiltinData builtinData = (BuiltinData)0;
                BSDFData bsdfData = (BSDFData)0;
                PreLightData preLightData = (PreLightData)0;

                // Evaluate the input data
                VFXGetHDRPLitData(surfaceData, builtinData, bsdfData, preLightData, o, normalOS, uvData, 0);

                // First we pack the data into the standard bsdf data
                StandardBSDFData standardLitData;
                ZERO_INITIALIZE(StandardBSDFData, standardLitData);
                FitToStandardLit(bsdfData, builtinData, posInput.positionSS, standardLitData);

            #ifdef MINIMAL_GBUFFER
                // Override all the parameters that we do not require for our minimal lit version
                standardLitData.specularOcclusion = 1.0;
                standardLitData.normalWS = fragInput.tangentToWorld[2];
                standardLitData.coatMask = 0.0;
                standardLitData.emissiveAndBaked = builtinData.emissiveColor;
            #endif

                // Then export it to the gbuffer
                EncodeIntoStandardGBuffer(standardLitData, rayIntersectionGbuffer.gbuffer0, rayIntersectionGbuffer.gbuffer1, rayIntersectionGbuffer.gbuffer2, rayIntersectionGbuffer.gbuffer3);
                rayIntersectionGbuffer.t = standardLitData.isUnlit != 0 ? RAY_TRACING_DISTANCE_FLAG_UNLIT : RayTCurrent();
            }

            // Inject the intersection shader
            ${VFXIncludeRP("Templates/PlanarPrimitive/DXR/Common/IntersectionShader.template")}
            ENDHLSL
        }
