#pragma only_renderers d3d11 playstation xboxone xboxseries vulkan metal switch
//#pragma enable_d3d11_debug_symbols

#pragma multi_compile_local _ CAPSULE_TILE_DEBUG

#pragma kernel Main

#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/NormalBuffer.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/CapsuleShadows/ShaderVariablesCapsuleShadows.cs.hlsl"
#include "Packages/com.unity.render-pipelines.core/Runtime/Lighting/CapsuleShadows/Shaders/CapsuleShadows.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/CapsuleShadows/Shaders/CapsuleShadowsGlobals.hlsl"
#ifdef CAPSULE_TILE_DEBUG
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/LightingDebug.cs.hlsl"
#endif

StructuredBuffer<CapsuleOccluderData> _CapsuleOccluderDatas;
RW_TEXTURE2D_X(float2, _CapsuleShadowsRenderOutput);
#ifdef CAPSULE_TILE_DEBUG
RW_TEXTURE2D_X(uint, _CapsuleTileDebug);
#endif

#define DEPTH_MAX_EMPTY         0x00000001U
#define DEPTH_MIN_EMPTY         0xffffffffU
#define DEPTH_RANGE_COUNT       2
groupshared uint s_depthMinU[DEPTH_RANGE_COUNT];
groupshared uint s_depthMaxU[DEPTH_RANGE_COUNT];
groupshared float3 s_tileCenter[DEPTH_RANGE_COUNT];
groupshared uint s_tileRadiusU[DEPTH_RANGE_COUNT];
groupshared uint s_capsuleBits[2];

#if USE_LEFT_HAND_CAMERA_SPACE
#define PACK_UNPACK_POSITIVE_DEPTH(D)   (D)
#else
#define PACK_UNPACK_POSITIVE_DEPTH(D)   (-(D))
#endif

float MaxElement(float2 v)
{
    return max(v.x, v.y);
}

float3 ViewspaceFromXY(float2 posVS_XY, float linearDepth)
{
    return float3(posVS_XY * abs(linearDepth), linearDepth);
}

#define TILE_SIZE   8

bool CapsuleIntersectsTile(CapsuleOccluderData capsuleData, uint capsuleIndex, float3 tileCenterWS, float tileRadiusWS)
{
    float3 offsetWS = capsuleData.centerRWS - tileCenterWS;

    float centerToCenterDistSq = dot(offsetWS, offsetWS);

    bool intersectsTile;
    if (capsuleIndex < _CapsuleDirectShadowCount)
    {
        float offsetDotLight = dot(offsetWS, _CapsuleLightDir);
        float absAxisDotLight = abs(dot(capsuleData.axisDirWS, _CapsuleLightDir));
        float absAxisOtherDot = sqrt(max(0.f, 1.f - absAxisDotLight*absAxisDotLight));
        float lightT = offsetDotLight + absAxisDotLight*capsuleData.offset + capsuleData.radius;   // farthest point along light axis
        float tileRadiusTowardsCapsule = tileRadiusWS + lightT*_CapsuleLightTanTheta;
        float capsuleRadiusTowardsLightAxis = absAxisOtherDot*capsuleData.offset + capsuleData.radius;
        float3 checkOffsetWS = offsetWS - offsetDotLight*_CapsuleLightDir;
        bool intersectsPenumbra = (lightT > 0.f) && (dot(checkOffsetWS, checkOffsetWS) < Sq(tileRadiusTowardsCapsule + capsuleRadiusTowardsLightAxis));

        float directRangeWS = capsuleData.offset + capsuleData.radius + _CapsuleShadowRange;
        bool intersectsRange = (centerToCenterDistSq < Sq(directRangeWS + tileRadiusWS));

        intersectsTile = intersectsPenumbra && intersectsRange;
    }
    else
    {
        float indirectRangeWS = capsuleData.offset + capsuleData.radius*(1.f + _CapsuleIndirectRangeFactor);
        intersectsTile = (centerToCenterDistSq < Sq(indirectRangeWS + tileRadiusWS));
    }
    return intersectsTile;
}

#define INVALID_NORMAL_TAG  2.f

void CapsuleShadowLoop(
    uint2 fullResCoord,
    float3 positionWS,
    uint flatThreadIndex,
    bool useSecondDepthRange,
    inout uint processedCapsuleCounter,
    inout float directVisibility,
    inout float indirectVisibility)
{
    float3 tileCenterWS0 = s_tileCenter[0];
    float tileRadiusWS0 = asfloat(s_tileRadiusU[0]);
    float3 normalWS = float3(fullResCoord.x, fullResCoord.y, INVALID_NORMAL_TAG);

    // loop over capsules in batches
    uint capsuleCount = _CapsuleDirectShadowCount + _CapsuleIndirectShadowCount;
    for (uint capsuleBaseIndex = 0; capsuleBaseIndex < capsuleCount; capsuleBaseIndex += 64)
    {
        // clear state
        if (flatThreadIndex < 2)
            s_capsuleBits[flatThreadIndex] = 0;
        GroupMemoryBarrierWithGroupSync();

        // use one thread per capsule to check against tile
        // TODO: check if any pixels still visible?
        {
            uint capsuleIndex = capsuleBaseIndex + flatThreadIndex;
            if (capsuleIndex < capsuleCount)
            {
                CapsuleOccluderData capsuleData = _CapsuleOccluderDatas[capsuleIndex];

                bool intersectsTile = CapsuleIntersectsTile(capsuleData, capsuleIndex, tileCenterWS0, tileRadiusWS0);
                if (useSecondDepthRange && !intersectsTile)
                    intersectsTile = CapsuleIntersectsTile(capsuleData, capsuleIndex, s_tileCenter[1], asfloat(s_tileRadiusU[1]));

                if (intersectsTile)
                    InterlockedOr(s_capsuleBits[flatThreadIndex/32], 1U << (flatThreadIndex % 32));
            }
        }
        GroupMemoryBarrierWithGroupSync();

        // loop over set bits to do the shading
        uint remainingBits = s_capsuleBits[0];
        if (normalWS.z == INVALID_NORMAL_TAG && (remainingBits != 0 || s_capsuleBits[1] != 0))
        {
            uint2 coord = uint2(normalWS.xy);
            float4 normalBufferData = LOAD_TEXTURE2D_X(_NormalBufferTexture, coord);

            NormalData normalData;
            DecodeFromNormalBuffer(normalBufferData, normalData);
            normalWS = normalData.normalWS;
        }
        bool secondPass = false;
        for (;;)
        {
            if (remainingBits == 0 && !secondPass)
            {
                remainingBits = s_capsuleBits[1];
                secondPass = true;
            }
            if (remainingBits == 0)
                break;

            int bitIndex = firstbitlow(remainingBits);
            remainingBits &= ~(1U << bitIndex);

            uint capsuleIndex = capsuleBaseIndex + (secondPass ? 32 : 0) + (uint)bitIndex;

            CapsuleOccluderData capsuleData = _CapsuleOccluderDatas[capsuleIndex];
            if (capsuleIndex < _CapsuleDirectShadowCount)
            {
                float occlusion = EvaluateCapsuleOcclusion(
                    GetCapsuleDirectOcclusionFlags(),
                    _CapsuleLightDir,
                    false,
                    _CapsuleLightCosTheta,
                    capsuleData.centerRWS - positionWS,
                    capsuleData.axisDirWS,
                    capsuleData.offset,
                    capsuleData.radius,
                    _CapsuleShadowRange,
                    normalWS);
                directVisibility *= max(1.f - occlusion, 0.0f);
#ifdef CAPSULE_TILE_DEBUG
                if (_CapsuleTileDebugMode == CAPSULETILEDEBUGMODE_DIRECT)
                    ++processedCapsuleCounter;
#endif
            }
            else
            {
                uint flags = CAPSULEAMBIENTOCCLUSIONMETHOD_LINE_AND_CLOSEST_SPHERE;
                float occlusion = EvaluateCapsuleAmbientOcclusion(
                    GetCapsuleAmbientOcclusionFlags(),
                    capsuleData.centerRWS - positionWS,
                    capsuleData.axisDirWS,
                    capsuleData.offset,
                    capsuleData.radius,
                    capsuleData.radius*_CapsuleIndirectRangeFactor,
                    normalWS);
                indirectVisibility *= max(1.f - occlusion, 0.f);
#ifdef CAPSULE_TILE_DEBUG
                if (_CapsuleTileDebugMode == CAPSULETILEDEBUGMODE_INDIRECT)
                    ++processedCapsuleCounter;
#endif
            }
        }
    }
}

float2 GetPositionNDC(uint2 pixelCoord, bool isHalfRes)
{
    float2 upscaledPosSS = float2(pixelCoord) + .5f;
    if (isHalfRes) {
        upscaledPosSS *= 2.f;
    }
    return upscaledPosSS * _CapsuleUpscaledSize.zw;
}

[numthreads(TILE_SIZE,TILE_SIZE,1)]
void Main(uint3 dispatchThreadId : SV_DispatchThreadID, uint flatThreadIndex : SV_GroupIndex)
{
    uint2 pixelCoord = dispatchThreadId.xy;
    UNITY_XR_ASSIGN_VIEW_INDEX(dispatchThreadId.z);

    bool isHalfRes = _CapsuleShadowIsHalfRes;

    // would like to load half res depth, but get shading errors when the depth doesn't match the normal
    float deviceDepth = LOAD_TEXTURE2D_X(_CameraDepthTexture, pixelCoord + (isHalfRes ? _FirstDepthMipOffset : 0)).x;
    bool is_sky = (deviceDepth == UNITY_RAW_FAR_CLIP_VALUE);

    float2 upscaledPosNDC = GetPositionNDC(pixelCoord, isHalfRes);
    float4 positionCS = ComputeClipSpacePosition(upscaledPosNDC, deviceDepth);

    // TODO: handle orthographic/oblique
    float4x4 invProj = UNITY_MATRIX_I_P;
    float linearDepth = invProj._m23/(invProj._m32 * positionCS.z + invProj._m33);
    float2 viewFromClipScale = float2(invProj._m00, invProj._m11);
    float2 viewFromClipOffset = float2(invProj._m03, invProj._m13);
    float2 fullResPixelHalfExtentAtUnitDepth = abs(viewFromClipScale*_CapsuleUpscaledSize.zw);

    float2 positionVS_XY = viewFromClipScale*positionCS.xy + viewFromClipOffset;
    float3 positionWS = TransformViewToWorld(ViewspaceFromXY(positionVS_XY, linearDepth));

    uint2 fullResCoord = pixelCoord;
    if (isHalfRes) {
        fullResCoord = fullResCoord*2 + ((asuint(deviceDepth) >> uint2(0, 1)) & 1);
    }

    // TODO: handle scaled view matrix?
    float absWorldFromViewScale = 1.f;

    if (flatThreadIndex < DEPTH_RANGE_COUNT)
    {
        s_depthMinU[flatThreadIndex] = DEPTH_MIN_EMPTY;
        s_depthMaxU[flatThreadIndex] = DEPTH_MAX_EMPTY;
        s_tileRadiusU[flatThreadIndex] = 0;
    }
    GroupMemoryBarrierWithGroupSync();

    if (!is_sky)
    {
        float depth = max(0.f, PACK_UNPACK_POSITIVE_DEPTH(linearDepth));
        InterlockedMin(s_depthMinU[0], asuint(depth));
        InterlockedMax(s_depthMaxU[1], asuint(depth));
    }
    GroupMemoryBarrierWithGroupSync();

    // early out if tile is all far clip
    if (s_depthMinU[0] == DEPTH_MIN_EMPTY)
    {
#ifdef CAPSULE_TILE_DEBUG
        if (flatThreadIndex == 0)
            _CapsuleTileDebug[COORD_TEXTURE2D_X(pixelCoord/8)] = 0;
#endif
        return;
    }

    // split the depth range at the midpoint
    if (!is_sky)
    {
        float mid = .5f*(asfloat(s_depthMinU[0]) + asfloat(s_depthMaxU[1]));
        float depth = max(0.f, PACK_UNPACK_POSITIVE_DEPTH(linearDepth));
        if (depth < mid)
            InterlockedMax(s_depthMaxU[0], asuint(depth));
        else
            InterlockedMin(s_depthMinU[1], asuint(depth));
    }
    GroupMemoryBarrierWithGroupSync();
    if (flatThreadIndex == 0)
    {
        uint depthMinU0 = s_depthMinU[0];
        uint depthMinU1 = s_depthMinU[1];
        uint depthMaxU0 = s_depthMaxU[0];
        uint depthMaxU1 = s_depthMaxU[1];

        // handle empty region either side of the split
        if (depthMaxU0 == DEPTH_MAX_EMPTY)
            depthMaxU0 = depthMinU0;
        if (depthMinU1 == DEPTH_MIN_EMPTY)
            depthMinU1 = depthMaxU1;

        // revert back to a single depth range if we don't skip much space (for performance)
        float totalDepthRange = asfloat(depthMaxU1) - asfloat(depthMinU0);
        float skipDepthRange = asfloat(depthMinU1) - asfloat(depthMaxU0);
        float tileSizeAtUnitDepth = TILE_SIZE*(isHalfRes ? 2 : 1)*MaxElement(fullResPixelHalfExtentAtUnitDepth);
        float tileSizeAtMaxDepth = tileSizeAtUnitDepth*asfloat(depthMaxU1);
        if (!_CapsuleSplitDepthRange || skipDepthRange < tileSizeAtMaxDepth || skipDepthRange < .2f*totalDepthRange)
        {
            depthMaxU0 = depthMaxU1;
            depthMinU1 = depthMinU0;
        }

        s_depthMinU[0] = depthMinU0;
        s_depthMinU[1] = depthMinU1;
        s_depthMaxU[0] = depthMaxU0;
        s_depthMaxU[1] = depthMaxU1;
    }
    GroupMemoryBarrierWithGroupSync();

    // TODO: splitting planes for froxel
    // TODO: move work to setup pass to run as one tile per thread
    // TODO: save/restore to LDS each pass to free up registers
    if (flatThreadIndex < 2)
    {
        float nearLinearDepth = PACK_UNPACK_POSITIVE_DEPTH(asfloat(s_depthMinU[flatThreadIndex]));
        float farLinearDepth = PACK_UNPACK_POSITIVE_DEPTH(asfloat(s_depthMaxU[flatThreadIndex]));
        float midLinearDepth = 0.5f*(nearLinearDepth + farLinearDepth);
        s_tileCenter[flatThreadIndex] = ViewspaceFromXY(positionVS_XY, midLinearDepth);
    }

    // get bounding sphere radius
    {
        // check one corner on each thread
        uint depthRangeIndex = flatThreadIndex & 1;
        uint cornerIndex = flatThreadIndex / 2;
        float cornerLinearDepth0 = PACK_UNPACK_POSITIVE_DEPTH(asfloat(s_depthMinU[depthRangeIndex]));
        float cornerLinearDepth1 = PACK_UNPACK_POSITIVE_DEPTH(asfloat(s_depthMaxU[depthRangeIndex]));
        if (cornerIndex < 8)
        {
            float2 tileHalfExtentAtUnitDepth = TILE_SIZE*(isHalfRes ? 2 : 1)*fullResPixelHalfExtentAtUnitDepth;
            float2 cornerVS_XY
                = positionVS_XY
                + float2((cornerIndex & 1) != 0 ? 1.f : -1.f, (cornerIndex & 2) != 0 ? 1.f : -1.f)*tileHalfExtentAtUnitDepth;
            float cornerLinearDepth = ((cornerIndex & 4) != 0 ? cornerLinearDepth1 : cornerLinearDepth0);
            float3 offsetVS = ViewspaceFromXY(cornerVS_XY, cornerLinearDepth) - s_tileCenter[depthRangeIndex];
            float tileRadiusWS = sqrt(dot(offsetVS, offsetVS)) * absWorldFromViewScale;
            InterlockedMax(s_tileRadiusU[depthRangeIndex], asuint(tileRadiusWS));
        }
    }
    GroupMemoryBarrierWithGroupSync();

    // move the sphere center to world space
    if (flatThreadIndex < 2)
        s_tileCenter[flatThreadIndex] = TransformViewToWorld(s_tileCenter[flatThreadIndex]);
    GroupMemoryBarrierWithGroupSync();

    // optimise the loop separately depending on whether we are using one or two depth ranges
    float directVisibility = 1.f, indirectVisibility = 1.f;
    uint processedCapsuleCounter = 0;
    bool useSecondDepthRange = (s_depthMinU[0] != s_depthMinU[1] || s_depthMaxU[0] != s_depthMaxU[1]);
#ifdef CAPSULE_TILE_DEBUG
    if (_CapsuleTileDebugMode == CAPSULETILEDEBUGMODE_DEPTH_RANGE)
        processedCapsuleCounter = useSecondDepthRange ? 16 : 4;
#endif
    [branch]
    if (useSecondDepthRange)
        CapsuleShadowLoop(fullResCoord, positionWS, flatThreadIndex, true, processedCapsuleCounter, directVisibility, indirectVisibility);
    else
        CapsuleShadowLoop(fullResCoord, positionWS, flatThreadIndex, false, processedCapsuleCounter, directVisibility, indirectVisibility);

    // write results
    _CapsuleShadowsRenderOutput[COORD_TEXTURE2D_X(pixelCoord)] = float2(PackCapsuleVisibility(directVisibility), PackCapsuleVisibility(indirectVisibility));
#ifdef CAPSULE_TILE_DEBUG
    if (flatThreadIndex == 0)
        _CapsuleTileDebug[COORD_TEXTURE2D_X(pixelCoord/8)] = processedCapsuleCounter;
#endif
}
