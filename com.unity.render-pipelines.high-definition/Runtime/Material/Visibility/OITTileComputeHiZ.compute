#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Visibility/VisibilityOITResources.hlsl"

//#pragma enable_d3d11_debug_symbols

#pragma kernel MainInitialize
#pragma kernel MainTileComputeHiZ

#define GROUP_SIZE 8

#if defined(USE_TEXTURE2D_X_AS_ARRAY)
RWTexture2DArray<float2> _OITTileHiZOutput;
#else
RWTexture2D<float2> _OITTileHiZOutput;
#endif

uint4 _SrcOffsetAndLimit;
uint4 _DstOffset;

float4 _VBufferLightingOffscreenParams;

uint GetOffscreenLightBufferWidth()
{
    return asuint(_VBufferLightingOffscreenParams.x);
}

// PlaneLineIntersection
//      p:          Line starting point
//      dir:        Line direction (normalized)
//      plane_p0:   point on plane
//      plane_n:    plane normal
//
//      hitDistance: distance from 'p' with the direction 'dir'
bool PlaneLineIntersection(float3 p, float3 dir, float3 plane_p0, float3 plane_n, out float hitDistance)
{
    const float epsilon = 1e-6f;

    if (abs(dot(dir, plane_n)) < epsilon)
    {
        hitDistance = -1e6f;
        return false;
    }

    hitDistance = (dot(plane_n, plane_p0) - dot(plane_n, p)) / dot(plane_n, dir);
    // hitPoint = p + hitDistance * dir;

    return true;
}

// Build a plane from center of froxel and
//  intersect with 4 columns of this froxel (4 differents view direction from each corner of the pixel footprint)
// Assumption: pixelSize == 1x1
float2 GetPixelMinMax(float linearDepth, float3 normal)
{
    const float3 zero = float3(0.0f, 0.0f, 0.0f);

    float3 center = float3(0.0f, 0.0f, linearDepth);

    float3 corner11 = float3( 0.5f,  0.5f, linearDepth);
    float3 corner01 = float3(-0.5f,  0.5f, linearDepth);
    float3 corner00 = float3(-0.5f, -0.5f, linearDepth);
    float3 corner10 = float3( 0.5f, -0.5f, linearDepth);

    float3 w0 = normalize(corner11);
    float3 w1 = normalize(corner01);
    float3 w2 = normalize(corner00);
    float3 w3 = normalize(corner10);

    float hitZ0;
    float hitZ1;
    float hitZ2;
    float hitZ3;
    bool hit0 = PlaneLineIntersection(zero, w0, center, normal, hitZ0);
    bool hit1 = PlaneLineIntersection(zero, w1, center, normal, hitZ1);
    bool hit2 = PlaneLineIntersection(zero, w2, center, normal, hitZ2);
    bool hit3 = PlaneLineIntersection(zero, w3, center, normal, hitZ3);

    //if (!hit0 || !hit1 || !hit2 || !hit3)
    //{
    //    return float2(0.0f, 0.0f);
    //}

    float2 minMax;

    minMax.x = min(min(hitZ0, hitZ1), min(hitZ2, hitZ3));
    minMax.y = max(max(hitZ0, hitZ1), max(hitZ2, hitZ3));

    return minMax;
}

[numthreads(GROUP_SIZE, GROUP_SIZE, 1)]
void MainInitialize(int3 dispatchThreadID : SV_DispatchThreadID)
{
    UNITY_XR_ASSIGN_VIEW_INDEX(dispatchThreadID.z);

    if (any((float2)dispatchThreadID.xy > _ScreenSize.xy))
    {
        return;
    }

    PositionInputs posInputs = GetPositionInput(float2(dispatchThreadID.xy), _ScreenSize.zw, uint2(GROUP_SIZE, GROUP_SIZE));

    uint pixelOffset = posInputs.positionSS.y * _ScreenSize.x + posInputs.positionSS.x;
    uint listCount, listOffset;
    VisibilityOIT::GetPixelList(pixelOffset, listCount, listOffset);
    if (listCount == 0)
    {
        _OITTileHiZOutput[COORD_TEXTURE2D_X(dispatchThreadID.xy)] = float2(UNITY_RAW_FAR_CLIP_VALUE, UNITY_RAW_FAR_CLIP_VALUE);

        return;
    }

    float minDepth =  1e7f;
    float maxDepth = -1e7f;

    for (uint i = 0; i < listCount; ++i)
    {
        int globalOffset = i + listOffset;
        uint2 offscreenCoord = uint2(globalOffset % GetOffscreenLightBufferWidth(), globalOffset / GetOffscreenLightBufferWidth());

        Visibility::VisibilityData unusedVisData;
        uint2 unusedTexelCoord;
        float linearDepth;
        VisibilityOIT::GetVisibilitySampleWithLinearDepth(i, listOffset, unusedVisData, unusedTexelCoord, linearDepth);

        uint4 packedOITGBuffer0 = _VisOITOffscreenGBuffer0[COORD_TEXTURE2D_X(offscreenCoord)].rgba;
        float3 normal;
        VisibilityOIT::UnpackOITNormalFromGBufferData0(packedOITGBuffer0, normal);

        float2 minMax = GetPixelMinMax(linearDepth, normal);

        //minDepth = min(linearDepth, minDepth);
        //maxDepth = max(linearDepth, maxDepth);
        minDepth = min(minMax.x, minDepth);
        maxDepth = max(minMax.y, maxDepth);
    }

    _OITTileHiZOutput[COORD_TEXTURE2D_X(dispatchThreadID.xy)] = float2(minDepth, maxDepth);
}

[numthreads(GROUP_SIZE, GROUP_SIZE, 1)]
void MainTileComputeHiZ(int3 dispatchThreadID : SV_DispatchThreadID)
{
    UNITY_XR_ASSIGN_VIEW_INDEX(dispatchThreadID.z);

    uint2 srcLimit = _SrcOffsetAndLimit.zw;

    //if (any(dispatchThreadID.xy >= (int2)(2.0f*srcLimit.xy)))
    //    return;

    uint2 srcOffset = _SrcOffsetAndLimit.xy;
    uint2 dstOffset = _DstOffset.xy;

    //float minDepth = 1.0f;
    //float maxDepth = 0.0f;

    float minDepth =  1e7f;
    float maxDepth = -1e7f;

    uint2 srcPixel = srcOffset + (dispatchThreadID.xy << 1);

    // TODO: Replace this loop by GatherRed, GatherGreen
    UNITY_UNROLL
    for (int i = 0; i < 2; ++i)
    {
        UNITY_UNROLL
        for (int j = 0; j < 2; ++j)
        {
            float2 minMax = _OITTileHiZOutput[COORD_TEXTURE2D_X(min(srcPixel + uint2(i, j), srcLimit))].xy;

            minDepth = min(minMax.x, minDepth);
            maxDepth = max(minMax.y, maxDepth);
        }
    }

    _OITTileHiZOutput[COORD_TEXTURE2D_X(dstOffset + dispatchThreadID.xy)] = float2(minDepth, maxDepth);
}
