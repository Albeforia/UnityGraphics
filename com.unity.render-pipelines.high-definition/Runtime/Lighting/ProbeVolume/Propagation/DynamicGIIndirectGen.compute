
#pragma enable_d3d11_debug_symbols

#pragma kernel IndirectArgGen
//#pragma kernel DivideByGroupSize

#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/ProbeVolume/Propagation/APVDynamicGICommon.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/EntityLighting.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinGIUtilities.hlsl"
#include "Packages/com.unity.render-pipelines.core/Runtime/Lighting/ProbeVolume/ProbeVolume.hlsl"

#define GROUP_SIZE 64

// First 3 args are for hits, second 3 for miss
RWBuffer<uint> _IndirectArgsBuffer;

#define HIT_INDIRECT_OFFSET 0
#define MISS_INDIRECT_OFFSET 3

AppendStructuredBuffer<uint3> _HitList;
AppendStructuredBuffer<uint3> _MissList;

float4 _DynamicGIIndirectGen;

#define _ProbeCount _DynamicGIIndirectGen.x
#define _LeakMultiplier _DynamicGIIndirectGen.y
#define _MinValidNeighbourDist _DynamicGIIndirectGen.z

StructuredBuffer<uint2>  _PackedProbeExtraData;
StructuredBuffer<float> _ProbeValidity;

// Here we try to split into three groups
//  - Completely scaled to 0 because invalidity (only happens with leak scale is 1)
//  - probe/axis couple has a hit -> list with a lightloop
//  - probe/axis has not a hit -> list with just APV sampling
// The first group directly write zero into the irradiance cache
// Other two have lists for the indirect dispatch.

// As of extra data we output a uint3 per probe/axis couple

//  - extraData packed into the original uint2
//    probeIndex + validity + axisIndex into another uint {19, 8, 5}


uint PackOutput(uint probeIndex, uint axisIndex, float validityScale)
{
    uint packedOutput = 0;
    packedOutput |= (axisIndex << 0);
    packedOutput |= ((uint)(validityScale * 255.5f) << 5);
    packedOutput |= (probeIndex << 13);

    return packedOutput;
}

// Note: can be further optimized ( to minimize interlock adds for example ). However since this is run once only, I prefer simplicity over performance.

[numthreads(GROUP_SIZE, 1, 1)]
void IndirectArgGen(uint3 id : SV_DispatchThreadID, uint3 groupThreadID : SV_GroupThreadID)
{
    uint probeIndex = id.x;

    if (probeIndex < _ProbeCount)
    {
        float probeValidity = _ProbeValidity[probeIndex];
        float invalidScale = (1.0f - lerp(0.0f, _LeakMultiplier, probeValidity));

        if (invalidScale > 0)
        {
            for (int i = 0; i < AXIS_COUNT; ++i)
            {
                uint extraDataIndex = probeIndex * AXIS_COUNT + i;
                uint2 extraData = _PackedProbeExtraData[extraDataIndex];

                uint3 outputData = uint3(extraData, PackOutput(probeIndex, i, invalidScale));

                float distToHit = ((extraData.x >> 24) & 255) / 255.0f;
                bool hasAHit = distToHit > _MinValidNeighbourDist;

                if (hasAHit)
                {
                    _HitList.Append(outputData);
                    InterlockedAdd(_IndirectArgsBuffer[HIT_INDIRECT_OFFSET], 1);
                }
                else
                {
                    _MissList.Append(outputData);
                    InterlockedAdd(_IndirectArgsBuffer[MISS_INDIRECT_OFFSET], 1);
                }
            }
        }
    }
}
