#pragma kernel InitializePropagationAxis
#define GROUP_SIZE 64
//#pragma enable_d3d11_debug_symbols

#pragma multi_compile BASIS_SPHERICAL_GAUSSIAN BASIS_SPHERICAL_GAUSSIAN_WINDOWED BASIS_AMBIENT_DICE_SHARP BASIS_AMBIENT_DICE_SOFTER BASIS_AMBIENT_DICE_SUPER_SOFT BASIS_AMBIENT_DICE_ULTRA_SOFT
#pragma multi_compile BASIS_PROPAGATION_OVERRIDE_NONE BASIS_PROPAGATION_OVERRIDE_SPHERICAL_GAUSSIAN BASIS_PROPAGATION_OVERRIDE_AMBIENT_DICE_WRAPPED_SOFTER BASIS_PROPAGATION_OVERRIDE_AMBIENT_DICE_WRAPPED_SUPER_SOFT BASIS_PROPAGATION_OVERRIDE_AMBIENT_DICE_WRAPPED_ULTRA_SOFT
#pragma multi_compile _ RADIANCE_ENCODING_LOGLUV RADIANCE_ENCODING_HALFLUV RADIANCE_ENCODING_R11G11B10

#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/ProbeVolume/DynamicGI/ProbeVolumeDynamicGI.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/EntityLighting.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/CommonLighting.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Sampling/Hammersley.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Sampling/Sampling.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/ProbeVolume/DynamicGI/ProbePropagationGlobals.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/ProbeVolume/DynamicGI/ProbeVolumeSphericalHarmonicsLighting.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/ProbeVolume/DynamicGI/ProbePropagationBasis.hlsl"

StructuredBuffer<float> _ProbeVolumeAtlasReadSHL01Buffer;
StructuredBuffer<float> _ProbeVolumeAtlasReadSHL2Buffer;
StructuredBuffer<float> _ProbeVolumeAtlasReadValidityBuffer;
RWTexture3D<float4> _ProbeVolumeAtlasWriteTextureSH;

uint _ProbeVolumeAtlasReadBufferCount;
float3 _ProbeVolumeResolution;
float3 _ProbeVolumeAtlasBias;
float4 _ProbeVolumeAtlasResolutionAndSliceCount;
float3 _ProbeVolumeAtlasSHRotateRight;
float3 _ProbeVolumeAtlasSHRotateUp;
float3 _ProbeVolumeAtlasSHRotateForward;

float3 _ProbeVolumeDGIBoundsRight;
float3 _ProbeVolumeDGIBoundsUp;

RWStructuredBuffer<RADIANCE> _RadianceCacheAxis;
int _RadianceCacheAxisCount;
float _BakedLightingContribution;
float _DynamicPropagationContribution;
float4 _RayAxis[NEIGHBOR_AXIS_COUNT];

float _Sharpness;

SHOutgoingRadiosityWithProjectedConstantsPacked ReadBakedSH(uint readIndex)
{
    SHOutgoingRadiosityWithProjectedConstantsPacked outgoingRadiosity;

    const uint SH_STRIDE_L01 = 4 * 3;
    const uint SH_STRIDE_L2 = (9 * 3) - SH_STRIDE_L01;

    outgoingRadiosity.data[0] = float4(
        _ProbeVolumeAtlasReadSHL01Buffer[readIndex * SH_STRIDE_L01 + 0], // shAr.w
        _ProbeVolumeAtlasReadSHL01Buffer[readIndex * SH_STRIDE_L01 + 1], // shAg.w
        _ProbeVolumeAtlasReadSHL01Buffer[readIndex * SH_STRIDE_L01 + 2], // shAb.w
        _ProbeVolumeAtlasReadSHL01Buffer[readIndex * SH_STRIDE_L01 + 3]  // shAr.x
    );
    outgoingRadiosity.data[1] = float4(
        _ProbeVolumeAtlasReadSHL01Buffer[readIndex * SH_STRIDE_L01 + 4], // shAr.y
        _ProbeVolumeAtlasReadSHL01Buffer[readIndex * SH_STRIDE_L01 + 5], // shAr.z
        _ProbeVolumeAtlasReadSHL01Buffer[readIndex * SH_STRIDE_L01 + 6], // shAg.x
        _ProbeVolumeAtlasReadSHL01Buffer[readIndex * SH_STRIDE_L01 + 7]  // shAg.y
    );
    outgoingRadiosity.data[2] = float4(
        _ProbeVolumeAtlasReadSHL01Buffer[readIndex * SH_STRIDE_L01 + 8], // shAg.z
        _ProbeVolumeAtlasReadSHL01Buffer[readIndex * SH_STRIDE_L01 + 9], // shAb.x
        _ProbeVolumeAtlasReadSHL01Buffer[readIndex * SH_STRIDE_L01 + 10], // shAb.y
        _ProbeVolumeAtlasReadSHL01Buffer[readIndex * SH_STRIDE_L01 + 11]  // shAb.z
    );
    outgoingRadiosity.data[3] = float4(
        _ProbeVolumeAtlasReadSHL2Buffer[readIndex * SH_STRIDE_L2 + 0], // shBr.x
        _ProbeVolumeAtlasReadSHL2Buffer[readIndex * SH_STRIDE_L2 + 1], // shBr.y
        _ProbeVolumeAtlasReadSHL2Buffer[readIndex * SH_STRIDE_L2 + 2], // shBr.z
        _ProbeVolumeAtlasReadSHL2Buffer[readIndex * SH_STRIDE_L2 + 3]  // shBr.w
    );
    outgoingRadiosity.data[4] = float4(
        _ProbeVolumeAtlasReadSHL2Buffer[readIndex * SH_STRIDE_L2 + 4], // shBg.x
        _ProbeVolumeAtlasReadSHL2Buffer[readIndex * SH_STRIDE_L2 + 5], // shBg.y
        _ProbeVolumeAtlasReadSHL2Buffer[readIndex * SH_STRIDE_L2 + 6], // shBg.z
        _ProbeVolumeAtlasReadSHL2Buffer[readIndex * SH_STRIDE_L2 + 7]  // shBg.w
    );
    outgoingRadiosity.data[5] = float4(
        _ProbeVolumeAtlasReadSHL2Buffer[readIndex * SH_STRIDE_L2 + 8], // shBb.x
        _ProbeVolumeAtlasReadSHL2Buffer[readIndex * SH_STRIDE_L2 + 9], // shBb.y
        _ProbeVolumeAtlasReadSHL2Buffer[readIndex * SH_STRIDE_L2 + 10], // shBb.z
        _ProbeVolumeAtlasReadSHL2Buffer[readIndex * SH_STRIDE_L2 + 11]  // shBb.w
    );
    outgoingRadiosity.data[6] = float4(
        _ProbeVolumeAtlasReadSHL2Buffer[readIndex * SH_STRIDE_L2 + 12], // shCr.x
        _ProbeVolumeAtlasReadSHL2Buffer[readIndex * SH_STRIDE_L2 + 13], // shCr.y
        _ProbeVolumeAtlasReadSHL2Buffer[readIndex * SH_STRIDE_L2 + 14], // shCr.z
        0.0
    );

    return outgoingRadiosity;
}

float3 ProbeVolumeEvaluateIncomingRadiance(SHIncomingIrradiance shIncomingIrradiance, float3 directionWS)
{
    float3 incomingRadiance = IncomingRadianceCompute(shIncomingIrradiance, directionWS);

    // Values can be negative due to ringing. Clip off negative values.
    incomingRadiance = max(0.0, incomingRadiance);

    return incomingRadiance;
}

float Halton(uint index, uint radix)
{
    float result = 0.0;
    float fraction = 1.0 / (float)radix;

    while (index > 0)
    {
        result += (index % radix) * fraction;

        index /= radix;
        fraction /= radix;
    }

    return result;
}

float3 ComputeDirectionFromHalton(uint i)
{
    float2 halton = float2(Halton(i, 2u), Halton(i, 3u));
    
    float theta = halton.x * 2.0 * PI;
    float z = -(halton.y * 2.0 - 1.0);
    float r = sqrt(1.0 - z * z);

    float3 sampleDirection = float3(
        r * cos(theta),
        r * sin(theta),
        z
    );
    
    return sampleDirection;
}

void ComputeProbeBasisFromSHSamplePeaks(SHIncomingIrradiance shIncomingIrradiance, float3x3 probeVolumeLtw, int readIndex)
{
    for (int i = 0; i < NEIGHBOR_AXIS_COUNT; ++i)
    {
        BasisAxisHit basisAxisHit = ComputeBasisAxisHit(_RayAxis[i].xyz, _Sharpness);
        float3 basisAxisHitDirectionWS = mul(basisAxisHit.mean, probeVolumeLtw);
        float3 incomingHitRadiance = ProbeVolumeEvaluateIncomingRadiance(shIncomingIrradiance, basisAxisHitDirectionWS);
        incomingHitRadiance *= basisAxisHit.amplitude;

        _RadianceCacheAxis[i * _ProbeVolumeAtlasReadBufferCount + readIndex] = EncodeRadiance(incomingHitRadiance);
    }
}

void ComputeProbeBasisFromSHZHFit(SHIncomingIrradiance shIncomingIrradiance, float3x3 probeVolumeLtw, int readIndex)
{
    for (int i = 0; i < NEIGHBOR_AXIS_COUNT; ++i)
    {
        BasisAxisHit basisAxisHit = ComputeBasisAxisHit(_RayAxis[i].xyz, _Sharpness);

        // Because convolution in SH space is cheap (zonal harmonic window component-wise multiplication), we are able to
        // more accurately capture the integral of incoming irradiance over the hit basis solid angle + weight.
        // It's important to note that this is an approximation - because our hit axis lobe is not a zonal harmonic - it is an SG or AmbientDice lobe,
        // but it can be approximately represented as an ZH.
        float3 basisAxisHitDirectionWS = mul(basisAxisHit.mean, probeVolumeLtw);
        ZHWindow basisAxisHitZHWindow = ComputeZHWindowFromBasisAxisHit(basisAxisHit);
        SHIncomingIrradianceConvolveZHWindowWithoutDeltaFunction(shIncomingIrradiance, basisAxisHitZHWindow);
        float3 incomingHitRadiance = ProbeVolumeEvaluateIncomingRadiance(shIncomingIrradiance, basisAxisHitDirectionWS);

        // ComputeZHWindowFromBasisAxisHit() returns a normalized (amplitude == 1) window.
        // We need to scale down the radiance by the actual amplitude of the window to complete the projection.
        incomingHitRadiance *= basisAxisHit.amplitude;

        _RadianceCacheAxis[i * _ProbeVolumeAtlasReadBufferCount + readIndex] = EncodeRadiance(incomingHitRadiance);
    }
}

void ComputeProbeBasisFromSHMonteCarloNaiveProjection(SHIncomingIrradiance shIncomingIrradiance, float3x3 probeVolumeLtw, int readIndex)
{
#define IMPORTANCE_SAMPLING_ENABLED
#if !defined(IMPORTANCE_SAMPLING_ENABLED)
    const int SAMPLE_COUNT = 8192;
#else
    const int SAMPLE_COUNT = 32;
#endif
    const float SAMPLE_COUNT_INVERSE = 1.0 / float(SAMPLE_COUNT);
    // float GOLDEN_ANGLE = PI * (3.0 - sqrt(5.0));
    float GOLDEN_ANGLE_HALF = GOLDEN_ANGLE * 0.5;
    const float SOLID_ANGLE_SPHERE = 4.0 * PI;

    for (int i = 0; i < NEIGHBOR_AXIS_COUNT; ++i)
    {
        BasisAxisHit basisAxisHit = ComputeBasisAxisHit(_RayAxis[i].xyz, _Sharpness);
        float3 basisAxisHitDirectionWS = mul(basisAxisHit.mean, probeVolumeLtw);
        basisAxisHit.mean = basisAxisHitDirectionWS;

        float3 incomingHitRadiance = 0.0;

        // Importance sample basis lobe by remapping samples into a cone that approximately matches the solid angle of the basis.
        // https://www.shadertoy.com/view/wlB3Wt
        //
        // solidAngleOfCone = 2 * PI * (1 - cosTheta) // note cosTheta is half angle
        // 1.0 / (1 - cosTheta) = 2 * PI / solidAngleOfCone
        // 1 - cosTheta = solidAngleOfCone / (2 * PI)
        // -cosTheta + 1 = solidAngleOfCone / (2 * PI)
        // -cosTheta = solidAngleOfCone / (2 * PI) - 1
        // cosTheta = -solidAngleOfCone / (2 * PI) + 1
        // solidAngleOfSG = integralOfSG = float b = 2.0 * PI / sharpness; return exp(-2.0 * sharpness) * -b + b;

#if !defined(IMPORTANCE_SAMPLING_ENABLED)
        float solidAngleBasis = 4.0 * PI;
#else
        // In order to derive the approximate solid angle, we need the normalized integral (the integral where the peak is 1, not amplitude)
        // The lerp towards 2.0 * PI is an adhoc lerp to get more coverage. Must be tuned for the specific basis being used.
        // With Ambient Dice, using the integral as the solid angle to extract cone coverage is not conservative enough.
        float solidAngleBasis = lerp(ComputeBasisAxisHitIntegral(basisAxisHit) / basisAxisHit.amplitude, 2.0 * PI, 0.25);
        float3x3 basisAxisHitLocalToWorld = GetLocalFrame(basisAxisHit.mean);
#endif
        float cosThetaMaxRatio = solidAngleBasis / SOLID_ANGLE_SPHERE;

        for (int sampleIndex = 0; sampleIndex < SAMPLE_COUNT; ++sampleIndex)
        {
            float3 sampleDirectionWS;
            {
                float offset = (float)sampleIndex + 0.5;
                float theta = offset * GOLDEN_ANGLE + GOLDEN_ANGLE_HALF;
                float z = -(offset * SAMPLE_COUNT_INVERSE * cosThetaMaxRatio * 2.0 - 1.0);
                float r = sqrt(1.0 - z * z);

                float3 sampleDirectionBasisOS = float3(
                    r * cos(theta),
                    r * sin(theta),
                    z
                );               
#if defined(IMPORTANCE_SAMPLING_ENABLED)    
                sampleDirectionWS = mul(sampleDirectionBasisOS, basisAxisHitLocalToWorld);
#else
                sampleDirectionWS = sampleDirectionBasisOS; // No rotation necessary, we are sampling the whole sphere.
#endif
            }

            float differentialArea = solidAngleBasis * SAMPLE_COUNT_INVERSE;
            
            float3 sampleIncomingRadiance = ProbeVolumeEvaluateIncomingRadiance(shIncomingIrradiance, sampleDirectionWS);

            incomingHitRadiance += sampleIncomingRadiance * differentialArea * ComputeBasisAxisHitEvaluateFromDirection(basisAxisHit, sampleDirectionWS);
        }

        _RadianceCacheAxis[i * _ProbeVolumeAtlasReadBufferCount + readIndex] = EncodeRadiance(incomingHitRadiance);
    }
}

void ComputeProbeBasisFromSHMonteCarloProgressiveLeastSquares(SHIncomingIrradiance shIncomingIrradiance, float3x3 probeVolumeLtw, int readIndex)
{
    // Progressive Least-Squares Encoding for Linear Bases
    // https://jcgt.org/published/0009/01/02/
    const float ACCELERATION = 1.0; // A value between 1 and 5 is reasonable.
    const int SAMPLE_COUNT = 1024;
    const float SAMPLE_COUNT_INVERSE = 1.0 / (float)SAMPLE_COUNT;
    const bool NON_NEGATIVE_SOLVE = true;
    const bool GAUSS_SEIDEL_ITERATION = true;
    float3 coefficients[NEIGHBOR_AXIS_COUNT];
    float monteCarloIntegrals[NEIGHBOR_AXIS_COUNT];
    float totalSampleWeight = 0.0;
    
    for (int i = 0; i < NEIGHBOR_AXIS_COUNT; ++i)
    {
        coefficients[i] = 0.0;
        monteCarloIntegrals[i] = 0.0;
    }

    for (int sampleIndex = 0; sampleIndex < SAMPLE_COUNT; ++sampleIndex)
    {
        // Progressive Least-Squares must use a progressive sampling sequence to be effective. Halton works well here. Non-progressive sequences like Hammersley do not.
        float3 sampleDirectionWS = ComputeDirectionFromHalton((uint)sampleIndex + 1u);

        float3 sampleIncomingRadiance = ProbeVolumeEvaluateIncomingRadiance(shIncomingIrradiance, sampleDirectionWS);

        float differentialArea = 4.0 * PI * SAMPLE_COUNT_INVERSE;

        float sampleWeight = differentialArea;

        totalSampleWeight += sampleWeight;
        float sampleWeightScale = 1.0 / totalSampleWeight;
        float3 delta = sampleIncomingRadiance;
        float sampleLobeWeights[NEIGHBOR_AXIS_COUNT];

        for (int axisIndex = 0; axisIndex < NEIGHBOR_AXIS_COUNT; ++axisIndex)
        {
            BasisAxisHit basisAxisHit = ComputeBasisAxisHit(_RayAxis[axisIndex].xyz, _Sharpness);
            float3 basisAxisHitDirectionWS = mul(basisAxisHit.mean, probeVolumeLtw);
            basisAxisHit.mean = basisAxisHitDirectionWS;
            
            float weight = ComputeBasisAxisHitEvaluateFromDirection(basisAxisHit, sampleDirectionWS);
            delta -= coefficients[axisIndex] * weight;
            sampleLobeWeights[axisIndex] = weight;
        }

        for (axisIndex = 0; axisIndex < NEIGHBOR_AXIS_COUNT; ++axisIndex)
        {
            float weight = sampleLobeWeights[axisIndex];
            float integralGuess = weight * weight;
            monteCarloIntegrals[axisIndex] += (integralGuess - monteCarloIntegrals[axisIndex]) * sampleWeightScale;
            float basisIntegral = sampleWeightScale + (1.0 - sampleWeightScale) * monteCarloIntegrals[axisIndex];
            float deltaScale = ACCELERATION * weight * sampleWeightScale / basisIntegral;
            coefficients[axisIndex] += delta * deltaScale;
            
            if (NON_NEGATIVE_SOLVE)
            {
                coefficients[axisIndex] = max(0.0, coefficients[axisIndex]);
            }
            
            if (GAUSS_SEIDEL_ITERATION)
            {
                delta *= 1.0 - deltaScale * weight;
            }
        }
    }

    for (i = 0; i < NEIGHBOR_AXIS_COUNT; ++i)
    {
        _RadianceCacheAxis[i * _ProbeVolumeAtlasReadBufferCount + readIndex] = EncodeRadiance(coefficients[i]);
    }    
}

#define BASIS_FROM_SH_MODE_MONTE_CARLO_NAIVE_PROJECTION (0)
#define BASIS_FROM_SH_MODE_MONTE_CARLO_PROGRESSIVE_LEAST_SQUARES (1)
#define BASIS_FROM_SH_MODE_SAMPLE_PEAKS (2)
#define BASIS_FROM_SH_MODE_ZH_FIT (3)

// Sample Peaks turns out to be better than ZH Fit in practice for our combination of basis and SH order.
// This is due to our basis lobes being significantly sharper than the frequency our SH L2 order can represent.
// So simply single sampling the SH from the peak of a lobe is a reasonable approximation for the entire solid angle of the lobe.
// ZH Fit futher convolves the SH to attempt to better capture a lobe's solid angle within a single sample direction, but again,
// its not really needed, requires extra instuctions, and results in extra blur.
// This is not the case when going in the other direction: basis->SH.
// When going from our radial basis to an SH, the ZH approximation is significantly better than sampling the peaks, because the
// radial basis is sharper than the spherical harmonic.
#define BASIS_FROM_SH_MODE BASIS_FROM_SH_MODE_SAMPLE_PEAKS

[numthreads(GROUP_SIZE, 1, 1)]
void InitializePropagationAxis(uint3 id : SV_DispatchThreadID)
{
    const uint readIndex = id.x;
    if (readIndex < _ProbeVolumeAtlasReadBufferCount)
    {
        SHOutgoingRadiosityWithProjectedConstantsPacked bakedOutgoingRadiosityProjectedConstantsPacked = ReadBakedSH(readIndex);
        SHOutgoingRadiosityWithProjectedConstants bakedOutgoingRadiosityProjectedConstants = SHOutgoingRadiosityWithProjectedConstantsCompute(bakedOutgoingRadiosityProjectedConstantsPacked);
        SHOutgoingRadiosity bakedOutgoingRadiosity = SHOutgoingRadiosityCompute(bakedOutgoingRadiosityProjectedConstants);

        const float3x3 probeVolumeAtlasSHRotate = float3x3(_ProbeVolumeAtlasSHRotateRight, _ProbeVolumeAtlasSHRotateUp, _ProbeVolumeAtlasSHRotateForward);
        SHOutgoingRadiosityRotate(probeVolumeAtlasSHRotate, bakedOutgoingRadiosity); // rotate baked SH Data into absolute world space before it is combined with dynamic SH data in absolute world space

        SHIncomingIrradiance shIncomingIrradiance = SHIncomingIrradianceCompute(bakedOutgoingRadiosity);

        const float3x3 probeVolumeLtw = float3x3(_ProbeVolumeDGIBoundsRight, _ProbeVolumeDGIBoundsUp, cross(_ProbeVolumeDGIBoundsRight, _ProbeVolumeDGIBoundsUp));

#if BASIS_FROM_SH_MODE == BASIS_FROM_SH_MODE_MONTE_CARLO_NAIVE_PROJECTION
        ComputeProbeBasisFromSHMonteCarloNaiveProjection(shIncomingIrradiance, probeVolumeLtw, readIndex);

#elif BASIS_FROM_SH_MODE == BASIS_FROM_SH_MODE_MONTE_CARLO_PROGRESSIVE_LEAST_SQUARES
        ComputeProbeBasisFromSHMonteCarloProgressiveLeastSquares(shIncomingIrradiance, probeVolumeLtw, readIndex);

#elif BASIS_FROM_SH_MODE == BASIS_FROM_SH_MODE_ZH_FIT
        ComputeProbeBasisFromSHZHFit(shIncomingIrradiance, probeVolumeLtw, readIndex);

#elif BASIS_FROM_SH_MODE == BASIS_FROM_SH_MODE_SAMPLE_PEAKS
        ComputeProbeBasisFromSHSamplePeaks(shIncomingIrradiance, probeVolumeLtw, readIndex);
#endif
    }
}
