#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Builtin/BuiltinData.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Packing.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/VBuffer/HDRenderPipeline.VertexBufferCompaction.cs.hlsl"

#pragma kernel VBCompactionKernel
#pragma kernel IBCompactionKernelUINT32
#pragma kernel IBCompactionKernelUINT16
#pragma enable_d3d11_debug_symbols


float4 _UVCompactionParams;
float4 _NormalCompactionParams;
float4 _PosCompactionParams;
float4 _TangentCompactionParams;


#define _UVVBBias (uint)_UVCompactionParams.x
#define _NormalVBBias (uint)_NormalCompactionParams.x
#define _PosVBBias (uint)_PosCompactionParams.x
#define _TangentVBBias (uint)_TangentCompactionParams.x

#define _VBCount (uint)_UVCompactionParams.y

#define _UVVBStride (uint)_UVCompactionParams.z
#define _NormalVBStride (uint)_NormalCompactionParams.z
#define _PosVBStride (uint)_PosCompactionParams.z
#define _TangentVBStride (uint)_TangentCompactionParams.z

#define _VBOutputBias (uint)_UVCompactionParams.w


float4 _IBCompactionParams;


ByteAddressBuffer _InputUVVB;
ByteAddressBuffer _InputNormalVB;
ByteAddressBuffer _InputPosVB;
ByteAddressBuffer _InputTangentVB;

RWStructuredBuffer<CompactVertex> _OutputVB;

CompactVertex GetCompactVertex(float2 uv, float3 pos, float3 N, float4 T)
{
    CompactVertex vtx;
    vtx.pos = pos;
    vtx.uv = uv;

    vtx.N = N;
    vtx.T = T;

    return vtx;
}

[numthreads(64, 1, 1)]
void VBCompactionKernel(uint3 id : SV_DispatchThreadID)
{
    if (id.x < _VBCount)
    {
        int vertexIdx = id.x;

        // Sample from inputs
        float2 uv = asfloat(_InputUVVB.Load2(vertexIdx * _UVVBStride + _UVVBBias));
        float3 pos = asfloat(_InputPosVB.Load3(vertexIdx * _PosVBStride + _PosVBBias));
        float3 N = asfloat(_InputNormalVB.Load3(vertexIdx * _NormalVBStride + _NormalVBBias));
        float4 T = asfloat(_InputTangentVB.Load4(vertexIdx * _TangentVBStride + _TangentVBBias));

        CompactVertex vtx = GetCompactVertex(uv, pos, N, T);
        _OutputVB[_VBOutputBias + vertexIdx] = vtx;
    }
}

RWStructuredBuffer<uint> _OutputIB;
ByteAddressBuffer _InputIB;


#define _IBSubmeshCount (uint)_IBCompactionParams.x

#define _IBOutputBias asuint(_IBCompactionParams.y)
#define _IBValueShift (uint)_IBCompactionParams.z
#define _IBInputStart (uint)_IBCompactionParams.w


void StoreTriangle(uint outputTriangleStart, uint inputVal, uint inputVal1, uint inputVal2)
{
    _OutputIB[_IBOutputBias + outputTriangleStart + 0] = inputVal;
    _OutputIB[_IBOutputBias + outputTriangleStart + 1] = inputVal1;
    _OutputIB[_IBOutputBias + outputTriangleStart + 2] = inputVal2;
}

[numthreads(128, 1, 1)]
void IBCompactionKernelUINT32(uint3 id : SV_DispatchThreadID)
{
    uint triangleIndexStart = id.x * 3;
    if (triangleIndexStart < _IBSubmeshCount)
    {
        uint idx0 = asuint(_InputIB.Load(triangleIndexStart + 0 + _IBInputStart)) + _IBValueShift;
        uint idx1 = asuint(_InputIB.Load(triangleIndexStart + 1 + _IBInputStart)) + _IBValueShift;
        uint idx2 = asuint(_InputIB.Load(triangleIndexStart + 2 + _IBInputStart)) + _IBValueShift;

        StoreTriangle(triangleIndexStart, idx0, idx1, idx2);
    }
    else
    {
        StoreTriangle(triangleIndexStart, 0xffffffff, 0xffffffff, 0xffffffff);
    }
}


[numthreads(128, 1, 1)]
void IBCompactionKernelUINT16(uint3 id : SV_DispatchThreadID)
{
    uint triangleIndexStart = id.x * 3;

    if (triangleIndexStart < _IBSubmeshCount)
    {
        uint triangleStartIndexInput = triangleIndexStart + _IBInputStart;

        uint idx0, idx1, idx2;
        uint accessIdx = (triangleStartIndexInput / 2);
        uint firstCouple = asuint(_InputIB.Load(accessIdx * 4));
        uint secondCouple = asuint(_InputIB.Load((accessIdx + 1) * 4));

        if ((triangleStartIndexInput & 1) == 0)
        {
            // We need first couple of indices
            // and first element of the next.
            idx0 = firstCouple & 0xffff;
            idx1 = firstCouple >> 16;
            idx2 = secondCouple & 0xffff;
        }
        else
        {
            // We need second index of the first couple of indices
            // and the whole next couple.
            idx0 = firstCouple >> 16;
            idx1 = secondCouple & 0xffff;
            idx2 = secondCouple >> 16;
        }

        StoreTriangle(triangleIndexStart, idx0 + _IBValueShift, idx1 + _IBValueShift, idx2 + _IBValueShift);
    }
    else
    {
        StoreTriangle(triangleIndexStart, 0xffffffff, 0xffffffff, 0xffffffff);
    }
}
