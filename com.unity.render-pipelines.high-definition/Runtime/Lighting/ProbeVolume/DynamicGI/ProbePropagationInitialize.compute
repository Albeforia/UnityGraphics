#pragma kernel InitializePropagationAxis
#define GROUP_SIZE 64
//#pragma enable_d3d11_debug_symbols

#pragma multi_compile BASIS_SPHERICAL_GAUSSIAN BASIS_SPHERICAL_GAUSSIAN_WINDOWED BASIS_AMBIENT_DICE_SHARP BASIS_AMBIENT_DICE_SOFTER BASIS_AMBIENT_DICE_SUPER_SOFT BASIS_AMBIENT_DICE_ULTRA_SOFT
#pragma multi_compile BASIS_PROPAGATION_OVERRIDE_NONE BASIS_PROPAGATION_OVERRIDE_SPHERICAL_GAUSSIAN BASIS_PROPAGATION_OVERRIDE_AMBIENT_DICE_WRAPPED_SOFTER BASIS_PROPAGATION_OVERRIDE_AMBIENT_DICE_WRAPPED_SUPER_SOFT BASIS_PROPAGATION_OVERRIDE_AMBIENT_DICE_WRAPPED_ULTRA_SOFT
#pragma multi_compile _ RADIANCE_ENCODING_LOGLUV RADIANCE_ENCODING_HALFLUV RADIANCE_ENCODING_R11G11B10

#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/ProbeVolume/DynamicGI/ProbeVolumeDynamicGI.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition-config/Runtime/ShaderConfig.cs.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/EntityLighting.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/CommonLighting.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/ProbeVolume/ProbeVolumeRotate.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/ProbeVolume/DynamicGI/ProbePropagationGlobals.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/ProbeVolume/DynamicGI/ProbeVolumeSphericalHarmonicsLighting.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/ProbeVolume/DynamicGI/ProbePropagationBasis.hlsl"

StructuredBuffer<float> _ProbeVolumeAtlasReadSHL01Buffer;
StructuredBuffer<float> _ProbeVolumeAtlasReadSHL2Buffer;
StructuredBuffer<float> _ProbeVolumeAtlasReadValidityBuffer;
RWTexture3D<float4> _ProbeVolumeAtlasWriteTextureSH;

uint _ProbeVolumeAtlasReadBufferCount;
float3 _ProbeVolumeResolution;
float3 _ProbeVolumeAtlasBias;
float4 _ProbeVolumeAtlasResolutionAndSliceCount;
float3 _ProbeVolumeAtlasSHRotateRight;
float3 _ProbeVolumeAtlasSHRotateUp;
float3 _ProbeVolumeAtlasSHRotateForward;

float3 _ProbeVolumeDGIBoundsRight;
float3 _ProbeVolumeDGIBoundsUp;

RWStructuredBuffer<RADIANCE> _RadianceCacheAxis;
int _RadianceCacheAxisCount;
float _BakedLightingContribution;
float _DynamicPropagationContribution;
float4 _RayAxis[NEIGHBOR_AXIS_COUNT];

float _Sharpness;

SHOutgoingRadiosityWithProjectedConstantsPacked ReadBakedSH(uint readIndex)
{
    SHOutgoingRadiosityWithProjectedConstantsPacked outgoingRadiosity;

    const uint SH_STRIDE_L01 = 4 * 3;
    const uint SH_STRIDE_L2 = (9 * 3) - SH_STRIDE_L01;

    outgoingRadiosity.data[0] = float4(
        _ProbeVolumeAtlasReadSHL01Buffer[readIndex * SH_STRIDE_L01 + 0], // shAr.w
        _ProbeVolumeAtlasReadSHL01Buffer[readIndex * SH_STRIDE_L01 + 1], // shAg.w
        _ProbeVolumeAtlasReadSHL01Buffer[readIndex * SH_STRIDE_L01 + 2], // shAb.w
        _ProbeVolumeAtlasReadSHL01Buffer[readIndex * SH_STRIDE_L01 + 3]  // shAr.x
    );
    outgoingRadiosity.data[1] = float4(
        _ProbeVolumeAtlasReadSHL01Buffer[readIndex * SH_STRIDE_L01 + 4], // shAr.y
        _ProbeVolumeAtlasReadSHL01Buffer[readIndex * SH_STRIDE_L01 + 5], // shAr.z
        _ProbeVolumeAtlasReadSHL01Buffer[readIndex * SH_STRIDE_L01 + 6], // shAg.x
        _ProbeVolumeAtlasReadSHL01Buffer[readIndex * SH_STRIDE_L01 + 7]  // shAg.y
    );
    outgoingRadiosity.data[2] = float4(
        _ProbeVolumeAtlasReadSHL01Buffer[readIndex * SH_STRIDE_L01 + 8], // shAg.z
        _ProbeVolumeAtlasReadSHL01Buffer[readIndex * SH_STRIDE_L01 + 9], // shAb.x
        _ProbeVolumeAtlasReadSHL01Buffer[readIndex * SH_STRIDE_L01 + 10], // shAb.y
        _ProbeVolumeAtlasReadSHL01Buffer[readIndex * SH_STRIDE_L01 + 11]  // shAb.z
    );
    outgoingRadiosity.data[3] = float4(
        _ProbeVolumeAtlasReadSHL2Buffer[readIndex * SH_STRIDE_L2 + 0], // shBr.x
        _ProbeVolumeAtlasReadSHL2Buffer[readIndex * SH_STRIDE_L2 + 1], // shBr.y
        _ProbeVolumeAtlasReadSHL2Buffer[readIndex * SH_STRIDE_L2 + 2], // shBr.z
        _ProbeVolumeAtlasReadSHL2Buffer[readIndex * SH_STRIDE_L2 + 3]  // shBr.w
    );
    outgoingRadiosity.data[4] = float4(
        _ProbeVolumeAtlasReadSHL2Buffer[readIndex * SH_STRIDE_L2 + 4], // shBg.x
        _ProbeVolumeAtlasReadSHL2Buffer[readIndex * SH_STRIDE_L2 + 5], // shBg.y
        _ProbeVolumeAtlasReadSHL2Buffer[readIndex * SH_STRIDE_L2 + 6], // shBg.z
        _ProbeVolumeAtlasReadSHL2Buffer[readIndex * SH_STRIDE_L2 + 7]  // shBg.w
    );
    outgoingRadiosity.data[5] = float4(
        _ProbeVolumeAtlasReadSHL2Buffer[readIndex * SH_STRIDE_L2 + 8], // shBb.x
        _ProbeVolumeAtlasReadSHL2Buffer[readIndex * SH_STRIDE_L2 + 9], // shBb.y
        _ProbeVolumeAtlasReadSHL2Buffer[readIndex * SH_STRIDE_L2 + 10], // shBb.z
        _ProbeVolumeAtlasReadSHL2Buffer[readIndex * SH_STRIDE_L2 + 11]  // shBb.w
    );
    outgoingRadiosity.data[6] = float4(
        _ProbeVolumeAtlasReadSHL2Buffer[readIndex * SH_STRIDE_L2 + 12], // shCr.x
        _ProbeVolumeAtlasReadSHL2Buffer[readIndex * SH_STRIDE_L2 + 13], // shCr.y
        _ProbeVolumeAtlasReadSHL2Buffer[readIndex * SH_STRIDE_L2 + 14], // shCr.z
        0.0
    );

    return outgoingRadiosity;
}

float3 ProbeVolumeEvaluateIncomingRadiance(SHIncomingIrradiance shIncomingIrradiance, float3 directionWS)
{
    float3 incomingRadiance = IncomingRadianceCompute(shIncomingIrradiance, directionWS);

    // Values can be negative due to ringing. Clip off negative values.
    incomingRadiance = max(0.0, incomingRadiance);

    return incomingRadiance;
}

[numthreads(GROUP_SIZE, 1, 1)]
void InitializePropagationAxis(uint3 id : SV_DispatchThreadID)
{
    const uint readIndex = id.x;
    if (readIndex < _ProbeVolumeAtlasReadBufferCount)
    {
        SHOutgoingRadiosityWithProjectedConstantsPacked bakedOutgoingRadiosityProjectedConstantsPacked = ReadBakedSH(readIndex);
        SHOutgoingRadiosityWithProjectedConstants bakedOutgoingRadiosityProjectedConstants = SHOutgoingRadiosityWithProjectedConstantsCompute(bakedOutgoingRadiosityProjectedConstantsPacked);
        SHOutgoingRadiosity bakedOutgoingRadiosity = SHOutgoingRadiosityCompute(bakedOutgoingRadiosityProjectedConstants);

        const float3x3 probeVolumeAtlasSHRotate = float3x3(_ProbeVolumeAtlasSHRotateRight, _ProbeVolumeAtlasSHRotateUp, _ProbeVolumeAtlasSHRotateForward);
        SHOutgoingRadiosityRotate(probeVolumeAtlasSHRotate, bakedOutgoingRadiosity); // rotate baked SH Data into absolute world space before it is combined with dynamic SH data in absolute world space

        SHIncomingIrradiance shIncomingIrradiance = SHIncomingIrradianceCompute(bakedOutgoingRadiosity);

        const float3x3 probeVolumeLtw = float3x3(_ProbeVolumeDGIBoundsRight, _ProbeVolumeDGIBoundsUp, cross(_ProbeVolumeDGIBoundsRight, _ProbeVolumeDGIBoundsUp));
        
        for (int i = 0; i < NEIGHBOR_AXIS_COUNT; ++i)
        {
            BasisAxisHit basisAxisHit = ComputeBasisAxisHit(_RayAxis[i].xyz, _Sharpness);

            // Because convolution in SH space is cheap (zonal harmonic window component-wise multiplication), we are able to
            // more accurately capture the integral of incoming irradiance over the hit basis solid angle + weight.
            // It's important to note that this is an approximation - because our hit axis lobe is not a zonal harmonic - it is an SG or AmbientDice lobe,
            // but it can be approximately represented as an ZH.
            // This has been validated against a ground truth monte carlo sampling of the basis over the hemisphere and the results are almost completely indistinguishable.
            float3 basisAxisHitDirectionWS = mul(basisAxisHit.mean, probeVolumeLtw);
            ZHWindow basisAxisHitZHWindow = ComputeZHWindowFromBasisAxisHit(basisAxisHit);
            SHIncomingIrradianceConvolveZHWindowWithoutDeltaFunction(shIncomingIrradiance, basisAxisHitZHWindow);
            float3 incomingHitRadiance = ProbeVolumeEvaluateIncomingRadiance(shIncomingIrradiance, basisAxisHitDirectionWS);

            _RadianceCacheAxis[i * _ProbeVolumeAtlasReadBufferCount + readIndex] = EncodeRadiance(incomingHitRadiance * 4);
        }
    }
}
