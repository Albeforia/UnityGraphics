#ifdef SURFACE_GRADIENT
#undef SURFACE_GRADIENT
#endif
#ifdef DECAL_SURFACE_GRADIENT
#undef DECAL_SURFACE_GRADIENT
#endif

#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/GeometricTools.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/TextureXR.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Visibility/VisibilityOITResources.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/PostProcessing/Shaders/PostProcessDefines.hlsl"

#define VARIANT_DIR_PUNCTUAL_AREA_ENV 1
#define HAS_LIGHTLOOP

#define DISABLE_APPLY_DEBUG_TO_LIGHTING

#define SHADERPASS SHADERPASS_VBUFFER_LIGHTING_OFFSCREEN

#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/LitProperties.hlsl"

#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/Lighting.hlsl"

#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/ShaderPass/LitDepthPass.hlsl"

#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoopDef.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoop.hlsl"

#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/LitData.hlsl"

#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/CommonLighting.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/EntityLighting.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Sky/SkyUtils.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/SDF2D.hlsl"

#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariablesFunctions.hlsl"

//#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/HDShadow.hlsl"
//#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoopDef.hlsl"
//#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/PunctualLightCommon.hlsl"
//#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoop.cs.hlsl"
//#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Builtin/BuiltinData.hlsl"
//#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoop.hlsl"

#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Visibility/VisibilityOITResources.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Visibility/VBufferDeferredMaterialCommon.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Visibility/BTDF.hlsl"

#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Random.hlsl" // TODO: replace with blue noise helper and scramble textures
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Visibility/BTDF.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/ImageBasedLighting.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/RaytracingSampling.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/RayTracingCommon.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariablesGlobal.cs.hlsl"

//#pragma enable_d3d11_debug_symbols
#pragma only_renderers d3d11 playstation xboxone xboxseries vulkan metal switch

#pragma kernel MainResolveOffscreenLighting

#define GROUP_SIZE 8

#if UNITY_REVERSED_Z
# define MIN_DEPTH(a, b) max(a, b)
#else
# define MIN_DEPTH(a, b) min(a, b)
#endif

TEXTURE2D_X(_DepthTexture);
RW_TEXTURE2D_X(float4, _OutputTexture);

float4 _VBufferLightingOffscreenParams;
int _OITHiZMaxMip;
StructuredBuffer<int2> _DepthPyramidMipLevelOffsets;

float3 viridis(float t)
{
    const float3 c0 = float3(0.2777273272234177, 0.005407344544966578, 0.3340998053353061);
    const float3 c1 = float3(0.1050930431085774, 1.404613529898575, 1.384590162594685);
    const float3 c2 = float3(-0.3308618287255563, 0.214847559468213, 0.09509516302823659);
    const float3 c3 = float3(-4.634230498983486, -5.799100973351585, -19.33244095627987);
    const float3 c4 = float3(6.228269936347081, 14.17993336680509, 56.69055260068105);
    const float3 c5 = float3(4.776384997670288, -13.74514537774601, -65.35303263337234);
    const float3 c6 = float3(-5.435455855934631, 4.645852612178535, 26.3124352495832);

    return c0 + t * (c1 + t * (c2 + t * (c3 + t * (c4 + t * (c5 + t * c6)))));
}

float3 plasma(float t)
{
    const float3 c0 = float3(0.05873234392399702, 0.02333670892565664, 0.5433401826748754);
    const float3 c1 = float3(2.176514634195958, 0.2383834171260182, 0.7539604599784036);
    const float3 c2 = float3(-2.689460476458034, -7.455851135738909, 3.110799939717086);
    const float3 c3 = float3(6.130348345893603, 42.3461881477227, -28.51885465332158);
    const float3 c4 = float3(-11.10743619062271, -82.66631109428045, 60.13984767418263);
    const float3 c5 = float3(10.02306557647065, 71.41361770095349, -54.07218655560067);
    const float3 c6 = float3(-3.658713842777788, -22.93153465461149, 18.19190778539828);

    return c0 + t * (c1 + t * (c2 + t * (c3 + t * (c4 + t * (c5 + t * c6)))));
}

float3 magma(float t)
{
    const float3 c0 = float3(-0.002136485053939582, -0.000749655052795221, -0.005386127855323933);
    const float3 c1 = float3(0.2516605407371642, 0.6775232436837668, 2.494026599312351);
    const float3 c2 = float3(8.353717279216625, -3.577719514958484, 0.3144679030132573);
    const float3 c3 = float3(-27.66873308576866, 14.26473078096533, -13.64921318813922);
    const float3 c4 = float3(52.17613981234068, -27.94360607168351, 12.94416944238394);
    const float3 c5 = float3(-50.76852536473588, 29.04658282127291, 4.23415299384598);
    const float3 c6 = float3(18.65570506591883, -11.48977351997711, -5.601961508734096);

    return c0 + t * (c1 + t * (c2 + t * (c3 + t * (c4 + t * (c5 + t * c6)))));
}

float3 inferno(float t)
{
    const float3 c0 = float3(0.0002189403691192265, 0.001651004631001012, -0.01948089843709184);
    const float3 c1 = float3(0.1065134194856116, 0.5639564367884091, 3.932712388889277);
    const float3 c2 = float3(11.60249308247187, -3.972853965665698, -15.9423941062914);
    const float3 c3 = float3(-41.70399613139459, 17.43639888205313, 44.35414519872813);
    const float3 c4 = float3(77.162935699427, -33.40235894210092, -81.80730925738993);
    const float3 c5 = float3(-71.31942824499214, 32.62606426397723, 73.20951985803202);
    const float3 c6 = float3(25.13112622477341, -12.24266895238567, -23.07032500287172);

    return c0 + t * (c1 + t * (c2 + t * (c3 + t * (c4 + t * (c5 + t * c6)))));
}

uint GetOffscreenLightBufferWidth()
{
    return asuint(_VBufferLightingOffscreenParams.x);
}

// Weight for SSR where Fresnel == 1 (returns value/pdf)
float GetSSRSampleWeight(float3 V, float3 L, float roughness)
{
    // Simplification:
    // value = D_GGX / (lambdaVPlusOne + lambdaL);
    // pdf = D_GGX / lambdaVPlusOne;

    const float lambdaVPlusOne = Lambda_GGX(roughness, V) + 1.0;
    const float lambdaL = Lambda_GGX(roughness, L);

    return lambdaVPlusOne / (lambdaVPlusOne + lambdaL);
}

#define SSR_TRACE_EPS               0.000488281f // 2^-11, should be good up to 4K
#define MIN_GGX_ROUGHNESS           0.00001f
#define MAX_GGX_ROUGHNESS           0.99999f

// Specialization without Fresnel (see PathTracingBSDF.hlsl for the reference implementation)
bool SampleGGX_VNDF(float roughness_,
    float3x3 localToWorld,
    float3 V,
    float2 inputSample,
    out float3 outgoingDir,
    out float weight)
{
    weight = 0.0f;

    float roughness = clamp(roughness_, MIN_GGX_ROUGHNESS, MAX_GGX_ROUGHNESS);

    float VdotH;
    float3 localV, localH;
    SampleGGXVisibleNormal(inputSample.xy, V, localToWorld, roughness, localV, localH, VdotH);

    // Compute the reflection direction
    float3 localL = 2.0 * VdotH * localH - localV;
    outgoingDir = mul(localL, localToWorld);

    if (localL.z < 0.001)
    {
        return false;
    }

    weight = GetSSRSampleWeight(localV, localL, roughness);

    if (weight < 0.001)
        return false;

    return true;
}

//RW_TEXTURE2D(float4, _OITDebugSSTracing);
RWTexture2D<float4> _OITDebugSSTracing;

void WriteDebugInfo(uint2 positionSS, float4 value)
{
    _OITDebugSSTracing[positionSS] = value;
}

void SampleVNDF(uint2 positionSS, float roughness, float deviceDepth, float3 normalWS, float ior, out float3 positionWS, out float weight, out float3 wi/*, out float3 wo*/, out float cos0i, out float cos0o, out float cos0h, out float cos0vh)
{
    float2 Xi;
    Xi.x = GetBNDSequenceSample(positionSS, _FrameCount, 0);
    Xi.y = GetBNDSequenceSample(positionSS, _FrameCount, 1);

    float3x3 localToWorld = GetLocalFrame(normalWS);

    float2 positionNDC = positionSS * _ScreenSize.zw + (0.5 * _ScreenSize.zw);
    positionWS = ComputeWorldSpacePosition(positionNDC, deviceDepth, UNITY_MATRIX_I_VP);
    float3 wo = GetWorldSpaceNormalizeViewDir(positionWS);

    float value;

    //SampleGGX_VNDF(roughness,
    //               localToWorld,
    //               wo,
    //               Xi,
    //               wi,
    //               weight);
    weight = 1.0f;
    wi = refract(-wo, normalWS, 1.0f / ior);
    //wi = reflect(-wo, normalWS);

    cos0o = dot(normalWS, wo);
    cos0i = dot(normalWS, wi);
    float3 wh = normalize(wo + wi);
    cos0h = dot(normalWS, wh);
    cos0vh = dot(wo, wh);
}

bool    GetBoundDeviceZ(uint2 posSS, float srcDeviceDepth, out float outDeviceDepth)
{
    PositionInputs posInputs = GetPositionInput(float2(posSS.xy), _ScreenSize.zw, uint2(GROUP_SIZE, GROUP_SIZE));

    uint pixelOffset = posSS.y * _ScreenSize.x + posSS.x;
    uint listCount, listOffset;
    VisibilityOIT::GetPixelList(pixelOffset, listCount, listOffset);
    if (listCount == 0)
    {
        outDeviceDepth = UNITY_RAW_FAR_CLIP_VALUE;
        return false;
    }

    uint sortIndicesBaseAddr = kSorting_PixelListDataOffset + (_ScreenSize.x * _ScreenSize.y) + listOffset;

    float previousDeviceDepth = 0.0f;
    for (uint i = 0; i < listCount; ++i)
    {
        uint sortedSampleIndex = i;

        // Load sorted indices when working with multi-sample lists
        if (listCount >= 2)
        {
            // Load the sorted index that corresponds to the i'th sample
            uint sortIndexAddr = sortIndicesBaseAddr + i;
            sortedSampleIndex = _OITSortMemoryBuffer[sortIndexAddr];
        }

        int globalOffset = sortedSampleIndex + listOffset;
        uint2 offscreenCoord = uint2(globalOffset % GetOffscreenLightBufferWidth(), globalOffset / GetOffscreenLightBufferWidth());

        Visibility::VisibilityData unusedVisData;
        uint2 unusedTexelCoord;
        float deviceDepth;
        float linearDepth;
        VisibilityOIT::GetVisibilitySampleWithLinearDepth(sortedSampleIndex, listOffset, unusedVisData, unusedTexelCoord, deviceDepth, linearDepth);
        if (srcDeviceDepth < deviceDepth)
        {
            outDeviceDepth = previousDeviceDepth;
            return true;
        }

        previousDeviceDepth = deviceDepth;
    }

    outDeviceDepth = srcDeviceDepth;
    return false;
}

[numthreads(GROUP_SIZE, GROUP_SIZE, 1)]
void MainResolveOffscreenLighting(int3 dispatchThreadId : SV_DispatchThreadID)
{
    UNITY_XR_ASSIGN_VIEW_INDEX(dispatchThreadId.z);
    if (any((float2)dispatchThreadId.xy > _ScreenSize.xy))
        return;

    PositionInputs posInputRaw = GetPositionInput(float2(dispatchThreadId.xy) + 0.5f, _ScreenSize.zw, uint2(GROUP_SIZE, GROUP_SIZE));

    uint pixelOffset = dispatchThreadId.y * _ScreenSize.x + dispatchThreadId.x;
    uint listCount, listOffset;
    VisibilityOIT::GetPixelList(pixelOffset, listCount, listOffset);

    if (listCount == 0)
        return;

    float firstDeviceDepth = 0.0;
    float firstLinearDepth = 0.0;
    int globalOffset;
    uint2 offscreenCoord;
    uint firstSampleIndex = 0;
    uint sortedSampleIndex;
    if (listCount <= firstSampleIndex)
        return;

    {
        sortedSampleIndex = Sorting::GetSortedSampleIndex(firstSampleIndex, listCount, listOffset);

        globalOffset = listOffset + sortedSampleIndex;
        offscreenCoord = uint2(globalOffset % GetOffscreenLightBufferWidth(), globalOffset / GetOffscreenLightBufferWidth());

        Visibility::VisibilityData unusedVisData;
        uint2 unusedTexelCoord;
        VisibilityOIT::GetVisibilitySampleWithLinearDepth(sortedSampleIndex, listOffset, unusedVisData, unusedTexelCoord, firstDeviceDepth, firstLinearDepth);
    }

    uint4 packedOITGBuffer0 = _VisOITOffscreenGBuffer0[COORD_TEXTURE2D_X(offscreenCoord)].rgba;
    uint2 packedOITGBuffer1 = _VisOITOffscreenGBuffer1[COORD_TEXTURE2D_X(offscreenCoord)].rg;
    float3 normal;
    float roughness;
    float3 baseColor;
    float metalness;
    float3 absorptionCoefficient;
    float ior;
    VisibilityOIT::UnpackOITGBufferData(packedOITGBuffer0, packedOITGBuffer1, normal, roughness, baseColor, metalness, absorptionCoefficient, ior);

    float opaqueDeviceDepth = LOAD_TEXTURE2D_X(_DepthTexture, dispatchThreadId.xy).r;
    //float opaqueDeviceDepth = LOAD_TEXTURE2D_X(_CameraDepthTexture, dispatchThreadId.xy).r;

    PositionInputs posInputOpaque = GetPositionInput((float2)dispatchThreadId.xy + 0.5f, _ScreenSize.zw);
    posInputOpaque.positionWS = ComputeWorldSpacePosition(posInputOpaque.positionNDC, opaqueDeviceDepth, UNITY_MATRIX_I_VP);
    float opaqueDepthLinear = LinearEyeDepth(posInputOpaque.positionWS, GetWorldToViewMatrix());
    //opaqueDepthLinear = (opaqueDepthLinear - _ProjectionParams.y) / (_ProjectionParams.z - _ProjectionParams.y);

    PositionInputs posInputTransparent = GetPositionInput(dispatchThreadId.xy + 0.5f, _ScreenSize.zw, uint2(GROUP_SIZE, GROUP_SIZE));
    posInputTransparent.positionWS = ComputeWorldSpacePosition(posInputTransparent.positionNDC, firstDeviceDepth, UNITY_MATRIX_I_VP);
    float transparentDepthLinearEye = LinearEyeDepth(posInputTransparent.positionWS, GetWorldToViewMatrix());
    float transparentDepthLinear = transparentDepthLinearEye;
    //float transparentDepthLinear = (transparentDepthLinearEye - near) / (far - near);

    if (firstDeviceDepth < opaqueDeviceDepth)
    {
        //_OutputTexture[COORD_TEXTURE2D_X(posInputRaw.positionSS.xy)] = float4(1.0, 0.0, 0.0, 1.0);
        return;
    }

    const float near = _ProjectionParams.y;
    const float far = _ProjectionParams.z;

    float3 wo = normalize(_WorldSpaceCameraPos - posInputTransparent.positionWS);

    //float pixelSizeRadiusProjected = maxPixelSize * (near + opaqueDepthLinear) / near;
    //pixelSizeRadiusProjected = (pixelSizeRadiusProjected - near) / (far - near);
    //_OutputTexture[COORD_TEXTURE2D_X(dispatchThreadId.xy)] = float4(pixelSizeRadiusProjected.xxx, 1.0);
    //return;

    //_OutputTexture[COORD_TEXTURE2D_X(dispatchThreadId.xy)] = float4(listCount.xxx, 1.0);
    //return;

#if 0
    uint2 positionSS = dispatchThreadId.xy;

    //float4 oitDepthData = LOAD_TEXTURE2D_X(_OITTileHiZ, positionSS);
    //float deviceDepth = oitDepthData.x;
    float deviceDepth = firstDeviceDepth;

    float3 positionWS;
    float weight;
    float3 wi;
    //float3 wo;
    float cos0i;
    float cos0o;
    float cos0h;
    float cos0vh;
    SampleVNDF(
        // Inputs
        positionSS, roughness, deviceDepth, normal, ior,
        // Outputs
        positionWS, weight, wi/*, wo*/, cos0i, cos0o, cos0h, cos0vh);

    //if (cos0i < 0.001f || weight < 0.001f)
    //{
    //    //WriteDebugInfo(positionSS, -1);
    //    return;
    //}

    float3 camPosWS = GetCurrentViewPosition();

    // Apply normal bias with the magnitude dependent on the distance from the camera.
    // Unfortunately, we only have access to the shading normal, which is less than ideal...
    positionWS = camPosWS + (positionWS - camPosWS) * (1 - 0.001 * rcp(max(dot(normal, wo), FLT_EPS)));
    //positionWS = camPosWS + (positionWS - camPosWS) * (1 - 0.001 * rcp(max(-dot(normal, wi), FLT_EPS)));
    //positionWS = camPosWS - normal * 0.001f;
    deviceDepth = ComputeNormalizedDeviceCoordinatesWithZ(positionWS, UNITY_MATRIX_VP).z;
    bool killRay = deviceDepth == UNITY_RAW_FAR_CLIP_VALUE;

    // Ref. #1: Michal Drobot - Quadtree Displacement Mapping with Height Blending.
    // Ref. #2: Yasin Uludag  - Hi-Z Screen-Space Cone-Traced Reflections.
    // Ref. #3: Jean-Philippe Grenier - Notes On Screen Space HIZ Tracing.
    // Warning: virtually all of the code below assumes reverse Z.

    // We start tracing from the center of the current pixel, and do so up to the far plane.
    float3 rayOrigin = float3(positionSS + 0.5, deviceDepth);

    float3 reflPosWS = positionWS + wi;
    float3 reflPosNDC = ComputeNormalizedDeviceCoordinatesWithZ(reflPosWS, UNITY_MATRIX_VP); // Jittered
    float3 reflPosSS = float3(reflPosNDC.xy * _ScreenSize.xy, reflPosNDC.z);
    float3 rayDir = reflPosSS - rayOrigin;
    float3 rcpRayDir = rcp(rayDir);
    int2   rayStep = int2(rcpRayDir.x >= 0 ? 1 : 0,
                          rcpRayDir.y >= 0 ? 1 : 0);
    float3 raySign = float3(rcpRayDir.x >= 0 ? 1 : -1,
                            rcpRayDir.y >= 0 ? 1 : -1,
                            rcpRayDir.z >= 0 ? 1 : -1);
    bool   rayTowardsEye = rcpRayDir.z >= 0;

    // Note that we don't need to store or read the perceptualRoughness value
    // if we mark stencil during the G-Buffer pass with pixels which should receive SSR,
    // and sample the color pyramid during the lighting pass.
    //killRay = killRay || (reflPosSS.z <= 0);
    //killRay = killRay || (reflPosSS.z < 0);
    //killRay = killRay || (dot(normal, wo) <= 0);
    //killRay = killRay || (perceptualRoughness > _SsrRoughnessFadeEnd);
//#ifndef SSR_TRACE_TOWARDS_EYE
//    killRay = killRay || rayTowardsEye;
//#endif

    if (killRay)
    {
        //WriteDebugInfo(positionSS, -1);
        return;
    }

    // Extend and clip the end point to the frustum.
    float tMax;
    {
        // Shrink the frustum by half a texel for efficiency reasons.
        const float halfTexel = 0.5;

        float3 bounds;
        bounds.x = (rcpRayDir.x >= 0) ? _ScreenSize.x - halfTexel : halfTexel;
        bounds.y = (rcpRayDir.y >= 0) ? _ScreenSize.y - halfTexel : halfTexel;
        // If we do not want to intersect the skybox, it is more efficient to not trace too far.
        //float maxDepth = (_SsrReflectsSky != 0) ? -0.00000024 : 0.00000024; // 2^-22
        float maxDepth = 0.00000024; // 2^-22
        bounds.z = (rcpRayDir.z >= 0) ? 1 : maxDepth;

        float3 dist = bounds * rcpRayDir - (rayOrigin * rcpRayDir);
        tMax = Min3(dist.x, dist.y, dist.z);
    }

    // Clamp the MIP level to give the compiler more information to optimize.
    //const int maxMipLevel = min(_SsrDepthPyramidMaxMip, 14);
    const int maxMipLevel = 7;

    // Start ray marching from the next texel to avoid self-intersections.
    float t;
    {
        // 'rayOrigin' is the exact texel center.
        float2 dist = abs(0.5 * rcpRayDir.xy);
        t = min(dist.x, dist.y);
    }

    float3 rayPos;

    int  mipLevel = 0;
    int  iterCount = 0;
    bool hit = false;
    bool miss = false;
    bool belowMip0 = false; // This value is set prior to entering the cell

    const float thickness = 0.001f;
    float _SsrThicknessScale = 1.0f / (1.0f + thickness);
    float _SsrThicknessBias = -near / (far - near) * (thickness * _SsrThicknessScale);

    bool beforeTransparent = false;
    //while (!(hit || miss) && (t <= tMax) && (iterCount < _SsrIterLimit))
    //while (!(hit || miss) && (t <= tMax) && (iterCount < 256))
    float3 rayPrevious;
    bool hitOpaqueOrFar = false;
    bool frontFace = true;
    uint bounceCount = 0;
    while ((t <= tMax) && (iterCount < 256) && !hitOpaqueOrFar)
    {
        rayPrevious = rayPos;
        rayPos = rayOrigin + t * rayDir;

        // Ray position often ends up on the edge. To determine (and look up) the right cell,
        // we need to bias the position by a small epsilon in the direction of the ray.
        float2 sgnEdgeDist = round(rayPos.xy) - rayPos.xy;
        float2 satEdgeDist = clamp(raySign.xy * sgnEdgeDist + SSR_TRACE_EPS, 0, SSR_TRACE_EPS);
        rayPos.xy += raySign.xy * satEdgeDist;

        int2 mipCoord = (int2)rayPos.xy >> mipLevel;
        int2 mipOffset = _DepthPyramidMipLevelOffsets[mipLevel];
        // Bounds define 4 faces of a cube:
        // 2 walls in front of the ray, and a floor and a base below it.
        float4 bounds;

        bounds.xy = (mipCoord + rayStep) << mipLevel;
        //bounds.z = LOAD_TEXTURE2D_X(_CameraDepthTexture, mipOffset + mipCoord).r;
        //bounds.z = LOAD_TEXTURE2D_X(_OITTileHiZ, mipOffset + mipCoord).z;
        //float srcDeviceDepth = LOAD_TEXTURE2D_X(_CameraDepthTexture, mipOffset + mipCoord).r;
        //    //rayPos.z;// LOAD_TEXTURE2D_X(_CameraDepthTexture, mipOffset + mipCoord).r;
        ////bounds.z = GetBoundDeviceZ((uint2)rayPos.xy, srcDeviceDepth);
        //bool beforeTransparent = GetBoundDeviceZ((uint2)rayPos.xy, srcDeviceDepth, bounds.z);
        float opaqueDepthDevice_k = LOAD_TEXTURE2D_X(_CameraDepthTexture, mipOffset + mipCoord).r;
        bounds.z = opaqueDepthDevice_k;

#if 0
        if (rayPos.z >= opaqueDepthDevice_k || rayPos.z <= 0.0f ||
            any(rayPos.xy < 0.0f) || any((int2)rayPos.xy >= (int2)_ScreenSize.xy))
        {
            ++bounceCount;
            hitOpaqueOrFar = true;
            break;
        }

        uint pixelOffset_k = rayPos.y * _ScreenSize.x + rayPos.x;
        uint listCount_k, listOffset_k;
        VisibilityOIT::GetPixelList(pixelOffset_k, listCount_k, listOffset_k);

        float hitDeviceDepth = opaqueDepthDevice_k;
        if (listCount_k > 0)
        {
            bool hitTransparent = false;
            for (uint q = 0; q < listCount_k; ++q)
            {
                uint sortedSampleIndex_q = listCount_k >= 2 ? Sorting::GetSortedSampleIndex(q, listCount_k, listOffset_k) : 0;
                int globalOffset_q = sortedSampleIndex_q + listOffset_k;
                uint2 offscreenCoord_q = uint2(globalOffset_q % GetOffscreenLightBufferWidth(), globalOffset / GetOffscreenLightBufferWidth());

                uint4 packedOITGBuffer0_q = _VisOITOffscreenGBuffer0[COORD_TEXTURE2D_X(offscreenCoord_q)].rgba;
                uint2 packedOITGBuffer1_q = _VisOITOffscreenGBuffer1[COORD_TEXTURE2D_X(offscreenCoord_q)].rg;
                float3 normal_q;
                float roughness_q;
                float3 baseColor_q;
                float metalness_q;
                float3 absorptionCoefficient_q;
                float ior_q;
                VisibilityOIT::UnpackOITGBufferData(packedOITGBuffer0_q, packedOITGBuffer1_q, normal_q, roughness_q, baseColor_q, metalness_q, absorptionCoefficient_q, ior_q);

                float cos0t = dot(rayDir, normal_q);

                if (frontFace && cos0t < 0.0f ||
                    !frontFace && cos0t > 0.0f)
                {
                    continue;
                }

                Visibility::VisibilityData unusedVisData_q;
                uint2 unusedTexelCoord_q;
                float deviceDepth_q;
                float linearDepth_q;
                VisibilityOIT::GetVisibilitySampleWithLinearDepth(sortedSampleIndex_q, listOffset_k, unusedVisData_q, unusedTexelCoord_q, deviceDepth_q, linearDepth_q);

                if (linearDepth_q > rayPos.z)
                {
                    break;
                }

                // Approx
                if (rayPrevious.z <= deviceDepth_q && deviceDepth_q <= rayPos.z)
                {
                    ++bounceCount;
                    hitTransparent = true;
                    rayDir = refract(rayDir, frontFace ? -normal_q : normal_q, frontFace ? 1.0f / ior_q : ior_q);
                    hitDeviceDepth = deviceDepth_q;
                    break;
                }
            }
            if (hitTransparent)
            {
                frontFace = !frontFace;
            }
        }

        bounds.z = hitDeviceDepth;
#endif

        // We define the depth of the base as the depth value as:
        // b = DeviceDepth((1 + thickness) * LinearDepth(d))
        // b = ((f - n) * d + n * (1 - (1 + thickness))) / ((f - n) * (1 + thickness))
        // b = ((f - n) * d - n * thickness) / ((f - n) * (1 + thickness))
        // b = d / (1 + thickness) - n / (f - n) * (thickness / (1 + thickness))
        // b = d * k_s + k_b
        bounds.w = bounds.z * _SsrThicknessScale + _SsrThicknessBias;

        float4 dist = bounds * rcpRayDir.xyzz - (rayOrigin.xyzz * rcpRayDir.xyzz);
        float  distWall = min(dist.x, dist.y);
        float  distFloor = dist.z;
        float  distBase = dist.w;

        // Note: 'rayPos' given by 't' can correspond to one of several depth values:
        // - above or exactly on the floor
        // - inside the floor (between the floor and the base)
        // - below the base
#if 0
        bool belowFloor = (raySign.z * (t - distFloor)) < 0;
        bool aboveBase = (raySign.z * (t - distBase)) >= 0;
#else
        bool belowFloor = rayPos.z < bounds.z;
        bool aboveBase = rayPos.z >= bounds.w;
#endif
        bool insideFloor = belowFloor && aboveBase;
        bool hitFloor = (t <= distFloor) && (distFloor <= distWall);

        // Game rules:
        // * if the closest intersection is with the wall of the cell, switch to the coarser MIP, and advance the ray.
        // * if the closest intersection is with the heightmap below,  switch to the finer   MIP, and advance the ray.
        // * if the closest intersection is with the heightmap above,  switch to the finer   MIP, and do NOT advance the ray.
        // Victory conditions:
        // * See below. Do NOT reorder the statements!

//#ifdef SSR_TRACE_BEHIND_OBJECTS
//        miss = belowMip0 && insideFloor;
//#else
        miss = belowMip0;
        //#endif

        hit = (mipLevel == 0) && (hitFloor || insideFloor) && !beforeTransparent;
        belowMip0 = (mipLevel == 0) && belowFloor;

        // 'distFloor' can be smaller than the current distance 't'.
        // We can also safely ignore 'distBase'.
        // If we hit the floor, it's always safe to jump there.
        // If we are at (mipLevel != 0) and we are below the floor, we should not move.
        t = hitFloor ? distFloor : (((mipLevel != 0) && belowFloor) ? t : distWall);
        rayPos.z = bounds.z; // Retain the depth of the potential intersection

        // Warning: both rays towards the eye, and tracing behind objects has linear
        // rather than logarithmic complexity! This is due to the fact that we only store
        // the maximum value of depth, and not the min-max.
        //mipLevel += (hitFloor || belowFloor || rayTowardsEye) ? -1 : 1;
        //mipLevel = clamp(mipLevel, 0, maxMipLevel);

        // mipLevel = 0;

        iterCount++;

        //if (bounceCount >= 1)
        //    break;
    }

    // Treat intersections with the sky as misses.
    //miss = miss || ((_SsrReflectsSky == 0) && (rayPos.z == 0));
    hit = hit && !miss;

    if (hit)
    {
        //float lastDeviceDepth = LOAD_TEXTURE2D_X(_CameraDepthTexture, (int2)rayPos.xy).r;
        //if (rayPos.z >= lastDeviceDepth)
        //{
        //    float3 curTransparent = _VisOITOffscreenPhotonRadianceLighting[COORD_TEXTURE2D_X(offscreenCoord)].rgb;
        //    _OutputTexture[COORD_TEXTURE2D_X(posInputRaw.positionSS.xy)] = float4(curTransparent, 1.0);
        //    //_OutputTexture[COORD_TEXTURE2D_X(posInputRaw.positionSS.xy)] = float4(0.0, 1.0, 0.0, 1.0);
        //}
        //else
        {
            float3 curOpaqueColor = LOAD_TEXTURE2D_X(_VisOITOpaqueColorPyramid, rayPos.xy).rgb;
            _OutputTexture[COORD_TEXTURE2D_X(posInputRaw.positionSS.xy)] = float4(curOpaqueColor, 1.0);
        }
    }
    else
    {
        _OutputTexture[COORD_TEXTURE2D_X(posInputRaw.positionSS.xy)] = float4(1.0, 0.0, 0.0, 1.0);
    }

    return;

#elif 1

    uint2 positionSS = dispatchThreadId.xy;

    float3 wr = reflect(-wo, normal);
    float3 wt = refract(-wo, normal, ior);

    float3 positionWS;
    float weight;
    float3 wi;
    //float3 wo;
    float cos0i;
    float cos0o;
    float cos0h;
    float cos0vh;
    SampleVNDF(
        // Inputs
        positionSS, roughness, firstDeviceDepth, normal, ior,
        // Outputs
        positionWS, weight, wt, cos0i, cos0o, cos0h, cos0vh);

    //if (dot(wt, wt) < 0.5f)
    //    wt = wr;

    //wt = -wo;

    bool frontFace = dot(wo, normal) > 0.0f;

    float3 startPosWS = posInputTransparent.positionWS + 0.125f * normal;
    //float3 startPosWS = posInputTransparent.positionWS * (1 - 0.001 * rcp(max(dot(normal, wo), FLT_EPS)));
    //float3 startPosWS = posInputTransparent.positionWS;

    //float3 camPosWS = GetCurrentViewPosition();
    //float3 dir = wt;
    //camPosWS + (positionWS - camPosWS) * (1 - 0.001 * rcp(max(dot(N, V), FLT_EPS)));
    float3 stepWS = startPosWS + 10.0f * wt;
    //float3 stepWS = camPosWS + (posInputTransparent.positionWS - camPosWS) * (1 - 0.001 * rcp(max(dot(normal, wt), FLT_EPS)));
    float3 stepNDC = ComputeNormalizedDeviceCoordinatesWithZ(stepWS, UNITY_MATRIX_VP);
    float stepDepthLinear = LinearEyeDepth(stepWS, GetWorldToViewMatrix());
    //stepDepthLinear = (stepDepthLinear - _ProjectionParams.y) / (_ProjectionParams.z - _ProjectionParams.y);

    float3 step = float3((stepNDC.xy * _ScreenSize.xy), stepDepthLinear);

    //float3 startNDC = ComputeNormalizedDeviceCoordinatesWithZ(startPosWS, UNITY_MATRIX_VP);
    float startDepthLinear = LinearEyeDepth(startPosWS, GetWorldToViewMatrix());

    float3 p = float3(posInputRaw.positionSS.xy + 0.5f, startDepthLinear/*transparentDepthLinear - 1.0f*/);
    float3 dir = normalize(step - p);

    //if (dir.z < 0.0f)
    //    return;

    float scale = 1.0f / length(dir.xy);
    dir *= scale;

    float curIOR = ior;

    #define maxTransparentHit 32
    float3 hits[maxTransparentHit] = { (float3)0, (float3)0, (float3)0, (float3)0, (float3)0, (float3)0, (float3)0, (float3)0,
                                       (float3)0, (float3)0, (float3)0, (float3)0, (float3)0, (float3)0, (float3)0, (float3)0,
                                       (float3)0, (float3)0, (float3)0, (float3)0, (float3)0, (float3)0, (float3)0, (float3)0,
                                       (float3)0, (float3)0, (float3)0, (float3)0, (float3)0, (float3)0, (float3)0, (float3)0 };
    float4 infos[maxTransparentHit] = { (float4)0, (float4)0, (float4)0, (float4)0, (float4)0, (float4)0, (float4)0, (float4)0,
                                        (float4)0, (float4)0, (float4)0, (float4)0, (float4)0, (float4)0, (float4)0, (float4)0,
                                        (float4)0, (float4)0, (float4)0, (float4)0, (float4)0, (float4)0, (float4)0, (float4)0,
                                        (float4)0, (float4)0, (float4)0, (float4)0, (float4)0, (float4)0, (float4)0, (float4)0 };

    bool hitOpaqueOrFar = false;
    float3 previous;
    int k;
    bool hitTransparent = false;
    uint curTransparentHit = 1;

    float energy = 1.0f;
    p.xy = round(p.xy);

    float distance = 0.0f;

    UNITY_LOOP
    for (k = 0; k < 512; ++k)
    {
        previous = p;
        previous.xy = (p.xy);

        // Paranoid loop
        UNITY_LOOP
        for (int u = 0; u < 64; u++)
        {
            p += dir;
            if (any((int2)round(p.xy) != (int2)round(previous.xy)))
            {
                break;
            }
        }
        //p.xy = round(p.xy) + 0.5f;

        distance += length(previous - p);

        //if (distance > far)
        //{
        //    curTransparentHit == 0;
        //    break;
        //}

        float opaqueDeviceDepth_k = LOAD_TEXTURE2D_X(_DepthTexture, p.xy).r;
        float3 opaquePositionWS_k = ComputeWorldSpacePosition(p.xy * _ScreenSize.zw, opaqueDeviceDepth_k, UNITY_MATRIX_I_VP);
        float opaqueDepthLinear_k = LinearEyeDepth(opaquePositionWS_k, GetWorldToViewMatrix());

        if (p.z >= opaqueDepthLinear_k)
        {
            hitOpaqueOrFar = true;
            break;
        }

        //uint pixelOffset_k = (uint)p.y * _ScreenSize.x + (uint)p.x;
        //uint pixelOffset_k = round(p.y) * _ScreenSize.x + round(p.x);
        uint pixelOffset_k = round(p.y * _ScreenSize.x + p.x);
        uint listCount_k, listOffset_k;
        VisibilityOIT::GetPixelList(pixelOffset_k, listCount_k, listOffset_k);

        //if (false && listCount_k > 0 && curTransparentHit < maxTransparentHit)
        if (listCount_k > 0)// && curTransparentHit < maxTransparentHit)
        {
            hitTransparent = false;
            uint2 offscreenCoord_best;
            float roughness_best;
            float ior_best;
            float3 normal_best;
            float measure_best = -1.0f;
            for (uint q = 0; q < listCount_k; ++q)
            {
                uint sortedSampleIndex_q = listCount_k >= 2 ? Sorting::GetSortedSampleIndex(q, listCount_k, listOffset_k) : 0;
                int globalOffset_q = sortedSampleIndex_q + listOffset_k;
                uint2 offscreenCoord_q = uint2(globalOffset_q % GetOffscreenLightBufferWidth(), globalOffset / GetOffscreenLightBufferWidth());

                uint4 packedOITGBuffer0_q = _VisOITOffscreenGBuffer0[COORD_TEXTURE2D_X(offscreenCoord_q)].rgba;
                uint2 packedOITGBuffer1_q = _VisOITOffscreenGBuffer1[COORD_TEXTURE2D_X(offscreenCoord_q)].rg;
                float3 normal_q;
                float roughness_q;
                float3 baseColor_q;
                float metalness_q;
                float3 absorptionCoefficient_q;
                float ior_q;
                VisibilityOIT::UnpackOITGBufferData(packedOITGBuffer0_q, packedOITGBuffer1_q, normal_q, roughness_q, baseColor_q, metalness_q, absorptionCoefficient_q, ior_q);

                float cos0t = dot(dir, normal_q);

                if ( frontFace && cos0t <= 0.0f ||
                    !frontFace && cos0t >= 0.0f)
                {
                    continue;
                }

                Visibility::VisibilityData unusedVisData_q;
                uint2 unusedTexelCoord_q;
                float deviceDepth_q;
                float linearDepth_q;
                VisibilityOIT::GetVisibilitySampleWithLinearDepth(sortedSampleIndex_q, listOffset_k, unusedVisData_q, unusedTexelCoord_q, deviceDepth_q, linearDepth_q);

                if (linearDepth_q + 0.5f > p.z)
                {
                    break;
                }

                //if (listCount_k == 2)
                //{
                //    _OutputTexture[COORD_TEXTURE2D_X(dispatchThreadId.xy)] = float4(1.0, 0.0, 0.0, 1.0);
                //    return;
                //}
                // Is Hit test
        #if 0
                //const float epsilon = 0.125f;
                const float epsilon = //0.5f;
                    //max(_ScreenSize.x, _ScreenSize.z);
                    //max(_ScreenSize.x, _ScreenSize.z) * (near + p.z) / near;
                    0.125f * (near + p.z) / near;
                // Approx if previous "sandwiches" the transparent sample
                //if (previous.z <= linearDepth_q + epsilon && linearDepth_q - epsilon <= p.z)
                //if (linearDepth_q < p.z - epsilon)
                if (abs(linearDepth_q - p.z) < epsilon)
                {
                    hitTransparent = true;
                    dir = refract(dir,
                        frontFace ? -normal_q : normal_q, frontFace ? 1.0f / ior_q : ior_q);
                    hits[curTransparentHit] = _VisOITOffscreenDirectReflectionLighting[COORD_TEXTURE2D_X(offscreenCoord_q)].rgb;
                    infos[curTransparentHit].x = roughness_q;
                    break;
                }
        #elif 0
                const float epsilon = ((p.z - near) / (far - near)) / max(_ScreenSize.x, _ScreenSize.z);
                    //0.5f;
                    //max(_ScreenSize.x, _ScreenSize.z);
                    //max(_ScreenSize.x, _ScreenSize.z) * (near + p.z) / near;
                    //0.00125f * (near + (p.z - near) + near) / near;
                // Sphere hit
                bool intersect;
                float2 hit;
                if (IntersectRaySphere(previous - float3((float2)((int2)p.xy), linearDepth_q), dir, epsilon, hit))
                {
                    hitTransparent = true;
                    dir = refract(dir,
                        frontFace ? -normal_q : normal_q, frontFace ? 1.0f / ior_q : ior_q);
                    hits[curTransparentHit] = _VisOITOffscreenDirectReflectionLighting[COORD_TEXTURE2D_X(offscreenCoord_q)].rgb;
                    infos[curTransparentHit].x = roughness_q;
                    break;
                }
        #else
                float curDeviceDepth = DeviceDepthFromLinearEye(p.z, _ZBufferParams);
                float prevDeviceDepth = DeviceDepthFromLinearEye(previous.z, _ZBufferParams);
                float3 previousWS = ComputeWorldSpacePosition(previous.xy * _ScreenSize.zw, curDeviceDepth, UNITY_MATRIX_I_VP);
                float3 currentWS = ComputeWorldSpacePosition(p.xy * _ScreenSize.zw, curDeviceDepth, UNITY_MATRIX_I_VP);
                float3 sampleWS = ComputeWorldSpacePosition(p.xy * _ScreenSize.zw, deviceDepth_q, UNITY_MATRIX_I_VP);
                float3 v0 = normalize(currentWS - previousWS);
                float3 v1 = normalize(sampleWS - previousWS);
                float measure_q = dot(v0, v1);
                if (measure_q > measure_best)
                {
                    measure_best = measure_q;
                    ior_best = ior_q;
                    offscreenCoord_best = offscreenCoord_q;
                    roughness_best = roughness_q;
                    normal_best = normal_q;
                }
        #endif
            }
            if (measure_best > 0.9f)
            {
                //dir = refract(dir,
                //    frontFace ? -normal_best : normal_best, frontFace ? 1.0f / ior_best : ior_best);
                dir = refract(dir,
                    frontFace ? -normal_best : normal_best, frontFace ? ior_best : 1.0f / ior_best);
                scale = 1.0f / length(dir.xy);
                dir *= scale;
                hits[curTransparentHit] = _VisOITOffscreenDirectReflectionLighting[COORD_TEXTURE2D_X(offscreenCoord_best)].rgb;
                infos[curTransparentHit].w = roughness_best;
                //p += dir;
                float fresnel_q = F_FresnelDielectric(ior_best, abs(dot(normal_best, dir)));
                infos[curTransparentHit].xyz = fresnel_q;
                energy *= fresnel_q;
                //hitTransparent = true;
            //}
            //if (hitTransparent)
            //{
                frontFace = !frontFace;
                hitTransparent = false;
                ++curTransparentHit;
            }
        }
    }

    if (k == 512)
        return;

    //if (curTransparentHit > 0)
    //{
    //    float3 rgbValue = viridis(
    //        saturate(
    //            ((float)curTransparentHit) / ((float)maxTransparentHit)
    //        )
    //    );
    //    _OutputTexture[COORD_TEXTURE2D_X(dispatchThreadId.xy)] = float4(rgbValue, 1.0);
    //    return;
    //}
    //return;

    //if (curTransparentHit == 0 && hitOpaqueOrFar)
    //{
    //    //ComputeNormalizedDeviceCoordinatesWithZ(positionWS, UNITY_MATRIX_VP).z;
    //    //ComputeWorldSpacePosition(posInputTransparent.positionNDC, firstDeviceDepth, UNITY_MATRIX_I_VP);
    //    //float finalDeviceDepth = DeviceDepthFromLinearEye(previous.z * (_ProjectionParams.z - _ProjectionParams.y) + _ProjectionParams.y, _ZBufferParams);
    //    //float3 ended = 0.5f * (p + previous);
    //    float3 ended = p;
    //    float finalDeviceDepth = DeviceDepthFromLinearEye(ended.z, _ZBufferParams);
    //    float3 finalPositionWS = ComputeWorldSpacePosition(ended.xy * _ScreenSize.zw, finalDeviceDepth, UNITY_MATRIX_I_VP);
    //    //float3 opaqueHit = LOAD_TEXTURE2D_X(_VisOITOpaqueColorPyramid, ended.xy).rgb * exp( -absorptionCoefficient * length(posInputTransparent.positionWS - finalPositionWS) );
    //    //float3 opaqueHit = LOAD_TEXTURE2D_X(_VisOITOpaqueColorPyramid, ended.xy).rgb;
    //    //_SsrColorPyramidMaxMip
    //    float perceptualRoughness = RoughnessToPerceptualRoughness(roughness);
    //    float3 opaqueHit = SAMPLE_TEXTURE2D_X_LOD(_VisOITOpaqueColorPyramid, s_trilinear_clamp_sampler, ended.xy * _ScreenSize.zw, perceptualRoughness * 8).rgb;
    //    _OutputTexture[COORD_TEXTURE2D_X(dispatchThreadId.xy)] = float4(opaqueHit, 1.0);
    //    return;
    //}
    //else
    //if (curTransparentHit > 0)// && hitOpaqueOrFar)
    {
        float3 ended = p;
        float perceptualRoughness = RoughnessToPerceptualRoughness(infos[curTransparentHit - 1].w);
        float3 opaqueHit = SAMPLE_TEXTURE2D_X_LOD(_VisOITOpaqueColorPyramid, s_trilinear_clamp_sampler, ended.xy * _ScreenSize.zw, perceptualRoughness * 8).rgb;
        float3 results = opaqueHit;
        for (int i = curTransparentHit - 1; i >= 0; --i)
        {
            results += hits[i] * infos[i].rgb;
        }
        _OutputTexture[COORD_TEXTURE2D_X(dispatchThreadId.xy)] = float4(results / ((float)(curTransparentHit + 1)), 1.0);
        return;
    }
    //else
    {
        _OutputTexture[COORD_TEXTURE2D_X(dispatchThreadId.xy)] = float4(1.0, 0, 0, 1.0);
        return;
    }
    return;

#endif

    float3 coarseRefraction = float3(0,0,0);
    float4 radianceVal = float4(0, 0, 0, 0);
    float fresnelDielectricCoef;
    {
        //for (uint a = 0; a < listCount; ++a)
        //{
        //    int gOffset = a + listOffset;
        //    uint2 offscreenCoord = uint2(gOffset % GetOffscreenLightBufferWidth(), gOffset / GetOffscreenLightBufferWidth());
        //    float4 radSample = _VisOITOffscreenPhotonRadianceLighting[COORD_TEXTURE2D_X(offscreenCoord)];
        //    radianceVal += float4(radSample.xyz, radSample.a);
        //}

        //float4 radianceVal = float4(0,0,0,0);
        {
            uint2 offscreenCoord = uint2(globalOffset % GetOffscreenLightBufferWidth(), globalOffset / GetOffscreenLightBufferWidth());
            radianceVal = _VisOITOffscreenPhotonRadianceLighting[COORD_TEXTURE2D_X(offscreenCoord)];
        }

        PositionInputs posInputTransparent0 = GetPositionInput(dispatchThreadId.xy, _ScreenSize.zw, uint2(GROUP_SIZE, GROUP_SIZE));
        float3 firstSamplePositionWS = ComputeWorldSpacePosition(posInputTransparent0.positionNDC, firstDeviceDepth, UNITY_MATRIX_I_VP);
        float3 wo = normalize(_WorldSpaceCameraPos - firstSamplePositionWS);

        fresnelDielectricCoef = F_FresnelDielectric(ior, dot(normal, wo));

        coarseRefraction = radianceVal.xyz / radianceVal.a;
    }

    float3 directLighting = _VisOITOffscreenDirectReflectionLighting[COORD_TEXTURE2D_X(offscreenCoord)].rgb;
    // @kleber: TODO
    // _OutputTexture[COORD_TEXTURE2D_X(posInputRaw.positionSS.xy)] = float4(lerp(coarseRefraction, directLighting, fresnelDielectricCoef), 1.0);
    _OutputTexture[COORD_TEXTURE2D_X(posInputRaw.positionSS.xy)] = float4(lerp(coarseRefraction, directLighting, 0.2), 1.0);
}
