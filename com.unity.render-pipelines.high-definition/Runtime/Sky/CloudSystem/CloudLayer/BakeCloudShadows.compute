#pragma only_renderers d3d11 playstation xboxone xboxseries vulkan metal switch

#pragma enable_d3d11_debug_symbols
#pragma multi_compile_local _ DISABLE_MAIN_LAYER
#pragma multi_compile_local _ USE_CLOUD_MOTION
#pragma multi_compile_local _ USE_FLOWMAP
#pragma multi_compile_local _ USE_SECOND_CLOUD_LAYER
#pragma multi_compile_local _ USE_SECOND_CLOUD_MOTION
#pragma multi_compile_local _ USE_SECOND_FLOWMAP

#pragma kernel BakeCloudShadows KERNEL_NAME=BakeCloudShadows

#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Sky/CloudSystem/CloudLayer/CloudLayerCommon.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl"


RW_TEXTURE2D(float3, _CloudShadows);

float4 _Params;
float4 _Params2;

#define _ShadowTint     _Params.rgb
#define _ShadowOpacity  _Params.a
#define _SunRight       _Params1[0].xyz
#define _SunUp          _Params1[1].xyz
#define _ShadowSize     _Params2.xy
#define _Resolution     _Params2.z

#define EARTH_RADIUS            6378100.0

float GetCloudVolumeDistance(float altitude, float3 originWS, float3 dir)
{
    float3 startPS = originWS + float3(0, EARTH_RADIUS, 0);
    float lenStartPS = length(startPS), rcpLenStartPS = rcp(lenStartPS);
    float cosChi = dot(-dir, startPS * rcpLenStartPS);
    return -IntersectSphere(altitude + EARTH_RADIUS, cosChi, lenStartPS, rcpLenStartPS).x;
}

float ComputeCloudShadow(float2 uv)
{
    /*
    const float width = 0.2;
    float3 dir = _SunDirection + uv.x * width * _SunRight - uv.y * width * _SunUp;

    return 1.0f - RenderClouds(normalize(dir)).a;
*/

    float4 clouds = 0;
    float3 offset = uv.x * _ShadowSize.x * _SunRight - uv.y * _ShadowSize.y * _SunUp;
    offset = 10*float3(uv.x * _ShadowSize.x, _Altitude(0), uv.y * _ShadowSize.y);

    float3 dir1 = offset + GetCloudVolumeDistance(_Altitude(0), offset, _SunDirection) * _SunDirection;
    float3 dir2 = offset + GetCloudVolumeDistance(_Altitude(1), offset, _SunDirection) * _SunDirection;

    dir1 = normalize(offset);

    //float3 dir1 = _SunDirection * _Altitude(0) + offset;
    //float3 dir2 = _SunDirection * _Altitude(1) + offset;

#ifndef DISABLE_MAIN_LAYER
    if (dir1.y >= 0 || !_UpperHemisphere)
        clouds = GetCloudLayerColor(normalize(dir1), 0);
#endif

#ifdef USE_SECOND_CLOUD_LAYER
    if (dir2.y >= 0 || !_UpperHemisphere)
        clouds += GetCloudLayerColor(normalize(dir2), 1) * (1-clouds.a);
#endif

    return 1.0f - clouds.a;
}

    /*
#define _EarthRadius            6378100.0
bool IntersectPlane(float3 ray_originWS, float3 ray_dir, float3 pos, float3 normal, out float t)
{
    float3 ray_originPS = ray_originWS + float3(0, _EarthRadius, 0);
    float denom = dot(normal, ray_dir);
    bool flag = false;
    t = -1.0f;
    if (abs(denom) > 1e-6)
    {
        float3 d = pos - ray_originPS;
        t = dot(d, normal) / denom;
        flag = (t >= 0);
    }
    return flag;
}
float ComputeCloudShadow(uint2 currentCoords)
{
#define _Thickness 800
    float _HighestCloudAltitude = (2000+_Thickness);
#define groundShadowSize 4000

    // C#
    float scaleX = abs(dot(_SunRight, normalize(float3(_SunRight.x, 0.0f, _SunRight.z))));
    float scaleY = abs(dot(_SunUp,    normalize(float3(_SunUp.x,    0.0f, _SunUp.z))));
    float2 _ShadowRegionSize = float2(groundShadowSize * scaleX, groundShadowSize * scaleY);

    float3 shadowPlaneOrigin = _SunDirection.xyz * (_HighestCloudAltitude + _EarthRadius);
    float3 shadowPlaneNormal = -_SunDirection.xyz;

    // Here the plane is guaranteed to intersect, we don't need to test the result
    float t;
    IntersectPlane(0, _SunDirection.xyz, shadowPlaneOrigin, shadowPlaneNormal, t);

    // Compute the position of the shadow plane
    //float3 shadowCookieCenterWS = float3(_WorldSpaceShadowCenter.x, _ShadowPlaneOffset, _WorldSpaceShadowCenter.z) + t * _SunDirection.xyz;
    float3 shadowCookieCenterWS = t * _SunDirection.xyz;
    //shadowCookieCenterWS.xz = fmod(shadowCookieCenterWS.xz, _ShadowRegionSize);

    // Compute the normalized coordinate on the shadow plane
    //float2 uv = float2(dispatchThreadId.x * _Resolution, 1.0 - dispatchThreadId.y * _Resolution) * 2.0 - 1.0;
    float2 normalizedCoord = currentCoords.xy * _Resolution * 2.0f - 1.0f;

    // Compute the origin of the ray properties  in the planet space
    float3 rayOriginWS = (normalizedCoord.x * _SunRight.xyz * _ShadowRegionSize.x + normalizedCoord.y * _SunUp.xyz * _ShadowRegionSize.y) + shadowCookieCenterWS;
    return RenderClouds(normalize(rayOriginWS)).a;
}
    */

[numthreads(8, 8, 1)]
void KERNEL_NAME(uint2 dispatchThreadId : SV_DispatchThreadID)
{
    if (dispatchThreadId.x == 0 || dispatchThreadId.y == 0 || dispatchThreadId.x == (uint)(rcp(_Resolution) - 1) || dispatchThreadId.y == (uint)(rcp(_Resolution) - 1))
    {
        _CloudShadows[dispatchThreadId.xy] = 0;
        return;
    }

    float2 uv = float2(dispatchThreadId.x * _Resolution, 1.0 - dispatchThreadId.y * _Resolution) * 2.0 - 1.0;
    float shadow = ComputeCloudShadow(uv);

    /*
    // Blend with the other borders to make the texture tileable
    const float tiling = 0.5;
    float2 uv2 = uv - (1.0 - tiling);
    float2 weights = saturate(uv2 / tiling);
    weights.x = Smoothstep01(weights.x);
    weights.y = Smoothstep01(weights.y);

    if (uv2.x > 0.0)
        shadow = lerp(shadow, ComputeCloudShadow(uv - float2(2.0, 0.0)), weights.x);

    if (uv2.y > 0.0)
    {
        float shadow2 = ComputeCloudShadow(uv - float2(0.0, 2.0));
        if (uv2.x > 0.0)
            shadow2 = lerp(shadow2, ComputeCloudShadow(uv - float2(2.0, 2.0)), weights.x);

        shadow = lerp(shadow, shadow2, weights.y);
    }
    */

    _CloudShadows[dispatchThreadId] = lerp(1.0 - _ShadowOpacity, 1.0f, shadow);
}
