#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/TextureXR.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Visibility/VisibilityOITResources.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/PostProcessing/Shaders/PostProcessDefines.hlsl"

//#pragma enable_d3d11_debug_symbols
#pragma only_renderers d3d11 playstation xboxone xboxseries vulkan metal switch

#pragma kernel OITSort_Init
#pragma kernel OITSort_BinPixels
#pragma kernel OITSort_Network
#pragma kernel OITSort_GroupShared

RWStructuredBuffer<uint> _OITSortMemoryBuffer;

RWByteAddressBuffer _RWVisOITBuffer;

uint3 LoadPackedVisibilitySample(uint i, uint listOffset)
{
    return _RWVisOITBuffer.Load3(((listOffset + i) * 3) << 2);
}

void StorePackedVisibilitySample(uint i, uint listOffset, uint3 packedSample)
{
    _RWVisOITBuffer.Store3(((listOffset + i) * 3) << 2, packedSample);
}

[numthreads(1, 1, 1)]
void OITSort_Init()
{
    uint sumSmall = _OITSortMemoryBuffer[0];
    uint sumMed = _OITSortMemoryBuffer[1];
    uint sumBig = _OITSortMemoryBuffer[2];

    // 3-5 is counter data

    // Offsets
    // Count <= 4
    _OITSortMemoryBuffer[6] = 0;

    // Count <= 32
    _OITSortMemoryBuffer[7] = sumSmall;

    // Count > 32
    _OITSortMemoryBuffer[8] = sumSmall + sumMed;

    uint3 numGroupsSmall = uint3((sumSmall + 255) / 256, 1, 1);
    uint3 numGroupsMed = uint3((sumMed + 255) / 256, 1, 1);
    uint3 numGroupsBig = uint3(sumBig, 1, 1);

    _OITSortMemoryBuffer[9 + 0] = numGroupsSmall.x;
    _OITSortMemoryBuffer[9 + 1] = numGroupsSmall.y;
    _OITSortMemoryBuffer[9 + 2] = numGroupsSmall.z;

    _OITSortMemoryBuffer[9 + 3] = numGroupsMed.x;
    _OITSortMemoryBuffer[9 + 4] = numGroupsMed.y;
    _OITSortMemoryBuffer[9 + 5] = numGroupsMed.z;

    _OITSortMemoryBuffer[9 + 6] = numGroupsBig.x;
    _OITSortMemoryBuffer[9 + 7] = numGroupsBig.y;
    _OITSortMemoryBuffer[9 + 8] = numGroupsBig.z;
}

[numthreads(8, 8, 1)]
void OITSort_BinPixels(int3 dispatchThreadID : SV_DispatchThreadID)
{
    UNITY_XR_ASSIGN_VIEW_INDEX(dispatchThreadID.z);

    if (any(dispatchThreadID.xy >= (int2)_ScreenSize.xy))
        return;

    uint outputPixel = dispatchThreadID.y * (int)_ScreenSize.x + dispatchThreadID.x;
    uint listCount = _VisOITListsCounts.Load(outputPixel << 2);

    //// List sizes of 0 or 1 don't need any sorting
    if (listCount < 2)
        return;

    uint sortVariantOffset;
    if (listCount <= 4)
    {
        sortVariantOffset = 0;
    }
    else if (listCount <= 32)
    {
        //sortVariantOffset = 1;

        // Override med to big
        sortVariantOffset = 2;
    }
    else
    {
        sortVariantOffset = 2;
    }

    uint sortCounterAddr = 3 + sortVariantOffset;
    uint sortIndexOffsetAddr = 6 + sortVariantOffset;

    uint globalSortIndexOffset = _OITSortMemoryBuffer[sortIndexOffsetAddr];
    uint localSortIndexOffset;
    InterlockedAdd(_OITSortMemoryBuffer[sortCounterAddr], 1, localSortIndexOffset);

    uint sortIndexAddr = 18 + globalSortIndexOffset + localSortIndexOffset;
    _OITSortMemoryBuffer[sortIndexAddr] = outputPixel;
}

// Please turn this into a v_swap ;)
void SwapUint(inout uint a, inout uint b)
{
    uint temp = a;
    a = b;
    b = temp;
}

uint GenerateSortKey(uint keyIndex, uint listCount, uint listOffset)
{
    uint key = 0xFFFFFFFF;
    if (keyIndex < listCount)
    {
        uint depth = ((LoadPackedVisibilitySample(keyIndex, listOffset).y >> 16) & 0xFFFF);
        key = ((depth & 0xFFFF) << 16) | (keyIndex & 0xFFFF);
    }
    return key;
}

uint3 LoadKeyValue(uint sortKey, uint listOffset)
{
    uint3 value = uint3(0, 0, 0);
    if (sortKey != 0xFFFFFFFF)
    {
        uint srcIndex = (sortKey & 0xFFFF);
        value = LoadPackedVisibilitySample(srcIndex, listOffset);
    }
    return value;
}

void StoreKeyValue(uint keyIndex, uint sortKey, uint listOffset, uint3 value)
{
    if (sortKey != 0xFFFFFFFF)
    {
        StorePackedVisibilitySample(keyIndex, listOffset, value);
    }
}

[numthreads(256, 1, 1)]
void OITSort_Network(int3 dispatchThreadId : SV_DispatchThreadID)
{
    uint threadIndex = dispatchThreadId.x;

    // Load pixel index
    uint sortVariantOffset = 0;
    uint sortSumAddr = sortVariantOffset;

    uint numPixels = _OITSortMemoryBuffer[sortSumAddr];

    // Note: this is always 0 since this is the first group
    //uint sortIndexOffsetAddr = 6 + sortVariantOffset;
    //uint globalSortIndexOffset = _OITSortMemoryBuffer.Load(sortIndexOffsetAddr);
    uint globalSortIndexOffset = 0;

    if (threadIndex < numPixels)
    {
        uint pixelIndexAddr = 18 + globalSortIndexOffset + threadIndex;
        uint pixelIndex = _OITSortMemoryBuffer[pixelIndexAddr];

        uint listCount = _VisOITListsCounts.Load(pixelIndex << 2);
        uint listOffset = _VisOITListsOffsets.Load(pixelIndex << 2);

        // Generate sort keys from depth
        uint sortKey0 = GenerateSortKey(0, listCount, listOffset);
        uint sortKey1 = GenerateSortKey(1, listCount, listOffset);
        uint sortKey2 = GenerateSortKey(2, listCount, listOffset);
        uint sortKey3 = GenerateSortKey(3, listCount, listOffset);

        // Sort the keys
        if (sortKey0 > sortKey1)
        {
            SwapUint(sortKey0, sortKey1);
        }
        if (sortKey2 > sortKey3)
        {
            SwapUint(sortKey2, sortKey3);
        }
        if (sortKey0 > sortKey2)
        {
            SwapUint(sortKey0, sortKey2);
        }
        if (sortKey1 > sortKey3)
        {
            SwapUint(sortKey1, sortKey3);
        }
        if (sortKey1 > sortKey2)
        {
            SwapUint(sortKey1, sortKey2);
        }

        // Shuffle the samples based on the sort results
        uint3 packedSample0 = LoadKeyValue(sortKey0, listOffset);
        uint3 packedSample1 = LoadKeyValue(sortKey1, listOffset);
        uint3 packedSample2 = LoadKeyValue(sortKey2, listOffset);
        uint3 packedSample3 = LoadKeyValue(sortKey3, listOffset);

        // TODO: There must be a better way to do this...
        if (listCount == 2)
        {
            StoreKeyValue(0, sortKey1, listOffset, packedSample1);
            StoreKeyValue(1, sortKey0, listOffset, packedSample0);
        }
        else if (listCount == 3)
        {
            StoreKeyValue(0, sortKey2, listOffset, packedSample2);
            StoreKeyValue(1, sortKey1, listOffset, packedSample1);
            StoreKeyValue(2, sortKey0, listOffset, packedSample0);
        }
        else if (listCount == 4)
        {
            StoreKeyValue(0, sortKey3, listOffset, packedSample3);
            StoreKeyValue(1, sortKey2, listOffset, packedSample2);
            StoreKeyValue(2, sortKey1, listOffset, packedSample1);
            StoreKeyValue(3, sortKey0, listOffset, packedSample0);
        }
    }
}

groupshared uint sSums[16];
groupshared uint sKeys[256];

// TODO: Remove this once the serialized reorder step of radix sort is removed
groupshared uint sOutputKeys[256];

[numthreads(256, 1, 1)]
void OITSort_GroupShared(uint3 groupThreadId : SV_GroupThreadID, uint3 groupId: SV_GroupID)
{
    uint threadIndex = groupThreadId.x;

    // Load pixel index

    // Note: This is always 2 since it's the big variant
    uint sortVariantOffset = 2;
    uint sortIndexOffsetAddr = 6 + sortVariantOffset;
    uint globalSortIndexOffset = _OITSortMemoryBuffer.Load(sortIndexOffsetAddr);

    uint pixelIndexAddr = 18 + globalSortIndexOffset + groupId.x;
    uint pixelIndex = _OITSortMemoryBuffer[pixelIndexAddr];

    uint listCount = _VisOITListsCounts.Load(pixelIndex << 2);
    uint listOffset = _VisOITListsOffsets.Load(pixelIndex << 2);

    uint sortKey = GenerateSortKey(threadIndex, listCount, listOffset);

    // Flip the key so the depth is in the LSBs
    sortKey = (sortKey << 16) | (sortKey >> 16);

    sKeys[threadIndex] = sortKey;

    // 16-bit radix sort (we don't bother sorting the top half since they contain indices)
    for (uint radixPassIndex = 0; radixPassIndex < 4; ++radixPassIndex)
    {
        sortKey = sKeys[threadIndex];

        // Initialize the sum bins to 0
        if (threadIndex < 16)
        {
            sSums[threadIndex] = 0;
        }

        uint binIndex = ((sortKey >> (radixPassIndex * 4)) & 0xF);

        GroupMemoryBarrierWithGroupSync();

        // Increment the bin associated with the current value to sort
        InterlockedAdd(sSums[binIndex], 1);

        GroupMemoryBarrierWithGroupSync();

        // Do a dumb prefix sum (replace this with a parallel version)
        if (threadIndex == 0)
        {
            uint previousSum = sSums[0];

            for (uint binIndex = 1; binIndex < 16; ++binIndex)
            {
                uint currentSum = previousSum + sSums[binIndex];
                previousSum = currentSum;

                sSums[binIndex] = currentSum;
            }
        }

        GroupMemoryBarrierWithGroupSync();

        // This is even worse than the prefix sum above! :(
        if (threadIndex == 0)
        {
            uint i = 0;
            for (i = 0; i < 256; ++i)
            {
                uint val = sKeys[255 - i];
                uint localBinIndex = ((val >> (radixPassIndex * 4)) & 0xF);
                uint index = sSums[localBinIndex] - 1;
                sOutputKeys[index] = val;
                sSums[localBinIndex] = index;
                GroupMemoryBarrier();
            }

            for (i = 0; i < 256; ++i)
            {
                sKeys[i] = sOutputKeys[i];
            }
        }

        GroupMemoryBarrierWithGroupSync();
    }

    // Load the final sort key for the current thread
    sortKey = sKeys[threadIndex];

    uint srcKeyIndex = ((sortKey >> 16) & 0xFFFF);
    uint dstKeyIndex = threadIndex;

    uint3 packedSample;
    if (dstKeyIndex < listCount)
    {
        packedSample = LoadPackedVisibilitySample(srcKeyIndex, listOffset);
    }

    GroupMemoryBarrierWithGroupSync();

    if (dstKeyIndex < listCount)
    {
        StorePackedVisibilitySample((listCount - 1) - dstKeyIndex, listOffset, packedSample);
    }
}

