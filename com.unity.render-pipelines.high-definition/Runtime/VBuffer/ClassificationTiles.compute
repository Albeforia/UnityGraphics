#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Builtin/BuiltinData.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Packing.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/VBuffer/VisibilityBufferCommon.hlsl"

#pragma enable_d3d11_debug_symbols

#pragma kernel CreateVisibilityBuffClassification

#define LIGHTFEATURE_ONLY
#define CLASSIFICATION_TYPE

// #define LIGHT_FEATURE_MASK_FLAGS_OPAQUE (16642048)

StructuredBuffer<uint> g_TileFeatureFlags;
RW_TEXTURE2D_X(uint2, _ClassificationTile);

float4 _TileBufferSize;

#define TILE_SIZE_FPTL 16

[numthreads(8, 8, 1)]
void CreateVisibilityBuffClassification(uint3 id : SV_DispatchThreadID)
{
    uint2 topLeftTileCoord = id.xy * 4;

    if (any(id.xy < _TileBufferSize.xy))
    {
        uint screenWidth = (uint)_ScreenSize.x;
        uint numTilesX = (screenWidth + (TILE_SIZE_FPTL) - 1) / TILE_SIZE_FPTL;

        uint featureSet = 0;
        // Very dumb loop. Can be vastly improved with LDS or wave intrinsics.
        for (int x = 0; x < 4; ++x)
        {
            for (int y = 0; y < 4; ++y)
            {
                uint2 tileCoord = topLeftTileCoord + uint2(x, y);
                uint tileIndex = tileCoord.x + tileCoord.y * numTilesX;

                featureSet |= g_TileFeatureFlags[tileIndex];
            }
        }

        _ClassificationTile[COORD_TEXTURE2D_X(id.xy)] = featureSet;
    }

}
