
        Pass
        {
            Name "ForwardDXR"
            Tags{ "LightMode" = "ForwardDXR" }

            HLSLPROGRAM
            #pragma target 4.5
            #pragma only_renderers d3d11 ps5
            #pragma raytracing surface_shader

            // Global includes
            #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl"

            // Define the shader pass
            #define SHADERPASS SHADERPASS_RAYTRACING_FORWARD

            // We are in a ray tracing pass, we can only support low shadows
            #define SHADOW_LOW

            // Need to override the macros for ray tracing
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/RaytracingMacros.hlsl"

            // Shader variables
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/ShaderVariablesRaytracing.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/ShaderVariablesRaytracingLightLoop.hlsl"

            // VFX includes
            ${VFXIncludeRP("Templates/PlanarPrimitive/DXR/Common/RayTracingInputStructure.template")}
            ${VFXHDRPLitVaryingsMacros}
            ${VFXPerPassInclude}
            ${VFXIncludeRP("VFXLit.template")}

            // Needs to be included after the VFX includes
            ${VFXIncludeRP("Templates/PlanarPrimitive/DXR/Lit/IntersectionFunctions.template")}

            // Lighting and material includes
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/Lighting.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoopDef.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/RaytracingIntersection.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/Common/RayTracingProcedural.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/RaytracingLightLoop.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/RayTracingCommon.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/Common/AtmosphericScatteringRayTracing.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/Forward/EvaluateRayTracingForward.hlsl"

            // Defines for the attributes
            ${VFXIncludeRP("VFXLitVaryings.template")}

            // Graph functions
            ${VFXGeneratedBlockFunction}

            [shader("closesthit")]
            void ClosestHit(inout RayIntersection rayIntersection : SV_RayPayload, AttributeData attributeData : SV_IntersectionAttributes)
            {
                UNITY_XR_ASSIGN_VIEW_INDEX(DispatchRaysIndex().z);

                // Compute the distance of the ray
                rayIntersection.t = RayTCurrent();

                // Evaluate the position
                float3 positionRWS = WorldRayOrigin() + rayIntersection.t * WorldRayDirection();

                // Index needs to be available in the context for the attribute load to work
                ${VFXGetIndexFromRTPrimitiveIndex}

                // Attributes of the paticle
                VFXAttributes attributes;
                ZERO_INITIALIZE(VFXAttributes, attributes);

                // Load the VFX attributes that we need for this
                ${VFXLoadAttributes}
                ${VFXProcessBlocks}
                ${VFXLoadSize}

                // Build the "varying" input
                rt_input o;
                ZERO_INITIALIZE(rt_input, o);

                // Fill the attributes
                ${VFXVertexCommonProcess}
                ${VFXHDRPLitFillVaryings}

                o.VFX_VARYING_UV.xy = attributeData.barycentrics;
                #ifdef VFX_VARYING_BENTFACTORS
	                ${VFXLoadParameter:{normalBendingFactor}}
	                #define BENT_FACTOR_MULTIPLIER 1.41421353816986083984375f
	                o.VFX_VARYING_BENTFACTORS = (o.VFX_VARYING_UV.xy - 0.5f) * normalBendingFactor * BENT_FACTOR_MULTIPLIER;
	            #endif
                ${VFXVertexSetFlipbooksInterpolants}

                rt_input i = o;
                i.VFX_VARYING_NORMAL = normalize(-WorldToPrimitive(attributes, size3)[2].xyz);
#ifdef VFX_VARYING_TANGENT
                i.VFX_VARYING_TANGENT = normalize(WorldToPrimitive(attributes, size3)[0].xyz);
#endif

                bool frontFace = dot(WorldRayDirection(), i.VFX_VARYING_NORMAL) < 0;
                ${VFXComputeNormalWS}

                // Output structures
                SurfaceData surfaceData = (SurfaceData)0;
                BuiltinData builtinData = (BuiltinData)0;
                BSDFData bsdfData = (BSDFData)0;
                PreLightData preLightData = (PreLightData)0;


                // Evaluate the position input
                PositionInputs posInput = GetPositionInput(rayIntersection.pixelCoord, _ScreenSize.zw, positionRWS);

                // Evaluate the input data
                VFXGetHDRPLitData(surfaceData, builtinData, bsdfData, preLightData, i, normalWS, posInput, uvData, 0);

                // Evaluate the view direction
                float3 viewWS = -WorldRayDirection();

                // Evaluate the forward lighting
                EvaluateForwardRayTracingLighting(preLightData, posInput, bsdfData, builtinData, surfaceData, viewWS, positionRWS, bsdfData.normalWS, true, rayIntersection);

                // Apply fog attenuation
                ApplyFogAttenuation(WorldRayOrigin(), WorldRayDirection(), rayIntersection.t, rayIntersection.color, true);
            }

            // Inject the intersection shader
            ${VFXIncludeRP("Templates/PlanarPrimitive/DXR/Common/IntersectionShader.template")}
            ENDHLSL
        }
