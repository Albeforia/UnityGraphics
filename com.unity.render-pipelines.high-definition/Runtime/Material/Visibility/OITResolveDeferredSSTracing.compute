#ifdef SURFACE_GRADIENT
#undef SURFACE_GRADIENT
#endif
#ifdef DECAL_SURFACE_GRADIENT
#undef DECAL_SURFACE_GRADIENT
#endif

#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/GeometricTools.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/TextureXR.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Visibility/VisibilityOITResources.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/PostProcessing/Shaders/PostProcessDefines.hlsl"

#define VARIANT_DIR_PUNCTUAL_AREA_ENV 1
#define HAS_LIGHTLOOP

#define DISABLE_APPLY_DEBUG_TO_LIGHTING

#define SHADERPASS SHADERPASS_VBUFFER_LIGHTING_OFFSCREEN

#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/LitProperties.hlsl"

#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/Lighting.hlsl"

#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/ShaderPass/LitDepthPass.hlsl"

#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoopDef.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoop.hlsl"

#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/LitData.hlsl"

#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/CommonLighting.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/EntityLighting.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Sky/SkyUtils.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/SDF2D.hlsl"

#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariablesFunctions.hlsl"

//#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/HDShadow.hlsl"
//#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoopDef.hlsl"
//#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/PunctualLightCommon.hlsl"
//#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoop.cs.hlsl"
//#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Builtin/BuiltinData.hlsl"
//#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoop.hlsl"

#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Visibility/VisibilityOITResources.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Visibility/VBufferDeferredMaterialCommon.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Visibility/BTDF.hlsl"

#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Random.hlsl" // TODO: replace with blue noise helper and scramble textures
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Visibility/BTDF.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/ImageBasedLighting.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/RaytracingSampling.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/RayTracingCommon.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariablesGlobal.cs.hlsl"

//#pragma enable_d3d11_debug_symbols
#pragma only_renderers d3d11 playstation xboxone xboxseries vulkan metal switch

#pragma kernel MainResolveOffscreenLighting

#define GROUP_SIZE 8

#if UNITY_REVERSED_Z
# define MIN_DEPTH(a, b) max(a, b)
#else
# define MIN_DEPTH(a, b) min(a, b)
#endif

TEXTURE2D_X(_DepthTexture);
RW_TEXTURE2D_X(float4, _OutputTexture);

float4 _VBufferLightingOffscreenParams;
int _OITHiZMaxMip;
StructuredBuffer<int2> _DepthPyramidMipLevelOffsets;

float3 viridis(float t)
{
    const float3 c0 = float3(0.2777273272234177, 0.005407344544966578, 0.3340998053353061);
    const float3 c1 = float3(0.1050930431085774, 1.404613529898575, 1.384590162594685);
    const float3 c2 = float3(-0.3308618287255563, 0.214847559468213, 0.09509516302823659);
    const float3 c3 = float3(-4.634230498983486, -5.799100973351585, -19.33244095627987);
    const float3 c4 = float3(6.228269936347081, 14.17993336680509, 56.69055260068105);
    const float3 c5 = float3(4.776384997670288, -13.74514537774601, -65.35303263337234);
    const float3 c6 = float3(-5.435455855934631, 4.645852612178535, 26.3124352495832);

    return c0 + t * (c1 + t * (c2 + t * (c3 + t * (c4 + t * (c5 + t * c6)))));
}

float3 plasma(float t)
{
    const float3 c0 = float3(0.05873234392399702, 0.02333670892565664, 0.5433401826748754);
    const float3 c1 = float3(2.176514634195958, 0.2383834171260182, 0.7539604599784036);
    const float3 c2 = float3(-2.689460476458034, -7.455851135738909, 3.110799939717086);
    const float3 c3 = float3(6.130348345893603, 42.3461881477227, -28.51885465332158);
    const float3 c4 = float3(-11.10743619062271, -82.66631109428045, 60.13984767418263);
    const float3 c5 = float3(10.02306557647065, 71.41361770095349, -54.07218655560067);
    const float3 c6 = float3(-3.658713842777788, -22.93153465461149, 18.19190778539828);

    return c0 + t * (c1 + t * (c2 + t * (c3 + t * (c4 + t * (c5 + t * c6)))));
}

float3 magma(float t)
{
    const float3 c0 = float3(-0.002136485053939582, -0.000749655052795221, -0.005386127855323933);
    const float3 c1 = float3(0.2516605407371642, 0.6775232436837668, 2.494026599312351);
    const float3 c2 = float3(8.353717279216625, -3.577719514958484, 0.3144679030132573);
    const float3 c3 = float3(-27.66873308576866, 14.26473078096533, -13.64921318813922);
    const float3 c4 = float3(52.17613981234068, -27.94360607168351, 12.94416944238394);
    const float3 c5 = float3(-50.76852536473588, 29.04658282127291, 4.23415299384598);
    const float3 c6 = float3(18.65570506591883, -11.48977351997711, -5.601961508734096);

    return c0 + t * (c1 + t * (c2 + t * (c3 + t * (c4 + t * (c5 + t * c6)))));
}

float3 inferno(float t)
{
    const float3 c0 = float3(0.0002189403691192265, 0.001651004631001012, -0.01948089843709184);
    const float3 c1 = float3(0.1065134194856116, 0.5639564367884091, 3.932712388889277);
    const float3 c2 = float3(11.60249308247187, -3.972853965665698, -15.9423941062914);
    const float3 c3 = float3(-41.70399613139459, 17.43639888205313, 44.35414519872813);
    const float3 c4 = float3(77.162935699427, -33.40235894210092, -81.80730925738993);
    const float3 c5 = float3(-71.31942824499214, 32.62606426397723, 73.20951985803202);
    const float3 c6 = float3(25.13112622477341, -12.24266895238567, -23.07032500287172);

    return c0 + t * (c1 + t * (c2 + t * (c3 + t * (c4 + t * (c5 + t * c6)))));
}

uint GetOffscreenLightBufferWidth()
{
    return asuint(_VBufferLightingOffscreenParams.x);
}

// Weight for SSR where Fresnel == 1 (returns value/pdf)
float GetSSRSampleWeight(float3 V, float3 L, float roughness)
{
    // Simplification:
    // value = D_GGX / (lambdaVPlusOne + lambdaL);
    // pdf = D_GGX / lambdaVPlusOne;

    const float lambdaVPlusOne = Lambda_GGX(roughness, V) + 1.0;
    const float lambdaL = Lambda_GGX(roughness, L);

    return lambdaVPlusOne / (lambdaVPlusOne + lambdaL);
}

#define SSR_TRACE_EPS               0.000488281f // 2^-11, should be good up to 4K
#define MIN_GGX_ROUGHNESS           0.00001f
#define MAX_GGX_ROUGHNESS           0.99999f

// Specialization without Fresnel (see PathTracingBSDF.hlsl for the reference implementation)
bool SampleGGX_VNDF(float roughness_,
    float3x3 localToWorld,
    float3 V,
    float2 inputSample,
    out float3 outgoingDir,
    out float weight)
{
    weight = 0.0f;

    float roughness = clamp(roughness_, MIN_GGX_ROUGHNESS, MAX_GGX_ROUGHNESS);

    float VdotH;
    float3 localV, localH;
    SampleGGXVisibleNormal(inputSample.xy, V, localToWorld, roughness, localV, localH, VdotH);

    // Compute the reflection direction
    float3 localL = 2.0 * VdotH * localH - localV;
    outgoingDir = mul(localL, localToWorld);

    if (localL.z < 0.001)
    {
        return false;
    }

    weight = GetSSRSampleWeight(localV, localL, roughness);

    if (weight < 0.001)
        return false;

    return true;
}

//RW_TEXTURE2D(float4, _OITDebugSSTracing);
RWTexture2D<float4> _OITDebugSSTracing;

void WriteDebugInfo(uint2 positionSS, float4 value)
{
    _OITDebugSSTracing[positionSS] = value;
}

void SampleVNDF(uint2 positionSS, float roughness, float deviceDepth, float3 normalWS, float ior, out float3 positionWS, out float weight, out float3 wi/*, out float3 wo*/, out float cos0i, out float cos0o, out float cos0h, out float cos0vh)
{
    float2 Xi;
    Xi.x = GetBNDSequenceSample(positionSS, _FrameCount, 0);
    Xi.y = GetBNDSequenceSample(positionSS, _FrameCount, 1);

    float3x3 localToWorld = GetLocalFrame(normalWS);

    float2 positionNDC = positionSS * _ScreenSize.zw + (0.5 * _ScreenSize.zw);
    positionWS = ComputeWorldSpacePosition(positionNDC, deviceDepth, UNITY_MATRIX_I_VP);
    float3 wo = GetWorldSpaceNormalizeViewDir(positionWS);

    float value;

    //SampleGGX_VNDF(roughness,
    //               localToWorld,
    //               wo,
    //               Xi,
    //               wi,
    //               weight);
    weight = 1.0f;
    wi = refract(-wo, normalWS, 1.0f / ior);
    //wi = reflect(-wo, normalWS);

    cos0o = dot(normalWS, wo);
    cos0i = dot(normalWS, wi);
    float3 wh = normalize(wo + wi);
    cos0h = dot(normalWS, wh);
    cos0vh = dot(wo, wh);
}

bool    GetBoundDeviceZ(uint2 posSS, float srcDeviceDepth, out float outDeviceDepth)
{
    PositionInputs posInputs = GetPositionInput(float2(posSS.xy), _ScreenSize.zw, uint2(GROUP_SIZE, GROUP_SIZE));

    uint pixelOffset = posSS.y * _ScreenSize.x + posSS.x;
    uint listCount, listOffset;
    VisibilityOIT::GetPixelList(pixelOffset, listCount, listOffset);
    if (listCount == 0)
    {
        outDeviceDepth = UNITY_RAW_FAR_CLIP_VALUE;
        return false;
    }

    uint sortIndicesBaseAddr = kSorting_PixelListDataOffset + (_ScreenSize.x * _ScreenSize.y) + listOffset;

    float previousDeviceDepth = 0.0f;
    for (uint i = 0; i < listCount; ++i)
    {
        uint sortedSampleIndex = i;

        // Load sorted indices when working with multi-sample lists
        if (listCount >= 2)
        {
            // Load the sorted index that corresponds to the i'th sample
            uint sortIndexAddr = sortIndicesBaseAddr + i;
            sortedSampleIndex = _OITSortMemoryBuffer[sortIndexAddr];
        }

        int globalOffset = sortedSampleIndex + listOffset;
        uint2 offscreenCoord = uint2(globalOffset % GetOffscreenLightBufferWidth(), globalOffset / GetOffscreenLightBufferWidth());

        Visibility::VisibilityData unusedVisData;
        uint2 unusedTexelCoord;
        float deviceDepth;
        float linearDepth;
        VisibilityOIT::GetVisibilitySampleWithLinearDepth(sortedSampleIndex, listOffset, unusedVisData, unusedTexelCoord, deviceDepth, linearDepth);
        if (srcDeviceDepth < deviceDepth)
        {
            outDeviceDepth = previousDeviceDepth;
            return true;
        }

        previousDeviceDepth = deviceDepth;
    }

    outDeviceDepth = srcDeviceDepth;
    return false;
}

[numthreads(GROUP_SIZE, GROUP_SIZE, 1)]
void MainResolveOffscreenLighting(int3 dispatchThreadId : SV_DispatchThreadID)
{
    UNITY_XR_ASSIGN_VIEW_INDEX(dispatchThreadId.z);
    if (any((float2)dispatchThreadId.xy > _ScreenSize.xy))
        return;

    PositionInputs posInputRaw = GetPositionInput(float2(dispatchThreadId.xy) + 0.5f, _ScreenSize.zw, uint2(GROUP_SIZE, GROUP_SIZE));

    uint pixelOffset = dispatchThreadId.y * _ScreenSize.x + dispatchThreadId.x;
    uint listCount, listOffset;
    VisibilityOIT::GetPixelList(pixelOffset, listCount, listOffset);

    if (listCount == 0)
        return;

    float firstDeviceDepth = 0.0;
    float firstLinearDepth = 0.0;
    int globalOffset;
    uint2 offscreenCoord;
    uint firstSampleIndex = 0;
    uint sortedSampleIndex;
    if (listCount <= firstSampleIndex)
        return;

    {
        sortedSampleIndex = Sorting::GetSortedSampleIndex(firstSampleIndex, listCount, listOffset);

        globalOffset = listOffset + sortedSampleIndex;
        offscreenCoord = uint2(globalOffset % GetOffscreenLightBufferWidth(), globalOffset / GetOffscreenLightBufferWidth());

        Visibility::VisibilityData unusedVisData;
        uint2 unusedTexelCoord;
        VisibilityOIT::GetVisibilitySampleWithLinearDepth(sortedSampleIndex, listOffset, unusedVisData, unusedTexelCoord, firstDeviceDepth, firstLinearDepth);
    }

    uint4 packedOITGBuffer0 = _VisOITOffscreenGBuffer0[COORD_TEXTURE2D_X(offscreenCoord)].rgba;
    uint2 packedOITGBuffer1 = _VisOITOffscreenGBuffer1[COORD_TEXTURE2D_X(offscreenCoord)].rg;
    float3 normal;
    float roughness;
    float3 baseColor;
    float metalness;
    float3 absorptionCoefficient;
    float ior;
    VisibilityOIT::UnpackOITGBufferData(packedOITGBuffer0, packedOITGBuffer1, normal, roughness, baseColor, metalness, absorptionCoefficient, ior);

    float opaqueDeviceDepth = LOAD_TEXTURE2D_X(_DepthTexture, dispatchThreadId.xy).r;
    //float opaqueDeviceDepth = LOAD_TEXTURE2D_X(_CameraDepthTexture, dispatchThreadId.xy).r;

    PositionInputs posInputOpaque = GetPositionInput((float2)dispatchThreadId.xy + 0.5f, _ScreenSize.zw);
    posInputOpaque.positionWS = ComputeWorldSpacePosition(posInputOpaque.positionNDC, opaqueDeviceDepth, UNITY_MATRIX_I_VP);
    float opaqueDepthLinear = LinearEyeDepth(posInputOpaque.positionWS, GetWorldToViewMatrix());
    //opaqueDepthLinear = (opaqueDepthLinear - _ProjectionParams.y) / (_ProjectionParams.z - _ProjectionParams.y);

    PositionInputs posInputTransparent = GetPositionInput(dispatchThreadId.xy + 0.5f, _ScreenSize.zw, uint2(GROUP_SIZE, GROUP_SIZE));
    posInputTransparent.positionWS = ComputeWorldSpacePosition(posInputTransparent.positionNDC, firstDeviceDepth, UNITY_MATRIX_I_VP);
    float transparentDepthLinearEye = LinearEyeDepth(posInputTransparent.positionWS, GetWorldToViewMatrix());
    float transparentDepthLinear = transparentDepthLinearEye;
    //float transparentDepthLinear = (transparentDepthLinearEye - near) / (far - near);

    if (firstDeviceDepth < opaqueDeviceDepth)
    {
        //_OutputTexture[COORD_TEXTURE2D_X(posInputRaw.positionSS.xy)] = float4(1.0, 0.0, 0.0, 1.0);
        return;
    }

    const float near = _ProjectionParams.y;
    const float far = _ProjectionParams.z;

    float3 wo = normalize(_WorldSpaceCameraPos - posInputTransparent.positionWS);

#define ENABLE_SS_TRACING 1

#if ENABLE_SS_TRACING

    uint2 positionSS = dispatchThreadId.xy;

    float3 wr = reflect(-wo, normal);
    float3 wt = refract(-wo, normal, ior);

    float3 positionWS;
    float weight;
    float3 wi;
    //float3 wo;
    float cos0i;
    float cos0o;
    float cos0h;
    float cos0vh;
    SampleVNDF(
        // Inputs
        positionSS, roughness, firstDeviceDepth, normal, ior,
        // Outputs
        positionWS, weight, wt, cos0i, cos0o, cos0h, cos0vh);

    bool frontFace = dot(wo, normal) > 0.0f;

    //float3 startPosWS = posInputTransparent.positionWS + 0.125f * normal;
    float3 startPosWS = posInputTransparent.positionWS * (1 - 0.001 * rcp(max(dot(normal, wo), FLT_EPS)));
    //float3 startPosWS = posInputTransparent.positionWS;

    float3 camPosWS = GetCurrentViewPosition();
    //float3 dir = wt;
    //camPosWS + (positionWS - camPosWS) * (1 - 0.001 * rcp(max(dot(N, V), FLT_EPS)));
    float3 stepWS = startPosWS + 5.0f * wt;
    float3 stepNDC = ComputeNormalizedDeviceCoordinatesWithZ(stepWS, UNITY_MATRIX_VP);
    float stepDepthLinear = LinearEyeDepth(stepWS, GetWorldToViewMatrix());
    //stepDepthLinear = (stepDepthLinear - _ProjectionParams.y) / (_ProjectionParams.z - _ProjectionParams.y);

    float3 step = float3((stepNDC.xy * _ScreenSize.xy), stepDepthLinear);

    //float3 startNDC = ComputeNormalizedDeviceCoordinatesWithZ(startPosWS, UNITY_MATRIX_VP);
    float startDepthLinear = LinearEyeDepth(startPosWS, GetWorldToViewMatrix());

    float3 p = float3(posInputRaw.positionSS.xy + 0.5f, startDepthLinear/*transparentDepthLinear - 1.0f*/);
    float3 dir = normalize(step - p);

    //if (dir.z < 0.0f)
    //    return;

    float scale = 1.0f / length(dir.xy);
    dir *= scale;

    float curIOR = ior;

    #define maxTransparentHit 1
    float3 hits[maxTransparentHit] = (float3[maxTransparentHit])0;
    float4 infos[maxTransparentHit] = (float4[maxTransparentHit])0;

    bool hitOpaque = false;
    bool hitFar = false;
    float3 previous;
    int k;
    bool hitTransparent = false;
    uint curTransparentHit = 1;

    float energy = 1.0f;

    float distance = 0.0f;

#define MAX_ITER 512

    UNITY_LOOP
    for (k = 0; k < MAX_ITER; ++k)
    {
        previous = p;
        previous.xy = (p.xy);

        // Paranoid loop
        UNITY_LOOP
        for (int u = 0; u < 128; u++)
        {
            p += 0.025f * dir;
            if (any((int2)(p.xy) != (int2)(previous.xy)))
            {
                break;
            }
        }

        distance += length(previous - p);

        //if (distance > far)
        //{
        //    curTransparentHit == 0;
        //    break;
        //}

        float opaqueDeviceDepth_k = LOAD_TEXTURE2D_X(_DepthTexture, p.xy).r;
        float3 opaquePositionWS_k = ComputeWorldSpacePosition(p.xy * _ScreenSize.zw, opaqueDeviceDepth_k, UNITY_MATRIX_I_VP);
        float opaqueDepthLinear_k = LinearEyeDepth(opaquePositionWS_k, GetWorldToViewMatrix());

        if (p.z >= opaqueDepthLinear_k)
        {
            float curDeviceDepth = DeviceDepthFromLinearEye(p.z, _ZBufferParams);
            float prevDeviceDepth = DeviceDepthFromLinearEye(previous.z, _ZBufferParams);
            //float2 prevXY = round(previous.xy) + 0.5f;
            float2 prevXY = previous.xy;
            float3 previousWS = ComputeWorldSpacePosition(prevXY * _ScreenSize.zw, prevDeviceDepth, UNITY_MATRIX_I_VP);
            //float2 curXY = round(p.xy) + 0.5f;
            float2 curXY = p.xy;
            float3 currentWS = ComputeWorldSpacePosition(curXY * _ScreenSize.zw, curDeviceDepth, UNITY_MATRIX_I_VP);
            float3 sampleWS = ComputeWorldSpacePosition(curXY * _ScreenSize.zw, opaqueDeviceDepth_k, UNITY_MATRIX_I_VP);
            float3 v0 = normalize(currentWS - previousWS);
            float3 v1 = normalize(sampleWS - previousWS);
            if (dot(v0, v1) > 0.1f)
            {
                hitOpaque = true;
                break;
            }
            else
            {
                hitFar = true;
                break;
            }
        }

        uint pixelOffset_k = (uint)p.y * _ScreenSize.x + (uint)p.x;
        //uint pixelOffset_k = round(p.y) * _ScreenSize.x + round(p.x);
        //uint pixelOffset_k = round(p.y * _ScreenSize.x + p.x);
        uint listCount_k, listOffset_k;
        VisibilityOIT::GetPixelList(pixelOffset_k, listCount_k, listOffset_k);

        //if (false && listCount_k > 0 && curTransparentHit < maxTransparentHit)
        if (listCount_k > 0 && curTransparentHit < maxTransparentHit)
        {
            hitTransparent = false;
            uint2 offscreenCoord_best;
            float roughness_best;
            float ior_best;
            float3 normal_best;
            float measure_best = -1.0f;
            //float measure_best = 100.0f;
            for (uint q = 0; q < listCount_k; ++q)
            {
                uint sortedSampleIndex_q = listCount_k >= 2 ? Sorting::GetSortedSampleIndex(q, listCount_k, listOffset_k) : 0;
                int globalOffset_q = sortedSampleIndex_q + listOffset_k;
                uint2 offscreenCoord_q = uint2(globalOffset_q % GetOffscreenLightBufferWidth(), globalOffset / GetOffscreenLightBufferWidth());

                uint4 packedOITGBuffer0_q = _VisOITOffscreenGBuffer0[COORD_TEXTURE2D_X(offscreenCoord_q)].rgba;
                uint2 packedOITGBuffer1_q = _VisOITOffscreenGBuffer1[COORD_TEXTURE2D_X(offscreenCoord_q)].rg;
                float3 normal_q;
                float roughness_q;
                float3 baseColor_q;
                float metalness_q;
                float3 absorptionCoefficient_q;
                float ior_q;
                VisibilityOIT::UnpackOITGBufferData(packedOITGBuffer0_q, packedOITGBuffer1_q, normal_q, roughness_q, baseColor_q, metalness_q, absorptionCoefficient_q, ior_q);

                float cos0t = dot(dir, normal_q);

                if ( frontFace && cos0t <= 0.0f ||
                    !frontFace && cos0t >= 0.0f)
                {
                    continue;
                }

                Visibility::VisibilityData unusedVisData_q;
                uint2 unusedTexelCoord_q;
                float deviceDepth_q;
                float linearDepth_q;
                VisibilityOIT::GetVisibilitySampleWithLinearDepth(sortedSampleIndex_q, listOffset_k, unusedVisData_q, unusedTexelCoord_q, deviceDepth_q, linearDepth_q);

                //if (linearDepth_q + 0.5f > p.z)
                //{
                //    break;
                //}

                //if (listCount_k == 2)
                //{
                //    _OutputTexture[COORD_TEXTURE2D_X(dispatchThreadId.xy)] = float4(1.0, 0.0, 0.0, 1.0);
                //    return;
                //}

                // Is Hit test
        #if 0
                float measure_q = abs(linearDepth_q - p.z);
                if (measure_q < measure_best)
                {
                    ior_best = ior_q;
                    measure_best = measure_q;
                    offscreenCoord_best = offscreenCoord_q;
                    roughness_best = roughness_q;
                    normal_best = normal_q;
                }
        #elif 0
                const float epsilon = ((p.z - near) / (far - near)) / max(_ScreenSize.x, _ScreenSize.z);
                    //0.5f;
                    //max(_ScreenSize.x, _ScreenSize.z);
                    //max(_ScreenSize.x, _ScreenSize.z) * (near + p.z) / near;
                    //0.00125f * (near + (p.z - near) + near) / near;
                // Sphere hit
                bool intersect;
                float2 hit;
                if (IntersectRaySphere(previous - float3((float2)((int2)p.xy), linearDepth_q), dir, epsilon, hit))
                {
                    hitTransparent = true;
                    dir = refract(dir,
                        frontFace ? -normal_q : normal_q, frontFace ? 1.0f / ior_q : ior_q);
                    hits[curTransparentHit] = _VisOITOffscreenDirectReflectionLighting[COORD_TEXTURE2D_X(offscreenCoord_q)].rgb;
                    infos[curTransparentHit].x = roughness_q;
                    break;
                }
        #else
                float curDeviceDepth = DeviceDepthFromLinearEye(p.z, _ZBufferParams);
                float prevDeviceDepth = DeviceDepthFromLinearEye(previous.z, _ZBufferParams);
                float2 prevXY = round(previous.xy) + 0.5f;
                float3 previousWS = ComputeWorldSpacePosition(prevXY * _ScreenSize.zw, prevDeviceDepth, UNITY_MATRIX_I_VP);
                float2 curXY = round(p.xy) + 0.5f;
                float3 currentWS = ComputeWorldSpacePosition(curXY * _ScreenSize.zw, curDeviceDepth, UNITY_MATRIX_I_VP);
                float3 sampleWS = ComputeWorldSpacePosition(curXY * _ScreenSize.zw, deviceDepth_q, UNITY_MATRIX_I_VP);
                float3 v0 = normalize(currentWS - previousWS);
                float3 v1 = normalize(sampleWS - previousWS);
                float measure_q = dot(v0, v1);
                if (measure_q > measure_best)
                {
                    measure_best = measure_q;
                    ior_best = ior_q;
                    offscreenCoord_best = offscreenCoord_q;
                    roughness_best = roughness_q;
                    normal_best = normal_q;
                }
        #endif
            }
#if 0
            if (measure_best < 0.025f)
            {
                float curIOR = frontFace ? 1.0f / ior_best : ior_best;
                dir = refract(dir,
                    frontFace ? -normal_best : normal_best, curIOR);
                //dir = refract(dir,
                //    frontFace ? -normal_best : normal_best, frontFace ? ior_best : 1.0f / ior_best);
                scale = 1.0f / length(dir.xy);
                dir *= scale;
                hits[curTransparentHit] = _VisOITOffscreenDirectReflectionLighting[COORD_TEXTURE2D_X(offscreenCoord_best)].rgb;
                infos[curTransparentHit].w = roughness_best;
                previous += 2.0f * dir;
                p += 2.0f * dir;
                float fresnel_q = F_FresnelDielectric(curIOR, abs(dot(normal_best, dir)));
                infos[curTransparentHit].xyz = fresnel_q;
                energy *= fresnel_q;
                frontFace = !frontFace;
                hitTransparent = false;
                ++curTransparentHit;
            }
#else
            if (measure_best > 0.95f)
            {
                float curIOR = frontFace ? 1.0f / ior_best : ior_best;
                //float curIOR = frontFace ? ior_best : 1.0f / ior_best;
                dir = refract(dir,
                    frontFace ? -normal_best : normal_best, curIOR);
                //dir = refract(dir,
                //    frontFace ? -normal_best : normal_best, frontFace ? ior_best : 1.0f / ior_best);
                scale = 1.0f / length(dir.xy);
                dir *= scale;
                hits[curTransparentHit] = _VisOITOffscreenDirectReflectionLighting[COORD_TEXTURE2D_X(offscreenCoord_best)].rgb;
                infos[curTransparentHit].w = roughness_best;
                previous += 2.0f * dir;
                p += 2.0f * dir;
                float fresnel_q = F_FresnelDielectric(curIOR, abs(dot(normal_best, dir)));
                infos[curTransparentHit].xyz = fresnel_q;
                energy *= fresnel_q;
                //hitTransparent = true;
            //}
            //if (hitTransparent)
            //{
                frontFace = !frontFace;
                hitTransparent = false;
                ++curTransparentHit;
            }
#endif
        }
    }

    if (k == MAX_ITER)
        return;

    UNITY_BRANCH
    if (hitOpaque)
    {
        float3 ended = 0.5f * (p + previous);
        //float curDeviceDepth = DeviceDepthFromLinearEye(p.z, _ZBufferParams);
        //float prevDeviceDepth = DeviceDepthFromLinearEye(previous.z, _ZBufferParams);
        //float2 prevXY = round(previous.xy) + 0.5f;
        //float3 previousWS = ComputeWorldSpacePosition(prevXY * _ScreenSize.zw, prevDeviceDepth, UNITY_MATRIX_I_VP);
        //float2 curXY = round(p.xy) + 0.5f;
        //float3 currentWS = ComputeWorldSpacePosition(curXY * _ScreenSize.zw, curDeviceDepth, UNITY_MATRIX_I_VP);
        //float3 viewDir = normalize(currentWS - previousWS);
        //float perceptualRoughness = RoughnessToPerceptualRoughness(infos[curTransparentHit - 1].w);
        float perceptualRoughness = RoughnessToPerceptualRoughness(roughness);
        float3 opaqueHit = SAMPLE_TEXTURE2D_X_LOD(_VisOITOpaqueColorPyramid, s_trilinear_clamp_sampler, ended.xy * _ScreenSize.zw, perceptualRoughness * 8).rgb;
        float3 results = opaqueHit;
        for (int i = curTransparentHit - 1; i >= 0; --i)
        {
            results += hits[i] * infos[i].rgb;
        }

        _OutputTexture[COORD_TEXTURE2D_X(dispatchThreadId.xy)] = float4(0.75f * results / ((float)(curTransparentHit + 0*1)), 1.0);
        return;
    }
    else
    {
        float curDeviceDepth = DeviceDepthFromLinearEye(p.z, _ZBufferParams);
        float prevDeviceDepth = DeviceDepthFromLinearEye(previous.z, _ZBufferParams);
        float2 prevXY = previous.xy;
        float3 previousWS = ComputeWorldSpacePosition(prevXY * _ScreenSize.zw, prevDeviceDepth, UNITY_MATRIX_I_VP);
        float2 curXY = p.xy;
        float3 currentWS = ComputeWorldSpacePosition(curXY * _ScreenSize.zw, curDeviceDepth, UNITY_MATRIX_I_VP);
        float3 viewDir = normalize(currentWS - previousWS);
        //float3 viewDir = normalize(-dir);
        float perceptualRoughness = RoughnessToPerceptualRoughness(roughness);

        float3 results = SampleSkyTexture(viewDir, 5 * perceptualRoughness, 0) * GetCurrentExposureMultiplier();

        _OutputTexture[COORD_TEXTURE2D_X(dispatchThreadId.xy)] = float4(results, 1.0);
        return;
    }
#if 0
    else if (hitFar)
    {
        _OutputTexture[COORD_TEXTURE2D_X(dispatchThreadId.xy)] = float4(0.0f, 0.0f, 1.0f, 1.0f);
        return;
    }
    else
    {
        _OutputTexture[COORD_TEXTURE2D_X(dispatchThreadId.xy)] = float4(1.0, 0, 0, 1.0);
        return;
    }
#endif
    return;

#endif

    float3 coarseRefraction = float3(0,0,0);
    float4 radianceVal = float4(0, 0, 0, 0);
    float fresnelDielectricCoef;
    {
        //for (uint a = 0; a < listCount; ++a)
        //{
        //    int gOffset = a + listOffset;
        //    uint2 offscreenCoord = uint2(gOffset % GetOffscreenLightBufferWidth(), gOffset / GetOffscreenLightBufferWidth());
        //    float4 radSample = _VisOITOffscreenPhotonRadianceLighting[COORD_TEXTURE2D_X(offscreenCoord)];
        //    radianceVal += float4(radSample.xyz, radSample.a);
        //}

        //float4 radianceVal = float4(0,0,0,0);
        {
            uint2 offscreenCoord = uint2(globalOffset % GetOffscreenLightBufferWidth(), globalOffset / GetOffscreenLightBufferWidth());
            radianceVal = _VisOITOffscreenPhotonRadianceLighting[COORD_TEXTURE2D_X(offscreenCoord)];
        }

        PositionInputs posInputTransparent0 = GetPositionInput(dispatchThreadId.xy, _ScreenSize.zw, uint2(GROUP_SIZE, GROUP_SIZE));
        float3 firstSamplePositionWS = ComputeWorldSpacePosition(posInputTransparent0.positionNDC, firstDeviceDepth, UNITY_MATRIX_I_VP);
        float3 wo = normalize(_WorldSpaceCameraPos - firstSamplePositionWS);

        fresnelDielectricCoef = F_FresnelDielectric(ior, dot(normal, wo));

        coarseRefraction = radianceVal.xyz / radianceVal.a;
    }

    float3 directLighting = _VisOITOffscreenDirectReflectionLighting[COORD_TEXTURE2D_X(offscreenCoord)].rgb;
    // @kleber: TODO
    // _OutputTexture[COORD_TEXTURE2D_X(posInputRaw.positionSS.xy)] = float4(lerp(coarseRefraction, directLighting, fresnelDielectricCoef), 1.0);
    _OutputTexture[COORD_TEXTURE2D_X(posInputRaw.positionSS.xy)] = float4(lerp(coarseRefraction, directLighting, 0.2), 1.0);
}
