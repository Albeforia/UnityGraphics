#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/TextureXR.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Visibility/VisibilityOITResources.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/PostProcessing/Shaders/PostProcessDefines.hlsl"

//#pragma enable_d3d11_debug_symbols
#pragma only_renderers d3d11 playstation xboxone xboxseries vulkan metal switch

#pragma kernel OITSort_Init
#pragma kernel OITSort_BinPixels
#pragma kernel OITSort_Swap
#pragma kernel OITSort_Network_4
#pragma kernel OITSort_Network_8
#pragma kernel OITSort_GroupShared_Wave
#pragma kernel OITSort_GroupShared

// BUG: For some reason, the binding system refuses to work unless the visibility buffer resource is provided as read/write instead of read only.
//      This may have something to do with it moving from an SRV -> UAV descriptor type when the write capability is added.
//      When this is resolved, this section of code should be removed and this shader should use VisibilityOIT::GetVisibilitySamplePackedDepth instead.
RWByteAddressBuffer _RWVisOITBuffer;

uint GetVisibilitySamplePackedDepth(uint i, uint listOffset)
{
    return ((_RWVisOITBuffer.Load3(((listOffset + i) * 3) << 2).y >> 16) & 0xFFFF);
}

[numthreads(1, 1, 1)]
void OITSort_Init()
{
    uint previousSum = 0;

    // Calculate the pixel list offets via prefix sum
    for (uint sortVariantIndex = 0; sortVariantIndex < kSorting_NumVariants; ++sortVariantIndex)
    {
        uint currentSum = _OITSortMemoryBuffer[kSorting_SumsOffset + sortVariantIndex];

        _OITSortMemoryBuffer[kSorting_PixelListOffsetsOffset + sortVariantIndex] = previousSum;

        previousSum += currentSum;
    }

    // Set up indirect args
    // This part is unfortunately still manual since the shaders have different thread group sizes

    uint sum2     = _OITSortMemoryBuffer[kSorting_SumsOffset + 0];
    uint sum4     = _OITSortMemoryBuffer[kSorting_SumsOffset + 1];
    uint sum8     = _OITSortMemoryBuffer[kSorting_SumsOffset + 2];
    uint sumMed   = _OITSortMemoryBuffer[kSorting_SumsOffset + 3];
    uint sumBig   = _OITSortMemoryBuffer[kSorting_SumsOffset + 4];

    uint3 numGroups2     = uint3((sum2 + 63) / 64, 1, 1);
    uint3 numGroups4     = uint3((sum4 + 63) / 64, 1, 1);
    uint3 numGroups8     = uint3((sum8 + 63) / 64, 1, 1);
    uint3 numGroupsMed   = uint3(sumMed, 1, 1);
    uint3 numGroupsBig   = uint3(sumBig, 1, 1);

    _OITSortMemoryBuffer[kSorting_IndirectArgsOffset + 0]  = numGroups2.x;
    _OITSortMemoryBuffer[kSorting_IndirectArgsOffset + 1]  = numGroups2.y;
    _OITSortMemoryBuffer[kSorting_IndirectArgsOffset + 2]  = numGroups2.z;

    _OITSortMemoryBuffer[kSorting_IndirectArgsOffset + 3]  = numGroups4.x;
    _OITSortMemoryBuffer[kSorting_IndirectArgsOffset + 4]  = numGroups4.y;
    _OITSortMemoryBuffer[kSorting_IndirectArgsOffset + 5]  = numGroups4.z;

    _OITSortMemoryBuffer[kSorting_IndirectArgsOffset + 6]  = numGroups8.x;
    _OITSortMemoryBuffer[kSorting_IndirectArgsOffset + 7]  = numGroups8.y;
    _OITSortMemoryBuffer[kSorting_IndirectArgsOffset + 8]  = numGroups8.z;

    _OITSortMemoryBuffer[kSorting_IndirectArgsOffset + 9]  = numGroupsMed.x;
    _OITSortMemoryBuffer[kSorting_IndirectArgsOffset + 10] = numGroupsMed.y;
    _OITSortMemoryBuffer[kSorting_IndirectArgsOffset + 11] = numGroupsMed.z;

    _OITSortMemoryBuffer[kSorting_IndirectArgsOffset + 12] = numGroupsBig.x;
    _OITSortMemoryBuffer[kSorting_IndirectArgsOffset + 13] = numGroupsBig.y;
    _OITSortMemoryBuffer[kSorting_IndirectArgsOffset + 14] = numGroupsBig.z;
}

[numthreads(8, 8, 1)]
void OITSort_BinPixels(int3 dispatchThreadID : SV_DispatchThreadID)
{
    UNITY_XR_ASSIGN_VIEW_INDEX(dispatchThreadID.z);

    if (any(dispatchThreadID.xy >= (int2)_ScreenSize.xy))
        return;

    uint outputPixel = dispatchThreadID.y * (int)_ScreenSize.x + dispatchThreadID.x;
    uint listCount = _VisOITListsCounts.Load(outputPixel << 2);

    //// List sizes of 0 or 1 don't need any sorting
    if (listCount < 2)
        return;

    uint sortVariantOffset = Sorting::GetVariantOffset(listCount);

    uint sortCounterAddr = kSorting_CountersOffset + sortVariantOffset;
    uint sortIndexOffsetAddr = kSorting_PixelListOffsetsOffset + sortVariantOffset;

    uint globalSortIndexOffset = _OITSortMemoryBuffer[sortIndexOffsetAddr];
    uint localSortIndexOffset;
    InterlockedAdd(_OITSortMemoryBuffer[sortCounterAddr], 1, localSortIndexOffset);

    uint sortIndexAddr = kSorting_PixelListDataOffset + globalSortIndexOffset + localSortIndexOffset;
    _OITSortMemoryBuffer[sortIndexAddr] = outputPixel;
}

[numthreads(64, 1, 1)]
void OITSort_Swap(int3 dispatchThreadId : SV_DispatchThreadID)
{
    uint threadIndex = dispatchThreadId.x;

    // Load pixel index
    uint sortVariantOffset = 0;
    uint sortSumAddr = kSorting_SumsOffset + sortVariantOffset;

    uint numPixels = _OITSortMemoryBuffer[sortSumAddr];

    // Note: this is always 0 since this is the first group
    //uint sortIndexOffsetAddr = 6 + sortVariantOffset;
    //uint globalSortIndexOffset = _OITSortMemoryBuffer.Load(sortIndexOffsetAddr);
    uint globalSortIndexOffset = 0;

    if (threadIndex < numPixels)
    {
        uint pixelIndexAddr = kSorting_PixelListDataOffset + globalSortIndexOffset + threadIndex;
        uint pixelIndex = _OITSortMemoryBuffer[pixelIndexAddr];

        // This variant ONLY works on exactly 2 samples
        uint listCount = 2;
        uint listOffset = _VisOITListsOffsets.Load(pixelIndex << 2);

        uint sampleDepth0 = GetVisibilitySamplePackedDepth(0, listOffset);
        uint sampleDepth1 = GetVisibilitySamplePackedDepth(1, listOffset);

        uint keyIndex0 = 0;
        uint keyIndex1 = 1;

        if (sampleDepth0 < sampleDepth1)
        {
            keyIndex0 = 1;
            keyIndex1 = 0;
        }

        uint sortIndicesBaseAddr = kSorting_PixelListDataOffset + (_ScreenSize.x * _ScreenSize.y) + listOffset;

        _OITSortMemoryBuffer[sortIndicesBaseAddr + 0] = keyIndex0;
        _OITSortMemoryBuffer[sortIndicesBaseAddr + 1] = keyIndex1;
    }
}

// Please turn this into a v_swap ;)
void SwapUint(inout uint a, inout uint b)
{
    uint temp = a;
    a = b;
    b = temp;
}

uint GenerateSortKey(uint keyIndex, uint listCount, uint listOffset)
{
    uint key = 0;
    if (keyIndex < listCount)
    {
        uint packedDepth = GetVisibilitySamplePackedDepth(keyIndex, listOffset);
        key = ((packedDepth & 0xFFFF) << 16) | (0xFF << 8) | (keyIndex & 0xFF);
    }
    return key;
}

#define CSWAP(a, b) if (a < b) SwapUint(a, b)
#define MAX_NETWORK_INPUTS_4 4
#define MAX_NETWORK_INPUTS_8 8

[numthreads(64, 1, 1)]
void OITSort_Network_4(int3 dispatchThreadId : SV_DispatchThreadID)
{
    uint threadIndex = dispatchThreadId.x;

    uint sortVariantOffset = 1;
    uint sortIndexOffsetAddr = kSorting_PixelListOffsetsOffset + sortVariantOffset;
    uint globalSortIndexOffset = _OITSortMemoryBuffer.Load(sortIndexOffsetAddr);

    // Load pixel index
    uint sortSumAddr = kSorting_SumsOffset + sortVariantOffset;

    uint numPixels = _OITSortMemoryBuffer[sortSumAddr];

    if (threadIndex < numPixels)
    {
        uint pixelIndexAddr = kSorting_PixelListDataOffset + globalSortIndexOffset + threadIndex;
        uint pixelIndex = _OITSortMemoryBuffer[pixelIndexAddr];

        uint listCount = _VisOITListsCounts.Load(pixelIndex << 2);
        uint listOffset = _VisOITListsOffsets.Load(pixelIndex << 2);

        // Generate sort keys from depth
        uint sortKeys[MAX_NETWORK_INPUTS_4];
        for (uint sortKeyIndex = 0; sortKeyIndex < MAX_NETWORK_INPUTS_4; ++sortKeyIndex)
        {
            sortKeys[sortKeyIndex] = GenerateSortKey(sortKeyIndex, listCount, listOffset);
        }

        // Sort the keys
        CSWAP(sortKeys[0], sortKeys[1]);
        CSWAP(sortKeys[2], sortKeys[3]);
        CSWAP(sortKeys[0], sortKeys[2]);
        CSWAP(sortKeys[1], sortKeys[3]);
        CSWAP(sortKeys[1], sortKeys[2]);

        uint sortIndicesBaseAddr = kSorting_PixelListDataOffset + (_ScreenSize.x * _ScreenSize.y) + listOffset;

        for (uint storeIndex = 0; storeIndex < MAX_NETWORK_INPUTS_4; ++storeIndex)
        {
            uint sortedIndex = (sortKeys[storeIndex] & 0xFF);
            uint sortIndexAddr = sortIndicesBaseAddr + storeIndex;

            if (storeIndex < listCount)
            {
                _OITSortMemoryBuffer[sortIndexAddr] = sortedIndex;
            }
        }
    }
}

[numthreads(64, 1, 1)]
void OITSort_Network_8(int3 dispatchThreadId : SV_DispatchThreadID)
{
    uint threadIndex = dispatchThreadId.x;

    uint sortVariantOffset = 2;
    uint sortIndexOffsetAddr = kSorting_PixelListOffsetsOffset + sortVariantOffset;
    uint globalSortIndexOffset = _OITSortMemoryBuffer.Load(sortIndexOffsetAddr);

    // Load pixel index
    uint sortSumAddr = kSorting_SumsOffset + sortVariantOffset;

    uint numPixels = _OITSortMemoryBuffer[sortSumAddr];

    if (threadIndex < numPixels)
    {
        uint pixelIndexAddr = kSorting_PixelListDataOffset + globalSortIndexOffset + threadIndex;
        uint pixelIndex = _OITSortMemoryBuffer[pixelIndexAddr];

        uint listCount = _VisOITListsCounts.Load(pixelIndex << 2);
        uint listOffset = _VisOITListsOffsets.Load(pixelIndex << 2);

        // Generate sort keys from depth
        uint sortKeys[MAX_NETWORK_INPUTS_8];
        for (uint sortKeyIndex = 0; sortKeyIndex < MAX_NETWORK_INPUTS_8; ++sortKeyIndex)
        {
            sortKeys[sortKeyIndex] = GenerateSortKey(sortKeyIndex, listCount, listOffset);
        }

        // Sort the keys
        CSWAP(sortKeys[0], sortKeys[1]);
        CSWAP(sortKeys[2], sortKeys[3]);
        CSWAP(sortKeys[4], sortKeys[5]);
        CSWAP(sortKeys[6], sortKeys[7]);
        CSWAP(sortKeys[0], sortKeys[2]);
        CSWAP(sortKeys[1], sortKeys[3]);
        CSWAP(sortKeys[4], sortKeys[6]);
        CSWAP(sortKeys[5], sortKeys[7]);
        CSWAP(sortKeys[1], sortKeys[2]);
        CSWAP(sortKeys[5], sortKeys[6]);
        CSWAP(sortKeys[0], sortKeys[4]);
        CSWAP(sortKeys[3], sortKeys[7]);
        CSWAP(sortKeys[1], sortKeys[5]);
        CSWAP(sortKeys[2], sortKeys[6]);
        CSWAP(sortKeys[1], sortKeys[4]);
        CSWAP(sortKeys[3], sortKeys[6]);
        CSWAP(sortKeys[2], sortKeys[4]);
        CSWAP(sortKeys[3], sortKeys[5]);
        CSWAP(sortKeys[3], sortKeys[4]);

        uint sortIndicesBaseAddr = kSorting_PixelListDataOffset + (_ScreenSize.x * _ScreenSize.y) + listOffset;

        for (uint storeIndex = 0; storeIndex < MAX_NETWORK_INPUTS_8; ++storeIndex)
        {
            uint sortedIndex = (sortKeys[storeIndex] & 0xFF);
            uint sortIndexAddr = sortIndicesBaseAddr + storeIndex;

            if (storeIndex < listCount)
            {
                _OITSortMemoryBuffer[sortIndexAddr] = sortedIndex;
            }
        }
    }
}

groupshared uint sSums[16];
groupshared uint sKeys[256];

[numthreads(32, 1, 1)]
void OITSort_GroupShared_Wave(uint3 groupThreadId : SV_GroupThreadID, uint3 groupId: SV_GroupID)
{
    uint threadIndex = groupThreadId.x;

    // Load pixel index

    uint sortVariantOffset = 3;
    uint sortIndexOffsetAddr = kSorting_PixelListOffsetsOffset + sortVariantOffset;
    uint globalSortIndexOffset = _OITSortMemoryBuffer.Load(sortIndexOffsetAddr);

    uint pixelIndexAddr = kSorting_PixelListDataOffset + globalSortIndexOffset + groupId.x;
    uint pixelIndex = _OITSortMemoryBuffer[pixelIndexAddr];

    uint listCount = _VisOITListsCounts.Load(pixelIndex << 2);
    uint listOffset = _VisOITListsOffsets.Load(pixelIndex << 2);

    uint sortKey = GenerateSortKey(threadIndex, listCount, listOffset);

    // Flip the key so the depth is in the LSBs since we only sort the bottom 16-bits
    // Also flip the depth key value so we get a descending order sort
    sortKey = (sortKey << 16) | (0xFFFF - (sortKey >> 16));

    sKeys[threadIndex] = sortKey;

    // 16-bit radix sort (we don't bother sorting the top half since they contain indices)
    for (uint radixPassIndex = 0; radixPassIndex < 4; ++radixPassIndex)
    {
        sortKey = sKeys[threadIndex];

        // Initialize the sum bins to 0
        if (threadIndex < 16)
        {
            sSums[threadIndex] = 0;
        }

        uint binIndex = ((sortKey >> (radixPassIndex * 4)) & 0xF);

        GroupMemoryBarrierWithGroupSync();

        // Increment the bin associated with the current value to sort
        uint localOffset;
        InterlockedAdd(sSums[binIndex], 1, localOffset);

        GroupMemoryBarrierWithGroupSync();

        // Do a dumb exclusive prefix sum (replace this with a parallel version)
        if (threadIndex == 0)
        {
            uint previousSum = 0;

            for (uint binIndex = 0; binIndex < 16; ++binIndex)
            {
                uint currentSum = sSums[binIndex];
                sSums[binIndex] = previousSum;
                previousSum += currentSum;
            }
        }

        GroupMemoryBarrierWithGroupSync();

        uint newKeyIndex = sSums[binIndex] + localOffset;
        sKeys[newKeyIndex] = sortKey;

        GroupMemoryBarrierWithGroupSync();
    }

    // Load the final sort key for the current thread
    sortKey = sKeys[threadIndex];

    uint sortIndicesBaseAddr = kSorting_PixelListDataOffset + (_ScreenSize.x * _ScreenSize.y) + listOffset;
    uint sortIndexAddr = sortIndicesBaseAddr + threadIndex;

    uint sortedIndex = ((sortKey >> 16) & 0xFF);

    if (threadIndex < listCount)
    {
        _OITSortMemoryBuffer[sortIndexAddr] = sortedIndex;
    }
}

// TODO: Remove this once the serialized reorder step of radix sort is removed
groupshared uint sOutputKeys[256];

[numthreads(256, 1, 1)]
void OITSort_GroupShared(uint3 groupThreadId : SV_GroupThreadID, uint3 groupId: SV_GroupID)
{
    uint threadIndex = groupThreadId.x;

    // Load pixel index

    uint sortVariantOffset = 4;
    uint sortIndexOffsetAddr = kSorting_PixelListOffsetsOffset + sortVariantOffset;
    uint globalSortIndexOffset = _OITSortMemoryBuffer.Load(sortIndexOffsetAddr);

    uint pixelIndexAddr = kSorting_PixelListDataOffset + globalSortIndexOffset + groupId.x;
    uint pixelIndex = _OITSortMemoryBuffer[pixelIndexAddr];

    uint listCount = _VisOITListsCounts.Load(pixelIndex << 2);
    uint listOffset = _VisOITListsOffsets.Load(pixelIndex << 2);

    uint sortKey = GenerateSortKey(threadIndex, listCount, listOffset);

    // Flip the key so the depth is in the LSBs since we only sort the bottom 16-bits
    // Also flip the depth key value so we get a descending order sort
    sortKey = (sortKey << 16) | (0xFFFF - (sortKey >> 16));

    sKeys[threadIndex] = sortKey;

    // 16-bit radix sort (we don't bother sorting the top half since they contain indices)
    for (uint radixPassIndex = 0; radixPassIndex < 4; ++radixPassIndex)
    {
        sortKey = sKeys[threadIndex];

        // Initialize the sum bins to 0
        if (threadIndex < 16)
        {
            sSums[threadIndex] = 0;
        }

        uint binIndex = ((sortKey >> (radixPassIndex * 4)) & 0xF);

        GroupMemoryBarrierWithGroupSync();

        // Increment the bin associated with the current value to sort
        uint localOffset;
        InterlockedAdd(sSums[binIndex], 1, localOffset);

        GroupMemoryBarrierWithGroupSync();

        // Do a dumb inclusive prefix sum (replace this with a parallel version)
        if (threadIndex == 0)
        {
            uint previousSum = sSums[0];

            for (uint binIndex = 1; binIndex < 16; ++binIndex)
            {
                uint currentSum = previousSum + sSums[binIndex];
                previousSum = currentSum;

                sSums[binIndex] = currentSum;
            }
        }

        GroupMemoryBarrierWithGroupSync();

        // This is even worse than the prefix sum above! :(
        if (threadIndex == 0)
        {
            uint i = 0;
            for (i = 0; i < 256; ++i)
            {
                uint val = sKeys[255 - i];
                uint localBinIndex = ((val >> (radixPassIndex * 4)) & 0xF);
                uint index = sSums[localBinIndex] - 1;
                sOutputKeys[index] = val;
                sSums[localBinIndex] = index;
                GroupMemoryBarrier();
            }

            for (i = 0; i < 256; ++i)
            {
                sKeys[i] = sOutputKeys[i];
            }
        }

        GroupMemoryBarrierWithGroupSync();
    }

    // Load the final sort key for the current thread
    sortKey = sKeys[threadIndex];

    uint sortIndicesBaseAddr = kSorting_PixelListDataOffset + (_ScreenSize.x * _ScreenSize.y) + listOffset;
    uint sortIndexAddr = sortIndicesBaseAddr + threadIndex;

    uint sortedIndex = ((sortKey >> 16) & 0xFF);

    if (threadIndex < listCount)
    {
        _OITSortMemoryBuffer[sortIndexAddr] = sortedIndex;
    }
}
